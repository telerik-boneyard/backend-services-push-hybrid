/*
The MIT License (MIT)

Copyright (c) 2016 Telerik AD

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.y distributed under the MIT license.

Everlive SDK Version: 1.7.0
*/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Everlive = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        };

        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":5}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":5}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],7:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":6,"_process":5,"inherits":3}],8:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":9}],9:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":10,"./lib/stringify":11}],10:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],11:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],12:[function(require,module,exports){
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.5
 * @author Jon Nylander
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */

/*jslint undef: true */
/*global console, exports*/

(function(root) {
  /**
   * Namespace to hold all the code for timezone detection.
   */
  var jstz = (function () {
      'use strict';
      var HEMISPHERE_SOUTH = 's',
          
          /**
           * Gets the offset in minutes from UTC for a certain date.
           * @param {Date} date
           * @returns {Number}
           */
          get_date_offset = function (date) {
              var offset = -date.getTimezoneOffset();
              return (offset !== null ? offset : 0);
          },

          get_date = function (year, month, date) {
              var d = new Date();
              if (year !== undefined) {
                d.setFullYear(year);
              }
              d.setMonth(month);
              d.setDate(date);
              return d;
          },

          get_january_offset = function (year) {
              return get_date_offset(get_date(year, 0 ,2));
          },

          get_june_offset = function (year) {
              return get_date_offset(get_date(year, 5, 2));
          },

          /**
           * Private method.
           * Checks whether a given date is in daylight saving time.
           * If the date supplied is after august, we assume that we're checking
           * for southern hemisphere DST.
           * @param {Date} date
           * @returns {Boolean}
           */
          date_is_dst = function (date) {
              var is_southern = date.getMonth() > 7,
                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
                                              get_january_offset(date.getFullYear()),
                  date_offset = get_date_offset(date),
                  is_west = base_offset < 0,
                  dst_offset = base_offset - date_offset;
                  
              if (!is_west && !is_southern) {
                  return dst_offset < 0;
              }

              return dst_offset !== 0;
          },

          /**
           * This function does some basic calculations to create information about
           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
           * the script has been tested rather than depend on the year set by the
           * client device.
           *
           * Returns a key that can be used to do lookups in jstz.olson.timezones.
           * eg: "720,1,2". 
           *
           * @returns {String}
           */

          lookup_key = function () {
              var january_offset = get_january_offset(),
                  june_offset = get_june_offset(),
                  diff = january_offset - june_offset;

              if (diff < 0) {
                  return january_offset + ",1";
              } else if (diff > 0) {
                  return june_offset + ",1," + HEMISPHERE_SOUTH;
              }

              return january_offset + ",0";
          },

          /**
           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
           *
           * Returns a primitive object on the format:
           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
           *
           * @returns Object
           */
          determine = function () {
              var key = lookup_key();
              return new jstz.TimeZone(jstz.olson.timezones[key]);
          },

          /**
           * This object contains information on when daylight savings starts for
           * different timezones.
           *
           * The list is short for a reason. Often we do not have to be very specific
           * to single out the correct timezone. But when we do, this list comes in
           * handy.
           *
           * Each value is a date denoting when daylight savings starts for that timezone.
           */
          dst_start_for = function (tz_name) {

            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
                dst_starts = {
                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
                    'Europe/Moscow': ru_pre_dst_change,
                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
                    'Asia/Yekaterinburg': ru_pre_dst_change,
                    'Asia/Omsk': ru_pre_dst_change,
                    'Asia/Krasnoyarsk': ru_pre_dst_change,
                    'Asia/Irkutsk': ru_pre_dst_change,
                    'Asia/Yakutsk': ru_pre_dst_change,
                    'Asia/Vladivostok': ru_pre_dst_change,
                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
                    'Asia/Kamchatka': ru_pre_dst_change,
                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
                    'Europe/Minsk': ru_pre_dst_change,
                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
                };

              return dst_starts[tz_name];
          };

      return {
          determine: determine,
          date_is_dst: date_is_dst,
          dst_start_for: dst_start_for 
      };
  }());

  /**
   * Simple object to perform ambiguity check and to return name of time zone.
   */
  jstz.TimeZone = function (tz_name) {
      'use strict';
        /**
         * The keys in this object are timezones that we know may be ambiguous after
         * a preliminary scan through the olson_tz object.
         *
         * The array of timezones to compare must be in the order that daylight savings
         * starts for the regions.
         */
      var AMBIGUITIES = {
              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
              'America/New_York':     ['America/Havana', 'America/New_York'],
              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
              'Asia/Dubai':           ['Europe/Moscow'],
              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
              'Asia/Jakarta':         ['Asia/Omsk'],
              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
              'Asia/Tokyo':           ['Asia/Irkutsk'],
              'Australia/Brisbane':   ['Asia/Yakutsk'],
              'Pacific/Noumea':       ['Asia/Vladivostok'],
              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
              'Pacific/Tongatapu':    ['Pacific/Apia'],
              'Asia/Baghdad':         ['Europe/Minsk'],
              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
          },

          timezone_name = tz_name,
          
          /**
           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
           *
           * For example, if the preliminary scan determines that we're in America/Denver.
           * We double check here that we're really there and not in America/Mazatlan.
           *
           * This is done by checking known dates for when daylight savings start for different
           * timezones during 2010 and 2011.
           */
          ambiguity_check = function () {
              var ambiguity_list = AMBIGUITIES[timezone_name],
                  length = ambiguity_list.length,
                  i = 0,
                  tz = ambiguity_list[0];

              for (; i < length; i += 1) {
                  tz = ambiguity_list[i];

                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
                      timezone_name = tz;
                      return;
                  }
              }
          },

          /**
           * Checks if it is possible that the timezone is ambiguous.
           */
          is_ambiguous = function () {
              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
          };

      if (is_ambiguous()) {
          ambiguity_check();
      }

      return {
          name: function () {
              return timezone_name;
          }
      };
  };

  jstz.olson = {};

  /*
   * The keys in this dictionary are comma separated as such:
   *
   * First the offset compared to UTC time in minutes.
   *
   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
   * does.
   *
   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
   * only interesting for timezones with DST.
   *
   * The mapped arrays is used for constructing the jstz.TimeZone object from within
   * jstz.determine_timezone();
   */
  jstz.olson.timezones = {
      '-720,0'   : 'Pacific/Majuro',
      '-660,0'   : 'Pacific/Pago_Pago',
      '-600,1'   : 'America/Adak',
      '-600,0'   : 'Pacific/Honolulu',
      '-570,0'   : 'Pacific/Marquesas',
      '-540,0'   : 'Pacific/Gambier',
      '-540,1'   : 'America/Anchorage',
      '-480,1'   : 'America/Los_Angeles',
      '-480,0'   : 'Pacific/Pitcairn',
      '-420,0'   : 'America/Phoenix',
      '-420,1'   : 'America/Denver',
      '-360,0'   : 'America/Guatemala',
      '-360,1'   : 'America/Chicago',
      '-360,1,s' : 'Pacific/Easter',
      '-300,0'   : 'America/Bogota',
      '-300,1'   : 'America/New_York',
      '-270,0'   : 'America/Caracas',
      '-240,1'   : 'America/Halifax',
      '-240,0'   : 'America/Santo_Domingo',
      '-240,1,s' : 'America/Santiago',
      '-210,1'   : 'America/St_Johns',
      '-180,1'   : 'America/Godthab',
      '-180,0'   : 'America/Argentina/Buenos_Aires',
      '-180,1,s' : 'America/Montevideo',
      '-120,0'   : 'America/Noronha',
      '-120,1'   : 'America/Noronha',
      '-60,1'    : 'Atlantic/Azores',
      '-60,0'    : 'Atlantic/Cape_Verde',
      '0,0'      : 'UTC',
      '0,1'      : 'Europe/London',
      '60,1'     : 'Europe/Berlin',
      '60,0'     : 'Africa/Lagos',
      '60,1,s'   : 'Africa/Windhoek',
      '120,1'    : 'Asia/Beirut',
      '120,0'    : 'Africa/Johannesburg',
      '180,0'    : 'Asia/Baghdad',
      '180,1'    : 'Europe/Moscow',
      '210,1'    : 'Asia/Tehran',
      '240,0'    : 'Asia/Dubai',
      '240,1'    : 'Asia/Baku',
      '270,0'    : 'Asia/Kabul',
      '300,1'    : 'Asia/Yekaterinburg',
      '300,0'    : 'Asia/Karachi',
      '330,0'    : 'Asia/Kolkata',
      '345,0'    : 'Asia/Kathmandu',
      '360,0'    : 'Asia/Dhaka',
      '360,1'    : 'Asia/Omsk',
      '390,0'    : 'Asia/Rangoon',
      '420,1'    : 'Asia/Krasnoyarsk',
      '420,0'    : 'Asia/Jakarta',
      '480,0'    : 'Asia/Shanghai',
      '480,1'    : 'Asia/Irkutsk',
      '525,0'    : 'Australia/Eucla',
      '525,1,s'  : 'Australia/Eucla',
      '540,1'    : 'Asia/Yakutsk',
      '540,0'    : 'Asia/Tokyo',
      '570,0'    : 'Australia/Darwin',
      '570,1,s'  : 'Australia/Adelaide',
      '600,0'    : 'Australia/Brisbane',
      '600,1'    : 'Asia/Vladivostok',
      '600,1,s'  : 'Australia/Sydney',
      '630,1,s'  : 'Australia/Lord_Howe',
      '660,1'    : 'Asia/Kamchatka',
      '660,0'    : 'Pacific/Noumea',
      '690,0'    : 'Pacific/Norfolk',
      '720,1,s'  : 'Pacific/Auckland',
      '720,0'    : 'Pacific/Tarawa',
      '765,1,s'  : 'Pacific/Chatham',
      '780,0'    : 'Pacific/Tongatapu',
      '780,1,s'  : 'Pacific/Apia',
      '840,0'    : 'Pacific/Kiritimati'
  };

  if (typeof exports !== 'undefined') {
    exports.jstz = jstz;
  } else {
    root.jstz = jstz;
  }
})(this);


},{}],13:[function(require,module,exports){
// Mingo.js 0.6.2
// Copyright (c) 2015 Francis Asante <kofrasa@gmail.com>
// MIT

;
(function (root, undefined) {

  "use strict";

  // global on the server, window in the browser
  var Mingo = {}, previousMingo;
  var _;

  Mingo.VERSION = '0.6.2';

  // backup previous Mingo
  if (root != null) {
    previousMingo = root.Mingo;
  }

  Mingo.noConflict = function () {
    root.Mingo = previousMingo;
    return Mingo;
  };

  var nativeScriptEnabled = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
  || (typeof UIButton !== 'undefined' && UIButton)));

  var nodeEnabled = ('undefined' !== typeof exports && 'undefined' !== typeof require && 'undefined' === typeof window && !nativeScriptEnabled);

  var browserifyEnabled = 'undefined' !== typeof exports && 'undefined' !== typeof require;

  // Export the Mingo object for Node.js
  if (nodeEnabled || nativeScriptEnabled || browserifyEnabled) {
    if (typeof module !== 'undefined') {
      module.exports = Mingo;
    }
    _ = require("underscore"); // get a reference to underscore
  } else {
    root.Mingo = Mingo;
    _ = root._; // get a reference to underscore
  }

  // quick reference for
  var primitives = [
    _.isString, _.isBoolean, _.isNumber, _.isDate, _.isNull, _.isRegExp
  ];

  function isPrimitive(value) {
    for (var i = 0; i < primitives.length; i++) {
      if (primitives[i](value)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Simplify expression for easy evaluation with query operators map
   * @param expr
   * @returns {*}
   */
  function normalize(expr) {

    // normalized primitives
    if (isPrimitive(expr)) {
      return _.isRegExp(expr) ? {"$regex": expr} : {"$eq": expr};
    }

    // normalize object expression
    if (_.isObject(expr)) {
      var keys = _.keys(expr);
      var notQuery = _.intersection(ops(OP_QUERY), keys).length === 0;

      // no valid query operator found, so we do simple comparison
      if (notQuery) {
        return {"$eq": expr};
      }

      // ensure valid regex
      if (_.contains(keys, "$regex")) {
        var regex = expr['$regex'];
        var options = expr['$options'] || "";
        var modifiers = "";
        if (_.isString(regex)) {
          modifiers += (regex.ignoreCase || options.indexOf("i") >= 0) ? "i" : "";
          modifiers += (regex.multiline || options.indexOf("m") >= 0) ? "m" : "";
          modifiers += (regex.global || options.indexOf("g") >= 0) ? "g" : "";
          regex = new RegExp(regex, modifiers);
        }
        expr['$regex'] = regex;
        delete expr['$options'];
      }
    }

    return expr;
  }

  // Settings used by Mingo internally
  var settings = {
    key: "_id"
  };

  /**
   * Setup default settings for Mingo
   * @param options
   */
  Mingo.setup = function (options) {
    _.extend(settings, options || {});
  };


  /**
   * Query object to test collection elements with
   * @param criteria the pass criteria for the query
   * @param projection optional projection specifiers
   * @constructor
   */
  Mingo.Query = function (criteria, projection) {
    if (!(this instanceof Mingo.Query))
      return new Mingo.Query(criteria, projection);

    this._criteria = criteria;
    this._projection = projection;
    this._compiled = [];
    this._compile();
  };

  Mingo.Query.prototype = {

    _compile: function () {

      if (_.isEmpty(this._criteria)) return;

      if (_.isArray(this._criteria) || _.isFunction(this._criteria) || !_.isObject(this._criteria)) {
        throw new Error("Invalid type for criteria");
      }

      for (var field in this._criteria) {
        if (this._criteria.hasOwnProperty(field)) {
          var expr = this._criteria[field];
          if (_.contains(['$and', '$or', '$nor', '$where'], field)) {
            this._processOperator(field, field, expr);
          } else {
            // normalize expression
            expr = normalize(expr);
            for (var op in expr) {
              if (expr.hasOwnProperty(op)) {
                this._processOperator(field, op, expr[op]);
              }
            }
          }
        }
      }
    },

    _processOperator: function (field, operator, value) {
      if (_.contains(ops(OP_QUERY), operator)) {
        this._compiled.push(queryOperators[operator](field, value));
      } else {
        throw new Error("Invalid query operator '" + operator + "' detected");
      }
    },

    /**
     * Checks if the object passes the query criteria. Returns true if so, false otherwise.
     * @param obj
     * @returns {boolean}
     */
    test: function (obj) {
      for (var i = 0; i < this._compiled.length; i++) {
        if (!this._compiled[i].test(obj)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Performs a query on a collection and returns a cursor object.
     * @param collection
     * @param projection
     * @returns {Mingo.Cursor}
     */
    find: function (collection, projection) {
      return new Mingo.Cursor(collection, this, projection);
    },

    /**
     * Remove matched documents from the collection returning the remainder
     * @param collection
     * @returns {Array}
     */
    remove: function (collection) {
      var arr = [];
      for (var i = 0; i < collection.length; i++) {
        if (!this.test(collection[i])) {
          arr.push(collection[i]);
        }
      }
      return arr;
    }
  };

  if (nodeEnabled) {

    var Transform = require('stream').Transform;
    var util = require('util');

    Mingo.Query.prototype.stream = function (options) {
      return new Mingo.Stream(this, options);
    };

    /**
     * Create a Transform class
     * @param query
     * @param options
     * @returns {Mingo.Stream}
     * @constructor
     */
    Mingo.Stream = function (query, options) {

      if (!(this instanceof Mingo.Stream))
        return new Mingo.Stream(query, options);

      options = options || {};
      _.extend(options, {objectMode: true});
      Transform.call(this, options);
      // query for this stream
      this._query = query;
    };
    // extend Transform
    util.inherits(Mingo.Stream, Transform);

    Mingo.Stream.prototype._transform = function (chunk, encoding, done) {
      if (_.isObject(chunk) && this._query.test(chunk)) {
        if (_.isEmpty(this._query._projection)) {
          this.push(chunk);
        } else {
          var cursor = new Mingo.Cursor([chunk], this._query);
          if (cursor.hasNext()) {
            this.push(cursor.next());
          }
        }
      }
      done();
    };
  }

  /**
   * Cursor to iterate and perform filtering on matched objects
   * @param collection
   * @param query
   * @param projection
   * @constructor
   */
  Mingo.Cursor = function (collection, query, projection) {

    if (!(this instanceof Mingo.Cursor))
      return new Mingo.Cursor(collection, query, projection);

    this._query = query;
    this._collection = collection;
    this._projection = projection || query._projection;
    this._operators = {};
    this._result = false;
    this._position = 0;
  };

  Mingo.Cursor.prototype = {

    _fetch: function () {
      var self = this;

      if (this._result !== false) {
        return this._result;
      }

      // inject projection operator
      if (_.isObject(this._projection)) {
        _.extend(this._operators, {"$project": this._projection});
      }

      // if (!_.isArray(this._collection) && !_.isObject(this._collection)) {
      //   throw new Error("Input collection is not of valid type. Must be an Array.");
      // }

      // filter collection
      this._result = _.filter(this._collection, this._query.test, this._query);
      var pipeline = [];

      _.each(['$sort', '$skip', '$limit', '$project'], function (op) {
        if (_.has(self._operators, op)) {
          pipeline.push(_.pick(self._operators, op));
        }
      });

      if (pipeline.length > 0) {
        var aggregator = new Mingo.Aggregator(pipeline);
        this._result = aggregator.run(this._result, this._query);
      }
      return this._result;
    },

    /**
     * Fetch and return all matched results
     * @returns {Array}
     */
    all: function () {
      return this._fetch();
    },

    /**
     * Fetch and return the first matching result
     * @returns {Object}
     */
    first: function () {
      return this.count() > 0 ? this._fetch()[0] : null;
    },

    /**
     * Fetch and return the last matching object from the result
     * @returns {Object}
     */
    last: function () {
      return this.count() > 0 ? this._fetch()[this.count() - 1] : null;
    },

    /**
     * Counts the number of matched objects found
     * @returns {Number}
     */
    count: function () {
      return this._fetch().length;
    },

    /**
     * Returns a cursor that begins returning results only after passing or skipping a number of documents.
     * @param {Number} n the number of results to skip.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    skip: function (n) {
      _.extend(this._operators, {"$skip": n});
      return this;
    },

    /**
     * Constrains the size of a cursor's result set.
     * @param {Number} n the number of results to limit to.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    limit: function (n) {
      _.extend(this._operators, {"$limit": n});
      return this;
    },

    /**
     * Returns results ordered according to a sort specification.
     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    sort: function (modifier) {
      _.extend(this._operators, {"$sort": modifier});
      return this;
    },

    /**
     * Returns the next document in a cursor.
     * @returns {Object | Boolean}
     */
    next: function () {
      if (this.hasNext()) {
        return this._fetch()[this._position++];
      }
      return null;
    },

    /**
     * Returns true if the cursor has documents and can be iterated.
     * @returns {boolean}
     */
    hasNext: function () {
      return this.count() > this._position;
    },

    /**
     * Specifies the exclusive upper bound for a specific field
     * @param expr
     * @returns {Number}
     */
    max: function (expr) {
      return groupOperators.$max(this._fetch(), expr);
    },

    /**
     * Specifies the inclusive lower bound for a specific field
     * @param expr
     * @returns {Number}
     */
    min: function (expr) {
      return groupOperators.$min(this._fetch(), expr);
    },

    /**
     * Applies a function to each document in a cursor and collects the return values in an array.
     * @param callback
     * @returns {Array}
     */
    map: function (callback) {
      return _.map(this._fetch(), callback);
    },

    /**
     * Applies a JavaScript function for every document in a cursor.
     * @param callback
     */
    forEach: function (callback) {
      _.each(this._fetch(), callback);
    }

  };

  /**
   * Aggregator for defining filter using mongoDB aggregation pipeline syntax
   * @param operators an Array of pipeline operators
   * @constructor
   */
  Mingo.Aggregator = function (operators) {
    if (!(this instanceof Mingo.Aggregator))
      return new Mingo.Aggregator(operators);

    this._operators = operators;
  };

  Mingo.Aggregator.prototype = {

    /**
     * Apply the pipeline operations over the collection by order of the sequence added
     * @param collection an array of objects to process
     * @param query the `Mingo.Query` object to use as context
     * @returns {Array}
     */
    run: function (collection, query) {
      if (!_.isEmpty(this._operators)) {
        // run aggregation pipeline
        for (var i = 0; i < this._operators.length; i++) {
          var operator = this._operators[i];
          var key = _.keys(operator);
          if (key.length == 1 && _.contains(ops(OP_PIPELINE), key[0])) {
            key = key[0];
            if (query instanceof Mingo.Query) {
              collection = pipelineOperators[key].call(query, collection, operator[key]);
            } else {
              collection = pipelineOperators[key](collection, operator[key]);
            }
          } else {
            throw new Error("Invalid aggregation operator '" + key + "'");
          }
        }
      }
      return collection;
    }
  };

  /**
   * Retrieve the value of a given key on an object
   * @param obj
   * @param field
   * @returns {*}
   * @private
   */
  function getValue(obj, field) {
    return _.result(obj, field);
  }

  /**
   * Resolve the value of the field (dot separated) on the given object
   * @param obj
   * @param field
   * @returns {*}
   */
  function resolve(obj, field) {
    if (!field) {
      return undefined;
    }
    var names = field.split(".");
    var value = obj;
    var isText;

    for (var i = 0; i < names.length; i++) {
      isText = names[i].match(/^\d+$/) === null;

      if (isText && _.isArray(value)) {
        var res = [];
        _.each(value, function (item) {
          res.push(resolve(item, names[i]));
        });
        value = res;
      } else {
        value = getValue(value, names[i]);
      }

      if (value === undefined) {
        break;
      }
    }

    return value;
  }

  /**
   * Performs a query on a collection and returns a cursor object.
   * @param collection
   * @param criteria
   * @param projection
   * @returns {Mingo.Cursor}
   */
  Mingo.find = function (collection, criteria, projection) {
    return (new Mingo.Query(criteria)).find(collection, projection);
  };

  /**
   * Returns a new array without objects which match the criteria
   * @param collection
   * @param criteria
   * @returns {Array}
   */
  Mingo.remove = function (collection, criteria) {
    return (new Mingo.Query(criteria)).remove(collection);
  };

  /**
   * Return the result collection after running the aggregation pipeline for the given collection
   * @param collection
   * @param pipeline
   * @returns {Array}
   */
  Mingo.aggregate = function (collection, pipeline) {
    if (!_.isArray(pipeline)) {
      throw new Error("Aggregation pipeline must be an array");
    }
    return (new Mingo.Aggregator(pipeline)).run(collection);
  };

  /**
   * Add new operators
   * @param type the operator type to extend
   * @param f a function returning an object of new operators
   */
  Mingo.addOperators = function (type, f) {
    var newOperators = f({
      resolve: resolve,
      computeValue: computeValue,
      ops: ops,
      key: function () {
        return settings.key;
      }
    });

    // ensure correct type specified
    if (!_.contains([OP_AGGREGATE, OP_GROUP, OP_PIPELINE, OP_PROJECTION, OP_QUERY], type)) {
      throw new Error("Could not identify type '" + type + "'");
    }

    var operators = ops(type);

    // check for existing operators
    _.each(_.keys(newOperators), function (op) {
      if (!/^\$\w+$/.test(op)) {
        throw new Error("Invalid operator name '" + op + "'");
      }
      if (_.contains(operators, op)) {
        throw new Error("Operator " + op + " is already defined for " + type + " operators");
      }
    });

    var wrapped = {};

    switch (type) {
      case OP_QUERY:
        _.each(_.keys(newOperators), function (op) {
          wrapped[op] = (function (f, ctx) {
            return function (selector, value) {
              return {
                test: function (obj) {
                  // value of field must be fully resolved.
                  var lhs = resolve(obj, selector);
                  var result = f.call(ctx, selector, lhs, value);
                  if (_.isBoolean(result)) {
                    return result;
                  } else if (result instanceof Mingo.Query) {
                    return result.test(obj);
                  } else {
                    throw new Error("Invalid return type for '" + op + "'. Must return a Boolean or Mingo.Query");
                  }
                }
              };
            }
          }(newOperators[op], newOperators));
        });
        break;
      case OP_PROJECTION:
        _.each(_.keys(newOperators), function (op) {
          wrapped[op] = (function (f, ctx) {
            return function (obj, expr, selector) {
              var lhs = resolve(obj, selector);
              return f.call(ctx, selector, lhs, expr);
            }
          }(newOperators[op], newOperators));
        });
        break;
      default:
        _.each(_.keys(newOperators), function (op) {
          wrapped[op] = (function (f, ctx) {
            return function () {
              var args = Array.prototype.slice.call(arguments);
              return f.apply(ctx, args);
            }
          }(newOperators[op], newOperators));
        });
    }

    // toss the operator salad :)
    _.extend(OPERATORS[type], wrapped);

  };

  /**
   * Mixin for Backbone.Collection objects
   */
  Mingo.CollectionMixin = {
    /**
     * Runs a query and returns a cursor to the result
     * @param criteria
     * @param projection
     * @returns {Mingo.Cursor}
     */
    query: function (criteria, projection) {
      return Mingo.find(this.toJSON(), criteria, projection);
    },

    /**
     * Runs the given aggregation operators on this collection
     * @params pipeline
     * @returns {Array}
     */
    aggregate: function (pipeline) {
      var args = [this.toJSON(), pipeline];
      return Mingo.aggregate.apply(null, args);
    }
  };

  var pipelineOperators = {

    /**
     * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $group: function (collection, expr) {
      // lookup key for grouping
      var idKey = expr[settings.key];

      var partitions = groupBy(collection, function (obj) {
        return computeValue(obj, idKey, idKey);
      });

      var result = [];

      // remove the group key
      expr = _.omit(expr, settings.key);

      _.each(partitions.keys, function (value, i) {
        var obj = {};

        // exclude undefined key value
        if (!_.isUndefined(value)) {
          obj[settings.key] = value;
        }

        // compute remaining keys in expression
        for (var key in expr) {
          if (expr.hasOwnProperty(key)) {
            obj[key] = accumulate(partitions.groups[i], key, expr[key]);
          }
        }
        result.push(obj);
      });

      return result;
    },

    /**
     * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.
     * $match uses standard MongoDB queries.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $match: function (collection, expr) {
      return (new Mingo.Query(expr)).find(collection).all();
    },

    /**
     * Reshapes a document stream.
     * $project can rename, add, or remove fields as well as create computed values and sub-documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $project: function (collection, expr) {

      if (_.isEmpty(expr)) {
        return collection;
      }
      var usesExclusion = false;
      _.each(expr, function(val, key) {
        if(val === 0 && key !== settings.key) {
           usesExclusion = true;
        }
        if(val !== 0 && usesExclusion) {
            throw new Error("You cannot mix including and excluding fields."); 
        }
      });

      // result collection
      var projected = [];
      var objKeys = _.keys(expr);
      var idOnlyExcludedExpression = false;

      if (_.contains(objKeys, settings.key)) {
        var id = expr[settings.key];
        if (id === 0 || id === false) {
          objKeys = _.without(objKeys, settings.key);
          if (_.isEmpty(objKeys)) {
            idOnlyExcludedExpression = true;
          }
        }
      } else {
        // if not specified the add the ID field
        objKeys.push(settings.key);
      }

      for (var i = 0; i < collection.length; i++) {

        var obj = collection[i];
        var cloneObj = {};
        var foundSlice = false;
        var foundExclusion = false;
        var dropKeys = [];
        if (idOnlyExcludedExpression) {
          dropKeys.push(settings.key);
        }

        _.each(objKeys, function (key) {

          var subExpr = expr[key];
          var newValue;
          if (key !== settings.key && subExpr === 0) {
            foundExclusion = true;
          }

          // tiny optimization here to skip over id
          if (key === settings.key && _.isEmpty(subExpr)) {
            newValue = obj[key];
          } else if (_.isString(subExpr)) {
            newValue = computeValue(obj, subExpr, key);
          } else if (subExpr === 1 || subExpr === true) {
            newValue = _.result(obj, key);
          } else if (_.isObject(subExpr)) {
            var operator = _.keys(subExpr);
            operator = operator.length > 1 ? false : operator[0];
            if (operator !== false && _.contains(ops(OP_PROJECTION), operator)) {
              // apply the projection operator on the operator expression for the key
              var temp = projectionOperators[operator](obj, subExpr[operator], key);
              if (!_.isUndefined(temp)) {
                newValue = temp;
              }
              if (operator == '$slice') {
                foundSlice = true;
              }
            } else {
              // compute the value for the sub expression for the key
              newValue = computeValue(obj, subExpr, key);
            }
          } else {
            dropKeys.push(key);
          }

          if (!_.isUndefined(newValue)) {
            cloneObj[key] = newValue;
          }
        });
        // if projection included $slice operator
        // Also if exclusion fields are found or we want to exclude only the id field
        // include keys that were not explicitly excluded
        if (foundSlice || foundExclusion || idOnlyExcludedExpression) {
          cloneObj = _.defaults(cloneObj, _.omit(obj, dropKeys));
        }
        projected.push(cloneObj);
      }

      return projected;
    },

    /**
     * Restricts the number of documents in an aggregation pipeline.
     *
     * @param collection
     * @param value
     * @returns {Object|*}
     */
    $limit: function (collection, value) {
      return _.first(collection, value);
    },

    /**
     * Skips over a specified number of documents from the pipeline and returns the rest.
     *
     * @param collection
     * @param value
     * @returns {*}
     */
    $skip: function (collection, value) {
      return _.rest(collection, value);
    },

    /**
     * Takes an array of documents and returns them as a stream of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $unwind: function (collection, expr) {
      var result = [];
      var field = expr.substr(1);
      for (var i = 0; i < collection.length; i++) {
        var obj = collection[i];
        // must throw an error if value is not an array
        var value = getValue(obj, field);
        if (_.isArray(value)) {
          _.each(value, function (item) {
            var tmp = _.clone(obj);
            tmp[field] = item;
            result.push(tmp);
          });
        } else {
          throw new Error("Target field '" + field + "' is not of type Array.");
        }
      }
      return result;
    },

    /**
     * Takes all input documents and returns them in a stream of sorted documents.
     *
     * @param collection
     * @param sortKeys
     * @returns {*}
     */
    $sort: function (collection, sortKeys) {
      if (!_.isEmpty(sortKeys) && _.isObject(sortKeys)) {
        var modifiers = _.keys(sortKeys);
        modifiers.reverse().forEach(function (key) {
          var indexes = [];
          var grouped = _.groupBy(collection, function (obj) {
            var value = resolve(obj, key);
            indexes.push(value);
            return value;
          });
          indexes = _.sortBy(_.uniq(indexes), function (item) {
            return item;
          });
          if (sortKeys[key] === -1) {
            indexes.reverse();
          }
          collection = [];
          _.each(indexes, function (item) {
            Array.prototype.push.apply(collection, grouped[item]);
          });
        });
      }
      return collection;
    }
  };

  ////////// QUERY OPERATORS //////////
  var queryOperators = {};

  var compoundOperators = {

    /**
     * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $and: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $and criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (!queries[i].test(obj)) {
              return false;
            }
          }
          return true;
        }
      };
    },

    /**
     * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $or: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $or criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (queries[i].test(obj)) {
              return true;
            }
          }
          return false;
        }
      };
    },

    /**
     * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $nor: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $nor criteria");
      }
      var query = this.$or("$or", value);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Inverts the effect of a query expression and returns documents that do not match the query expression.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $not: function (selector, value) {
      var criteria = {};
      criteria[selector] = normalize(value);
      var query = new Mingo.Query(criteria);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Matches documents that satisfy a JavaScript expression.
     *
     * @param selector
     * @param value
     * @returns {{test: test}}
     */
    $where: function (selector, value) {
      if (!_.isFunction(value)) {
        value = new Function("return " + value + ";");
      }
      return {
        test: function (obj) {
          return value.call(obj) === true;
        }
      };
    }

  };

  // add compound query operators
  _.extend(queryOperators, compoundOperators);

  var simpleOperators = {

    /**
     * Checks that two values are equal. Pseudo operator introduced for convenience and consistency
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $eq: function (a, b) {
      // flatten to reach nested values. fix for https://github.com/kofrasa/mingo/issues/19
      a = _.flatten(_.isArray(a) ? a : [a]);
      a = _.find(a, function (val) {
        return _.isEqual(val, b);
      });
      return a !== undefined;
    },

    /**
     * Matches all values that are not equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $ne: function (a, b) {
      return !this.$eq(a, b);
    },

    /**
     * Matches any of the values that exist in an array specified in the query.
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $in: function (a, b) {
      a = _.isArray(a) ? a : [a];
      return _.intersection(a, b).length > 0;
    },

    /**
     * Matches values that do not exist in an array specified to the query.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $nin: function (a, b) {
      return _.isUndefined(a) || !this.$in(a, b);
    },

    /**
     * Matches values that are less than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val < b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are less than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val <= b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val > b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val >= b
      });
      return a !== undefined;
    },

    /**
     * Performs a modulo operation on the value of a field and selects documents with a specified result.
     *
     * @param a
     * @param b
     * @returns {*|boolean|boolean}
     */
    $mod: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isNumber(val) && _.isArray(b) && b.length === 2 && (val % b[0]) === b[1];
      });
      return a !== undefined;
    },

    /**
     * Selects documents where values match a specified regular expression.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $regex: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isString(val) && _.isRegExp(b) && (!!val.match(b));
      });
      return a !== undefined;
    },

    /**
     * Matches documents that have the specified field.
     *
     * @param a
     * @param b
     * @returns {boolean|*|boolean}
     */
    $exists: function (a, b) {
      return (b === false && _.isUndefined(a)) || (b === true && !_.isUndefined(a));
    },

    /**
     * Matches arrays that contain all elements specified in the query.
     *
     * @param a
     * @param b
     * @returns boolean
     */
    $all: function (a, b) {
      var self = this;
      var matched = false;
      if (_.isArray(a) && _.isArray(b)) {
        for (var i = 0; i < b.length; i++) {
          if (_.isObject(b[i]) && _.contains(_.keys(b[i]), "$elemMatch")) {
            matched = matched || self.$elemMatch(a, b[i].$elemMatch);
          } else {
            // order of arguments matter. underscore maintains order after intersection
            return _.intersection(b, a).length === b.length;
          }
        }
      }
      return matched;
    },

    /**
     * Selects documents if the array field is a specified size.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $size: function (a, b) {
      return _.isArray(a) && _.isNumber(b) && (a.length === b);
    },

    /**
     * Selects documents if element in the array field matches all the specified $elemMatch condition.
     *
     * @param a
     * @param b
     */
    $elemMatch: function (a, b) {
      if (_.isArray(a) && !_.isEmpty(a)) {
        var query = new Mingo.Query(b);
        for (var i = 0; i < a.length; i++) {
          if (query.test(a[i])) {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Selects documents if a field is of the specified type.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $type: function (a, b) {
      switch (b) {
        case 1:
          return _.isNumeric(a) && (a + "").indexOf(".") !== -1;
        case 2:
        case 5:
          return _.isString(a);
        case 3:
          return _.isObject(a);
        case 4:
          return _.isArray(a);
        case 8:
          return _.isBoolean(a);
        case 9:
          return _.isDate(a);
        case 10:
          return _.isNull(a);
        case 11:
          return _.isRegExp(a);
        case 16:
          return _.isNumeric(a) && a <= 2147483647 && (a + "").indexOf(".") === -1;
        case 18:
          return _.isNumeric(a) && a > 2147483647 && a <= 9223372036854775807 && (a + "").indexOf(".") === -1;
        default:
          return false;
      }
    }
  };
  // add simple query operators
  _.each(_.keys(simpleOperators), function (op) {
    queryOperators[op] = (function (f, ctx) {
      return function (selector, value) {
        return {
          test: function (obj) {
            // value of field must be fully resolved.
            var lhs = resolve(obj, selector);
            return f.call(ctx, lhs, value);
          }
        };
      }
    }(simpleOperators[op], simpleOperators));
  });

  var projectionOperators = {

    /**
     * Projects the first element in an array that matches the query condition.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $: function (obj, expr, field) {
      throw new Error("$ not implemented");
    },

    /**
     * Projects only the first element from an array that matches the specified $elemMatch condition.
     *
     * @param obj
     * @param field
     * @param expr
     * @returns {*}
     */
    $elemMatch: function (obj, expr, field) {
      var array = resolve(obj, field);
      var query = new Mingo.Query(expr);

      if (_.isUndefined(array) || !_.isArray(array)) {
        return undefined;
      }

      for (var i = 0; i < array.length; i++) {
        if (query.test(array[i])) {
          return [array[i]];
        }
      }

      return undefined;
    },

    /**
     * Limits the number of elements projected from an array. Supports skip and limit slices.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $slice: function (obj, expr, field) {
      var array = resolve(obj, field);

      if (!_.isArray(array)) {
        return array;
      }
      if (!_.isArray(expr)) {
        if (!_.isNumber(expr)) {
          throw new Error("Invalid type for $slice operator");
        }
        expr = expr < 0 ? [expr] : [0, expr];
      } else {
        // MongoDB $slice works a bit differently from Array.slice
        // Uses single argument for 'limit' and array argument [skip, limit]
        var skip = (expr[0] < 0) ? array.length + expr[0] : expr;
        var limit = skip + expr[1];
        expr = [skip, limit];
      }

      return Array.prototype.slice.apply(array, expr);
    }
  };

  var groupOperators = {

    /**
     * Returns an array of all the unique values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $addToSet: function (collection, expr) {
      var result = _.map(collection, function (obj) {
        return computeValue(obj, expr, null);
      });
      return _.uniq(result);
    },

    /**
     * Returns the sum of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $sum: function (collection, expr) {
      if (!_.isArray(collection)) {
        return 0;
      }
      if (_.isNumber(expr)) {
        // take a short cut if expr is number literal
        return collection.length * expr;
      }
      return _.reduce(collection, function (acc, obj) {
        // pass empty field to avoid naming conflicts with fields on documents
        return acc + computeValue(obj, expr, null);
      }, 0);
    },

    /**
     * Returns the highest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $max: function (collection, expr) {
      var obj = _.max(collection, function (obj) {
        return computeValue(obj, expr, null);
      });
      return computeValue(obj, expr, null);
    },

    /**
     * Returns the lowest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $min: function (collection, expr) {
      var obj = _.min(collection, function (obj) {
        return computeValue(obj, expr, null);
      });
      return computeValue(obj, expr, null);
    },

    /**
     * Returns an average of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {number}
     */
    $avg: function (collection, expr) {
      return this.$sum(collection, expr) / (collection.length || 1);
    },

    /**
     * Returns an array of all values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $push: function (collection, expr) {
      return _.map(collection, function (obj) {
        return computeValue(obj, expr, null);
      });
    },

    /**
     * Returns the first value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $first: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[0], expr) : undefined;
    },

    /**
     * Returns the last value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $last: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[collection.length - 1], expr) : undefined;
    }
  };


  /////////// Aggregation Operators ///////////

  var arithmeticOperators = {

    /**
     * Computes the sum of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $add: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.reduce(args, function (memo, num) {
        return memo + num;
      }, 0);
    },

    /**
     * Takes an array that contains two numbers or two dates and subtracts the second value from the first.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $subtract: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return args[0] - args[1];
    },

    /**
     * Takes two numbers and divides the first number by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $divide: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return args[0] / args[1];
    },

    /**
     * Computes the product of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $multiply: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.reduce(args, function (memo, num) {
        return memo * num;
      }, 1);
    },

    /**
     * Takes two numbers and calculates the modulo of the first number divided by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $mod: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return args[0] % args[1];
    }
  };

  var stringOperators = {

    /**
     * Concatenates two strings.
     *
     * @param obj
     * @param expr
     * @returns {string|*}
     */
    $concat: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      // does not allow concatenation with nulls
      if (_.contains(args, null) || _.contains(args, undefined)) {
        return null;
      }
      return args.join("");
    },

    /**
     * Compares two strings and returns an integer that reflects the comparison.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $strcasecmp: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      args[0] = _.isEmpty(args[0]) ? "" : args[0].toUpperCase();
      args[1] = _.isEmpty(args[1]) ? "" : args[1].toUpperCase();
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    },

    /**
     * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
     * The index is zero-based.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $substr: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      if (_.isString(args[0])) {
        if (args[1] < 0) {
          return "";
        } else if (args[2] < 0) {
          return args[0].substr(args[1]);
        } else {
          return args[0].substr(args[1], args[2]);
        }
      }
      return "";
    },

    /**
     * Converts a string to lowercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toLower: function (obj, expr) {
      var value = computeValue(obj, expr, null);
      return _.isEmpty(value) ? "" : value.toLowerCase();
    },

    /**
     * Converts a string to uppercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toUpper: function (obj, expr) {
      var value = computeValue(obj, expr, null);
      return _.isEmpty(value) ? "" : value.toUpperCase();
    }
  };

  var dateOperators = {
    /**
     * Returns the day of the year for a date as a number between 1 and 366 (leap year).
     * @param obj
     * @param expr
     */
    $dayOfYear: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      if (_.isDate(d)) {
        var start = new Date(d.getFullYear(), 0, 0);
        var diff = d - start;
        var oneDay = 1000 * 60 * 60 * 24;
        return Math.round(diff / oneDay);
      }
      return undefined;
    },

    /**
     * Returns the day of the month for a date as a number between 1 and 31.
     * @param obj
     * @param expr
     */
    $dayOfMonth: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getDate() : undefined;
    },

    /**
     * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).
     * @param obj
     * @param expr
     */
    $dayOfWeek: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getDay() + 1 : undefined;
    },

    /**
     * Returns the year for a date as a number (e.g. 2014).
     * @param obj
     * @param expr
     */
    $year: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getFullYear() : undefined;
    },

    /**
     * Returns the month for a date as a number between 1 (January) and 12 (December).
     * @param obj
     * @param expr
     */
    $month: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getMonth() + 1 : undefined;
    },

    /**
     * Returns the week number for a date as a number between 0
     * (the partial week that precedes the first Sunday of the year) and 53 (leap year).
     * @param obj
     * @param expr
     */
    $week: function (obj, expr) {
      // source: http://stackoverflow.com/a/6117889/1370481
      var d = computeValue(obj, expr, null);

      // Copy date so don't modify original
      d = new Date(+d);
      d.setHours(0, 0, 0);
      // Set to nearest Thursday: current date + 4 - current day number
      // Make Sunday's day number 7
      d.setDate(d.getDate() + 4 - (d.getDay() || 7));
      // Get first day of year
      var yearStart = new Date(d.getFullYear(), 0, 1);
      // Calculate full weeks to nearest Thursday
      return Math.floor(( ( (d - yearStart) / 8.64e7) + 1) / 7);
    },

    /**
     * Returns the hour for a date as a number between 0 and 23.
     * @param obj
     * @param expr
     */
    $hour: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getHours() : undefined;
    },

    /**
     * Returns the minute for a date as a number between 0 and 59.
     * @param obj
     * @param expr
     */
    $minute: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getMinutes() : undefined;
    },

    /**
     * Returns the seconds for a date as a number between 0 and 60 (leap seconds).
     * @param obj
     * @param expr
     */
    $second: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getSeconds() : undefined;
    },

    /**
     * Returns the milliseconds of a date as a number between 0 and 999.
     * @param obj
     * @param expr
     */
    $millisecond: function (obj, expr) {
      var d = computeValue(obj, expr, null);
      return _.isDate(d) ? d.getMilliseconds() : undefined;
    },

    /**
     * Returns the date as a formatted string.
     *
     * %Y  Year (4 digits, zero padded)  0000-9999
     * %m  Month (2 digits, zero padded)  01-12
     * %d  Day of Month (2 digits, zero padded)  01-31
     * %H  Hour (2 digits, zero padded, 24-hour clock)  00-23
     * %M  Minute (2 digits, zero padded)  00-59
     * %S  Second (2 digits, zero padded)  00-60
     * %L  Millisecond (3 digits, zero padded)  000-999
     * %j  Day of year (3 digits, zero padded)  001-366
     * %w  Day of week (1-Sunday, 7-Saturday)  1-7
     * %U  Week of year (2 digits, zero padded)  00-53
     * %%  Percent Character as a Literal  %
     *
     * @param obj current object
     * @param expr operator expression
     */
    $dateToString: function (obj, expr) {

      var fmt = expr['format'];
      var date = computeValue(obj, expr['date'], null);
      var matches = fmt.match(/(%%|%Y|%m|%d|%H|%M|%S|%L|%j|%w|%U)/g);

      for (var i = 0, len = matches.length; i < len; i++) {
        var hdlr = DATE_SYM_TABLE[matches[i]];
        var value = hdlr;

        if (_.isArray(hdlr)) {
          // reuse date operators
          var fn = this[hdlr[0]];
          var pad = hdlr[1];
          value = padDigits(fn.call(this, obj, date), pad);
        }
        // replace the match with resolved value
        fmt = fmt.replace(matches[i], value);
      }

      return fmt;
    }
  };

  var setOperators = {
    /**
     * Returns true if two sets have the same elements.
     * @param obj
     * @param expr
     */
    $setEquals: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      var first = _.uniq(args[0]);
      var second = _.uniq(args[1]);
      if (first.length !== second.length) {
        return false;
      }
      return _.difference(first, second).length == 0;
    },

    /**
     * Returns the common elements of the input sets.
     * @param obj
     * @param expr
     */
    $setIntersection: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.intersection(args[0], args[1]);
    },

    /**
     * Returns elements of a set that do not appear in a second set.
     * @param obj
     * @param expr
     */
    $setDifference: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.difference(args[0], args[1]);
    },

    /**
     * Returns a set that holds all elements of the input sets.
     * @param obj
     * @param expr
     */
    $setUnion: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.union(args[0], args[1]);
    },

    /**
     * Returns true if all elements of a set appear in a second set.
     * @param obj
     * @param expr
     */
    $setIsSubset: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return _.intersection(args[0], args[1]).length === args[0].length;
    },

    /**
     * Returns true if any elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $anyElementTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr, null)[0];
      for (var i = 0; i < args.length; i++) {
        if (!!args[i])
          return true;
      }
      return false;
    },

    /**
     * Returns true if all elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $allElementsTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr, null)[0];
      for (var i = 0; i < args.length; i++) {
        if (!args[i])
          return false;
      }
      return true;
    }
  };

  var conditionalOperators = {

    /**
     * A ternary operator that evaluates one expression,
     * and depending on the result returns the value of one following expressions.
     *
     * @param obj
     * @param expr
     */
    $cond: function (obj, expr) {
      var ifExpr, thenExpr, elseExpr;
      if (_.isArray(expr)) {
        if (expr.length != 3) {
          throw new Error("Invalid arguments for $cond operator");
        }
        ifExpr = expr[0];
        thenExpr = expr[1];
        elseExpr = expr[2];
      } else if (_.isObject(expr)) {
        ifExpr = expr['if'];
        thenExpr = expr['then'];
        elseExpr = expr['else'];
      }
      var condition = computeValue(obj, ifExpr, null);
      return condition ? computeValue(obj, thenExpr, null) : computeValue(obj, elseExpr, null);
    },

    /**
     * Evaluates an expression and returns the first expression if it evaluates to a non-null value.
     * Otherwise, $ifNull returns the second expression's value.
     *
     * @param obj
     * @param expr
     * @returns {*}
     */
    $ifNull: function (obj, expr) {
      if (!_.isArray(expr) || expr.length != 2) {
        throw new Error("Invalid arguments for $ifNull operator");
      }
      var args = computeValue(obj, expr, null);
      return (args[0] === null || args[0] === undefined) ? args[1] : args[0];
    }
  };

  var comparisonOperators = {
    /**
     * Compares two values and returns the result of the comparison as an integer.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $cmp: function (obj, expr) {
      var args = computeValue(obj, expr, null);
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    }
  };
  // mixin comparison operators
  _.each(["$eq", "$ne", "$gt", "$gte", "$lt", "$lte"], function (op) {
    comparisonOperators[op] = function (obj, expr) {
      var args = computeValue(obj, expr, null);
      return simpleOperators[op](args[0], args[1]);
    };
  });

  var arrayOperators = {
    /**
     * Counts and returns the total the number of items in an array.
     * @param obj
     * @param expr
     */
    $size: function (obj, expr) {
      var value = computeValue(obj, expr, null);
      return _.isArray(value) ? value.length : undefined;
    }
  };

  var literalOperators = {
    /**
     * Return a value without parsing.
     * @param obj
     * @param expr
     */
    $literal: function (obj, expr) {
      return expr;
    }
  };


  var variableOperators = {
    /**
     * Applies a subexpression to each element of an array and returns the array of resulting values in order.
     * @param obj
     * @param expr
     * @returns {Array|*}
     */
    $map: function (obj, expr) {
      var inputExpr = computeValue(obj, expr["input"], null);
      if (!_.isArray(inputExpr)) {
        throw new Error("Input expression for $map must resolve to an array");
      }
      var asExpr = expr["as"];
      var inExpr = expr["in"];

      // HACK: add the "as" expression as a value on the object to take advantage of "resolve()"
      // which will reduce to that value when invoked. The reference to the as expression will be prefixed with "$$".
      // But since a "$" is stripped of before passing the name to "resolve()" we just need to prepend "$" to the key.
      var tempKey = "$" + asExpr;
      // let's save any value that existed, kinda useless but YOU CAN NEVER BE TOO SURE, CAN YOU :)
      var original = obj[tempKey];
      return _.map(inputExpr, function (item) {
        obj[tempKey] = item;
        var value = computeValue(obj, inExpr, null);
        // cleanup and restore
        if (_.isUndefined(original)) {
          delete obj[tempKey];
        } else {
          obj[tempKey] = original;
        }
        return value;
      });

    },

    /**
     * Defines variables for use within the scope of a subexpression and returns the result of the subexpression.
     * @param obj
     * @param expr
     * @returns {*}
     */
    $let: function (obj, expr) {
      var varsExpr = expr["vars"];
      var inExpr = expr["in"];

      // resolve vars
      var originals = {};
      var varsKeys = _.keys(varsExpr);
      _.each(varsKeys, function (key) {
        var val = computeValue(obj, varsExpr[key], null);
        var tempKey = "$" + key;
        // set value on object using same technique as in "$map"
        originals[tempKey] = obj[tempKey];
        obj[tempKey] = val;
      });

      var value = computeValue(obj, inExpr, null);

      // cleanup and restore
      _.each(varsKeys, function (key) {
        var tempKey = "$" + key;
        if (_.isUndefined(originals[tempKey])) {
          delete obj[tempKey];
        } else {
          obj[tempKey] = originals[tempKey];
        }
      });

      return value;
    }
  };

  var booleanOperators = {
    /**
     * Returns true only when all its expressions evaluate to true. Accepts any number of argument expressions.
     * @param obj
     * @param expr
     * @returns {boolean}
     */
    $and: function (obj, expr) {
      var value = computeValue(obj, expr, null);
      return _.every(value);
    },

    /**
     * Returns true when any of its expressions evaluates to true. Accepts any number of argument expressions.
     * @param obj
     * @param expr
     * @returns {boolean}
     */
    $or: function (obj, expr) {
      var value = computeValue(obj, expr, null);
      return _.some(value);
    },

    /**
     * Returns the boolean value that is the opposite of its argument expression. Accepts a single argument expression.
     * @param obj
     * @param expr
     * @returns {boolean}
     */
    $not: function (obj, expr) {
      return !computeValue(obj, expr[0], null);
    }
  };

  // combine aggregate operators
  var aggregateOperators = _.extend(
    {},
    arrayOperators,
    arithmeticOperators,
    booleanOperators,
    comparisonOperators,
    conditionalOperators,
    dateOperators,
    literalOperators,
    setOperators,
    stringOperators,
    variableOperators
  );

  var OP_QUERY = Mingo.OP_QUERY = 'query',
    OP_GROUP = Mingo.OP_GROUP = 'group',
    OP_AGGREGATE = Mingo.OP_AGGREGATE = 'aggregate',
    OP_PIPELINE = Mingo.OP_PIPELINE = 'pipeline',
    OP_PROJECTION = Mingo.OP_PROJECTION = 'projection';

  // operator definitions
  var OPERATORS = {
    'aggregate': aggregateOperators,
    'group': groupOperators,
    'pipeline': pipelineOperators,
    'projection': projectionOperators,
    'query': queryOperators
  };

  // used for formatting dates in $dateToString operator
  var DATE_SYM_TABLE = {
    '%Y': ['$year', 4],
    '%m': ['$month', 2],
    '%d': ['$dayOfMonth', 2],
    '%H': ['$hour', 2],
    '%M': ['$minute', 2],
    '%S': ['$second', 2],
    '%L': ['$millisecond', 3],
    '%j': ['$dayOfYear', 3],
    '%w': ['$dayOfWeek', 1],
    '%U': ['$week', 2],
    '%%': '%'
  };

  function padDigits(number, digits) {
    return new Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number;
  }

  /**
   * Return the registered operators on the given operator category
   * @param type catgory of operators
   * @returns {*}
   */
  function ops(type) {
    return _.keys(OPERATORS[type]);
  }

  /**
   * Groups the collection into sets by the returned key
   *
   * @param collection
   * @param fn
   */
  function groupBy(collection, fn) {

    var result = {
      'keys': [],
      'groups': []
    };

    _.each(collection, function (obj) {

      var key = fn(obj);
      var index = -1;

      if (_.isObject(key)) {
        for (var i = 0; i < result.keys.length; i++) {
          if (_.isEqual(key, result.keys[i])) {
            index = i;
            break;
          }
        }
      } else {
        index = _.indexOf(result.keys, key);
      }

      if (index > -1) {
        result.groups[index].push(obj);
      } else {
        result.keys.push(key);
        result.groups.push([obj]);
      }
    });

    // assert this
    if (result.keys.length !== result.groups.length) {
      throw new Error("assert groupBy(): keys.length !== groups.length");
    }

    return result;
  }

  /**
   * Returns the result of evaluating a $group operation over a collection
   *
   * @param collection
   * @param field the name of the aggregate operator or field
   * @param expr the expression of the aggregate operator for the field
   * @returns {*}
   */
  function accumulate(collection, field, expr) {
    if (_.contains(ops(OP_GROUP), field)) {
      return groupOperators[field](collection, expr);
    }

    if (_.isObject(expr)) {
      var result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = accumulate(collection, key, expr[key]);
          // must run ONLY one group operator per expression
          // if so, return result of the computed value
          if (_.contains(ops(OP_GROUP), key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid $group expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
      return result;
    }

    return undefined;
  }

  /**
   * Computes the actual value of the expression using the given object as context
   *
   * @param obj the current object from the collection
   * @param expr the expression for the given field
   * @param field the field name (may also be an aggregate operator)
   * @returns {*}
   */
  function computeValue(obj, expr, field) {

    // if the field of the object is a valid operator
    if (_.contains(ops(OP_AGGREGATE), field)) {
      return aggregateOperators[field](obj, expr);
    }

    // if expr is a variable for an object field
    // field not used in this case
    if (_.isString(expr) && expr.length > 0 && expr[0] === "$") {
      return resolve(obj, expr.slice(1));
    }

    var result;

    // check and return value if already in a resolved state
    if (isPrimitive(expr)) {
      return expr;
    } else if (_.isArray(expr)) {
      result = _.map(expr, function (item) {
        return computeValue(obj, item, null);
      });
    } else if (_.isObject(expr)) {
      result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = computeValue(obj, expr[key], key);

          // must run ONLY one aggregate operator per expression
          // if so, return result of the computed value
          if (_.contains(ops(OP_AGGREGATE), key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid aggregation expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
    }

    return result;
  }

}(this));

},{"stream":"stream","underscore":36,"util":7}],14:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":25,"component-type":17,"debug":18,"dot-component":21,"mongo-eql":23,"object-component":24}],15:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":14,"./mods":16,"component-type":17,"debug":18,"dot-component":21,"object-component":24}],16:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":17,"debug":18,"dot-component":21,"mongo-eql":23,"object-component":24}],17:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],18:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":19}],19:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":20}],20:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],21:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":22}],22:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],23:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":17}],24:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],25:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":17,"mongo-eql":23}],26:[function(require,module,exports){
var CryptoJS = require('./lib/core').CryptoJS;
require('./lib/enc-base64');
require('./lib/md5');
require('./lib/evpkdf');
require('./lib/cipher-core');
require('./lib/aes');
var JsonFormatter = require('./lib/jsonformatter').JsonFormatter;

exports.CryptoJS = CryptoJS;
exports.JsonFormatter = JsonFormatter;
},{"./lib/aes":27,"./lib/cipher-core":28,"./lib/core":29,"./lib/enc-base64":30,"./lib/evpkdf":31,"./lib/jsonformatter":32,"./lib/md5":33}],27:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

},{"./core":29}],28:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

},{"./core":29}],29:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

exports.CryptoJS = CryptoJS;

},{}],30:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

},{"./core":29}],31:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;

    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */
    var EvpKDF = C_algo.EvpKDF = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.EvpKDF.create();
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init hasher
            var hasher = cfg.hasher.create();

            // Initial values
            var derivedKey = WordArray.create();

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                if (block) {
                    hasher.update(block);
                }
                var block = hasher.update(password).finalize(salt);
                hasher.reset();

                // Iterations
                for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                }

                derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
    };
}());

},{"./core":29}],32:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

// create custom json serialization format
var JsonFormatter = {
	stringify: function (cipherParams) {
		// create json object with ciphertext
		var jsonObj = {
			ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
		};
		
		// optionally add iv and salt
		if (cipherParams.iv) {
			jsonObj.iv = cipherParams.iv.toString();
		}
		
		if (cipherParams.salt) {
			jsonObj.s = cipherParams.salt.toString();
		}

		// stringify json object
		return JSON.stringify(jsonObj)
	},

	parse: function (jsonStr) {
		// parse json string
		var jsonObj = JSON.parse(jsonStr);
		
		// extract ciphertext from json object, and create cipher params object
		var cipherParams = CryptoJS.lib.CipherParams.create({
			ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
		});
		
		// optionally extract iv and salt
		if (jsonObj.iv) {
			cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
		}
            
		if (jsonObj.s) {
			cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
		}
		
		return cipherParams;
	}
};

exports.JsonFormatter = JsonFormatter;
},{"./core":29}],33:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

},{"./core":29}],34:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , httpsRe = /^http/
    , protocolRe = /(^\w+):\/\//
    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function succeed(r) {
    var protocol = protocolRe.exec(r.url);
    protocol = (protocol && protocol[1]) || window.location.protocol;
    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
  }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (succeed(r)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    var isAFormData = typeof FormData === 'function' && (o['data'] instanceof FormData);
    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        timedOut()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function timedOut() {
      self._timedOut = true
      self.request.abort()      
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  , 'catch': function (fn) {
      return this.fail(fn)
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],35:[function(require,module,exports){
(function (process){
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.0.17
 */

(function() {
    "use strict";
    function lib$rsvp$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$rsvp$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$rsvp$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$rsvp$utils$$_isArray;
    if (!Array.isArray) {
      lib$rsvp$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$rsvp$utils$$_isArray = Array.isArray;
    }

    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;

    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };

    function lib$rsvp$utils$$F() { }

    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      lib$rsvp$utils$$F.prototype = o;
      return new lib$rsvp$utils$$F();
    });
    function lib$rsvp$events$$indexOf(callbacks, callback) {
      for (var i=0, l=callbacks.length; i<l; i++) {
        if (callbacks[i] === callback) { return i; }
      }

      return -1;
    }

    function lib$rsvp$events$$callbacksFor(object) {
      var callbacks = object._promiseCallbacks;

      if (!callbacks) {
        callbacks = object._promiseCallbacks = {};
      }

      return callbacks;
    }

    var lib$rsvp$events$$default = {

      /**
        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
        Example:

        ```javascript
        var object = {};

        RSVP.EventTarget.mixin(object);

        object.on('finished', function(event) {
          // handle event
        });

        object.trigger('finished', { detail: value });
        ```

        `EventTarget.mixin` also works with prototypes:

        ```javascript
        var Person = function() {};
        RSVP.EventTarget.mixin(Person.prototype);

        var yehuda = new Person();
        var tom = new Person();

        yehuda.on('poke', function(event) {
          console.log('Yehuda says OW');
        });

        tom.on('poke', function(event) {
          console.log('Tom says OW');
        });

        yehuda.trigger('poke');
        tom.trigger('poke');
        ```

        @method mixin
        @for RSVP.EventTarget
        @private
        @param {Object} object object to extend with EventTarget methods
      */
      'mixin': function(object) {
        object['on']      = this['on'];
        object['off']     = this['off'];
        object['trigger'] = this['trigger'];
        object._promiseCallbacks = undefined;
        return object;
      },

      /**
        Registers a callback to be executed when `eventName` is triggered

        ```javascript
        object.on('event', function(eventInfo){
          // handle the event
        });

        object.trigger('event');
        ```

        @method on
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to listen for
        @param {Function} callback function to be called when the event is triggered.
      */
      'on': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;

        callbacks = allCallbacks[eventName];

        if (!callbacks) {
          callbacks = allCallbacks[eventName] = [];
        }

        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
          callbacks.push(callback);
        }
      },

      /**
        You can use `off` to stop firing a particular callback for an event:

        ```javascript
        function doStuff() { // do stuff! }
        object.on('stuff', doStuff);

        object.trigger('stuff'); // doStuff will be called

        // Unregister ONLY the doStuff callback
        object.off('stuff', doStuff);
        object.trigger('stuff'); // doStuff will NOT be called
        ```

        If you don't pass a `callback` argument to `off`, ALL callbacks for the
        event will not be executed when the event fires. For example:

        ```javascript
        var callback1 = function(){};
        var callback2 = function(){};

        object.on('stuff', callback1);
        object.on('stuff', callback2);

        object.trigger('stuff'); // callback1 and callback2 will be executed.

        object.off('stuff');
        object.trigger('stuff'); // callback1 and callback2 will not be executed!
        ```

        @method off
        @for RSVP.EventTarget
        @private
        @param {String} eventName event to stop listening to
        @param {Function} callback optional argument. If given, only the function
        given will be removed from the event's callback queue. If no `callback`
        argument is given, all callbacks will be removed from the event's callback
        queue.
      */
      'off': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;

        if (!callback) {
          allCallbacks[eventName] = [];
          return;
        }

        callbacks = allCallbacks[eventName];

        index = lib$rsvp$events$$indexOf(callbacks, callback);

        if (index !== -1) { callbacks.splice(index, 1); }
      },

      /**
        Use `trigger` to fire custom events. For example:

        ```javascript
        object.on('foo', function(){
          console.log('foo event happened!');
        });
        object.trigger('foo');
        // 'foo event happened!' logged to the console
        ```

        You can also pass a value as a second argument to `trigger` that will be
        passed as an argument to all event listeners for the event:

        ```javascript
        object.on('foo', function(value){
          console.log(value.name);
        });

        object.trigger('foo', { name: 'bar' });
        // 'bar' logged to the console
        ```

        @method trigger
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to be triggered
        @param {Any} options optional value to be passed to any event handlers for
        the given `eventName`
      */
      'trigger': function(eventName, options) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;

        if (callbacks = allCallbacks[eventName]) {
          // Don't cache the callbacks.length since it may grow
          for (var i=0; i<callbacks.length; i++) {
            callback = callbacks[i];

            callback(options);
          }
        }
      }
    };

    var lib$rsvp$config$$config = {
      instrument: false
    };

    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);

    function lib$rsvp$config$$configure(name, value) {
      if (name === 'onerror') {
        // handle for legacy users that expect the actual
        // error to be passed to their function added via
        // `RSVP.configure('onerror', someFunctionHere);`
        lib$rsvp$config$$config['on']('error', value);
        return;
      }

      if (arguments.length === 2) {
        lib$rsvp$config$$config[name] = value;
      } else {
        return lib$rsvp$config$$config[name];
      }
    }

    var lib$rsvp$instrument$$queue = [];

    function lib$rsvp$instrument$$scheduleFlush() {
      setTimeout(function() {
        var entry;
        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
          entry = lib$rsvp$instrument$$queue[i];

          var payload = entry.payload;

          payload.guid = payload.key + payload.id;
          payload.childGuid = payload.key + payload.childId;
          if (payload.error) {
            payload.stack = payload.error.stack;
          }

          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
        }
        lib$rsvp$instrument$$queue.length = 0;
      }, 50);
    }

    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
      if (1 === lib$rsvp$instrument$$queue.push({
          name: eventName,
          payload: {
            key: promise._guidKey,
            id:  promise._id,
            eventName: eventName,
            detail: promise._result,
            childId: child && child._id,
            label: promise._label,
            timeStamp: lib$rsvp$utils$$now(),
            error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
          }})) {
            lib$rsvp$instrument$$scheduleFlush();
          }
      }
    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;

    function  lib$rsvp$$internal$$withOwnPromise() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$rsvp$$internal$$noop() {}

    var lib$rsvp$$internal$$PENDING   = void 0;
    var lib$rsvp$$internal$$FULFILLED = 1;
    var lib$rsvp$$internal$$REJECTED  = 2;

    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
        return lib$rsvp$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
      lib$rsvp$config$$config.async(function(promise) {
        var sealed = false;
        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$rsvp$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$rsvp$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
        thenable._onError = null;
        lib$rsvp$$internal$$reject(promise, thenable._result);
      } else {
        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$rsvp$$internal$$getThen(maybeThenable);

        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$rsvp$utils$$isFunction(then)) {
          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$rsvp$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
        lib$rsvp$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$rsvp$$internal$$fulfill(promise, value);
      }
    }

    function lib$rsvp$$internal$$publishRejection(promise) {
      if (promise._onError) {
        promise._onError(promise._result);
      }

      lib$rsvp$$internal$$publish(promise);
    }

    function lib$rsvp$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$rsvp$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('fulfilled', promise);
        }
      } else {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
      }
    }

    function lib$rsvp$$internal$$reject(promise, reason) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
      promise._state = lib$rsvp$$internal$$REJECTED;
      promise._result = reason;
      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
    }

    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onError = null;

      subscribers[length] = child;
      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
      }
    }

    function lib$rsvp$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
      }

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$rsvp$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$rsvp$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$rsvp$$internal$$tryCatch(callback, detail);

        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$rsvp$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$rsvp$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$rsvp$$internal$$reject(promise, error);
      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (settled === lib$rsvp$$internal$$REJECTED) {
        lib$rsvp$$internal$$reject(promise, value);
      }
    }

    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
      var resolved = false;
      try {
        resolver(function resolvePromise(value){
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$rsvp$$internal$$reject(promise, e);
      }
    }

    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
      if (state === lib$rsvp$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          lib$rsvp$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$rsvp$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$rsvp$$internal$$reject(this.promise, this._validationError());
      }
    }

    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;

    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$rsvp$utils$$isArray(input);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
          entry._onError = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$rsvp$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        lib$rsvp$$internal$$fulfill(promise, this._result);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
      });
    };
    function lib$rsvp$promise$all$$all(entries, label) {
      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    }
    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
    function lib$rsvp$promise$race$$race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);

      if (!lib$rsvp$utils$$isArray(entries)) {
        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$rsvp$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$rsvp$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
    function lib$rsvp$promise$resolve$$resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
    function lib$rsvp$promise$reject$$reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;

    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
    var lib$rsvp$promise$$counter = 0;

    function lib$rsvp$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$rsvp$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise’s eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class RSVP.Promise
      @param {function} resolver
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @constructor
    */
    function lib$rsvp$promise$$Promise(resolver, label) {
      this._id = lib$rsvp$promise$$counter++;
      this._label = label;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default('created', this);
      }

      if (lib$rsvp$$internal$$noop !== resolver) {
        if (!lib$rsvp$utils$$isFunction(resolver)) {
          lib$rsvp$promise$$needsResolver();
        }

        if (!(this instanceof lib$rsvp$promise$$Promise)) {
          lib$rsvp$promise$$needsNew();
        }

        lib$rsvp$$internal$$initializePromise(this, resolver);
      }
    }

    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;

    // deprecated
    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;

    lib$rsvp$promise$$Promise.prototype = {
      constructor: lib$rsvp$promise$$Promise,

      _guidKey: lib$rsvp$promise$$guidKey,

      _onError: function (reason) {
        lib$rsvp$config$$config.async(function(promise) {
          setTimeout(function() {
            if (promise._onError) {
              lib$rsvp$config$$config['trigger']('error', reason);
            }
          }, 0);
        }, this);
      },

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection, label) {
        var parent = this;
        var state = parent._state;

        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', this, this);
          }
          return this;
        }

        parent._onError = null;

        var child = new this.constructor(lib$rsvp$$internal$$noop, label);
        var result = parent._result;

        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('chained', parent, child);
        }

        if (state) {
          var callback = arguments[state - 1];
          lib$rsvp$config$$config.async(function(){
            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection, label) {
        return this.then(null, onRejection, label);
      },

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves

      Synchronous example:

      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }

      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```

      Asynchronous example:

      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```

      @method finally
      @param {Function} callback
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'finally': function(callback, label) {
        var constructor = this.constructor;

        return this.then(function(value) {
          return constructor.resolve(callback()).then(function(){
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function(){
            throw reason;
          });
        }, label);
      }
    };

    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
    }

    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
      return new Error('allSettled must be called with an array');
    };

    function lib$rsvp$all$settled$$allSettled(entries, label) {
      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
    }
    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
    function lib$rsvp$all$$all(array, label) {
      return lib$rsvp$promise$$default.all(array, label);
    }
    var lib$rsvp$all$$default = lib$rsvp$all$$all;
    var lib$rsvp$asap$$len = 0;
    var lib$rsvp$asap$$toString = {}.toString;
    var lib$rsvp$asap$$vertxNext;
    function lib$rsvp$asap$$asap(callback, arg) {
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
      lib$rsvp$asap$$len += 2;
      if (lib$rsvp$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        lib$rsvp$asap$$scheduleFlush();
      }
    }

    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;

    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
    var lib$rsvp$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$rsvp$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$rsvp$asap$$flush);
      };
    }

    // vertx
    function lib$rsvp$asap$$useVertxTimer() {
      return function() {
        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
      };
    }

    function lib$rsvp$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$rsvp$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$rsvp$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$rsvp$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$rsvp$asap$$flush, 1);
      };
    }

    var lib$rsvp$asap$$queue = new Array(1000);
    function lib$rsvp$asap$$flush() {
      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
        var callback = lib$rsvp$asap$$queue[i];
        var arg = lib$rsvp$asap$$queue[i+1];

        callback(arg);

        lib$rsvp$asap$$queue[i] = undefined;
        lib$rsvp$asap$$queue[i+1] = undefined;
      }

      lib$rsvp$asap$$len = 0;
    }

    function lib$rsvp$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$rsvp$asap$$useVertxTimer();
      } catch(e) {
        return lib$rsvp$asap$$useSetTimeout();
      }
    }

    var lib$rsvp$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$rsvp$asap$$isNode) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
    } else if (lib$rsvp$asap$$isWorker) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
    } else {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
    }
    function lib$rsvp$defer$$defer(label) {
      var deferred = { };

      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
        deferred['resolve'] = resolve;
        deferred['reject'] = reject;
      }, label);

      return deferred;
    }
    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
    function lib$rsvp$filter$$filter(promises, filterFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(filterFn)) {
          throw new TypeError("You must pass a function as filter's second argument.");
        }

        var length = values.length;
        var filtered = new Array(length);

        for (var i = 0; i < length; i++) {
          filtered[i] = filterFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
          var results = new Array(length);
          var newLength = 0;

          for (var i = 0; i < length; i++) {
            if (filtered[i]) {
              results[newLength] = values[i];
              newLength++;
            }
          }

          results.length = newLength;

          return results;
        });
      });
    }
    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;

    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
      this._superConstructor(Constructor, object, true, label);
    }

    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;

    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
      this._result = {};
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
      return input && typeof input === 'object';
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
      return new Error('Promise.hash must be called with an object');
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
      var promise = this.promise;
      var input   = this._input;
      var results = [];

      for (var key in input) {
        if (promise._state === lib$rsvp$$internal$$PENDING && input.hasOwnProperty(key)) {
          results.push({
            position: key,
            entry: input[key]
          });
        }
      }

      var length = results.length;
      this._remaining = length;
      var result;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        result = results[i];
        this._eachEntry(result.entry, result.position);
      }
    };

    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
      this._superConstructor(Constructor, object, false, label);
    }

    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;

    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
      return new Error('hashSettled must be called with an object');
    };

    function lib$rsvp$hash$settled$$hashSettled(object, label) {
      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
    function lib$rsvp$hash$$hash(object, label) {
      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
    function lib$rsvp$map$$map(promises, mapFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(mapFn)) {
          throw new TypeError("You must pass a function as map's second argument.");
        }

        var length = values.length;
        var results = new Array(length);

        for (var i = 0; i < length; i++) {
          results[i] = mapFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(results, label);
      });
    }
    var lib$rsvp$map$$default = lib$rsvp$map$$map;

    function lib$rsvp$node$$Result() {
      this.value = undefined;
    }

    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();

    function lib$rsvp$node$$getThen(obj) {
      try {
       return obj.then;
      } catch(error) {
        lib$rsvp$node$$ERROR.value= error;
        return lib$rsvp$node$$ERROR;
      }
    }


    function lib$rsvp$node$$tryApply(f, s, a) {
      try {
        f.apply(s, a);
      } catch(error) {
        lib$rsvp$node$$ERROR.value = error;
        return lib$rsvp$node$$ERROR;
      }
    }

    function lib$rsvp$node$$makeObject(_, argumentNames) {
      var obj = {};
      var name;
      var i;
      var length = _.length;
      var args = new Array(length);

      for (var x = 0; x < length; x++) {
        args[x] = _[x];
      }

      for (i = 0; i < argumentNames.length; i++) {
        name = argumentNames[i];
        obj[name] = args[i + 1];
      }

      return obj;
    }

    function lib$rsvp$node$$arrayResult(_) {
      var length = _.length;
      var args = new Array(length - 1);

      for (var i = 1; i < length; i++) {
        args[i - 1] = _[i];
      }

      return args;
    }

    function lib$rsvp$node$$wrapThenable(then, promise) {
      return {
        then: function(onFulFillment, onRejection) {
          return then.call(promise, onFulFillment, onRejection);
        }
      };
    }

    function lib$rsvp$node$$denodeify(nodeFunc, options) {
      var fn = function() {
        var self = this;
        var l = arguments.length;
        var args = new Array(l + 1);
        var arg;
        var promiseInput = false;

        for (var i = 0; i < l; ++i) {
          arg = arguments[i];

          if (!promiseInput) {
            // TODO: clean this up
            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
              return p;
            } else if (promiseInput && promiseInput !== true) {
              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
            }
          }
          args[i] = arg;
        }

        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);

        args[l] = function(err, val) {
          if (err)
            lib$rsvp$$internal$$reject(promise, err);
          else if (options === undefined)
            lib$rsvp$$internal$$resolve(promise, val);
          else if (options === true)
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
          else if (lib$rsvp$utils$$isArray(options))
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
          else
            lib$rsvp$$internal$$resolve(promise, val);
        };

        if (promiseInput) {
          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
        } else {
          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
        }
      };

      fn.__proto__ = nodeFunc;

      return fn;
    }

    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;

    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
      if (result === lib$rsvp$node$$ERROR) {
        lib$rsvp$$internal$$reject(promise, result.value);
      }
      return promise;
    }

    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
      return lib$rsvp$promise$$default.all(args).then(function(args){
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      });
    }

    function lib$rsvp$node$$needsPromiseInput(arg) {
      if (arg && typeof arg === 'object') {
        if (arg.constructor === lib$rsvp$promise$$default) {
          return true;
        } else {
          return lib$rsvp$node$$getThen(arg);
        }
      } else {
        return false;
      }
    }
    function lib$rsvp$race$$race(array, label) {
      return lib$rsvp$promise$$default.race(array, label);
    }
    var lib$rsvp$race$$default = lib$rsvp$race$$race;
    function lib$rsvp$reject$$reject(reason, label) {
      return lib$rsvp$promise$$default.reject(reason, label);
    }
    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
    function lib$rsvp$resolve$$resolve(value, label) {
      return lib$rsvp$promise$$default.resolve(value, label);
    }
    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
    function lib$rsvp$rethrow$$rethrow(reason) {
      setTimeout(function() {
        throw reason;
      });
      throw reason;
    }
    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;

    // default async is asap;
    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
    function lib$rsvp$$async(callback, arg) {
      lib$rsvp$config$$config.async(callback, arg);
    }

    function lib$rsvp$$on() {
      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
    }

    function lib$rsvp$$off() {
      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
    }

    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
      lib$rsvp$config$$configure('instrument', true);
      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
        }
      }
    }

    var lib$rsvp$umd$$RSVP = {
      'race': lib$rsvp$race$$default,
      'Promise': lib$rsvp$promise$$default,
      'allSettled': lib$rsvp$all$settled$$default,
      'hash': lib$rsvp$hash$$default,
      'hashSettled': lib$rsvp$hash$settled$$default,
      'denodeify': lib$rsvp$node$$default,
      'on': lib$rsvp$$on,
      'off': lib$rsvp$$off,
      'map': lib$rsvp$map$$default,
      'filter': lib$rsvp$filter$$default,
      'resolve': lib$rsvp$resolve$$default,
      'reject': lib$rsvp$reject$$default,
      'all': lib$rsvp$all$$default,
      'rethrow': lib$rsvp$rethrow$$default,
      'defer': lib$rsvp$defer$$default,
      'EventTarget': lib$rsvp$events$$default,
      'configure': lib$rsvp$config$$configure,
      'async': lib$rsvp$$async
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$rsvp$umd$$RSVP; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$rsvp$umd$$RSVP;
    } else if (typeof this !== 'undefined') {
      this['RSVP'] = lib$rsvp$umd$$RSVP;
    }
}).call(this);


}).call(this,require('_process'))

},{"_process":5}],36:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DataQuery = require('../common/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CommonData = function () {
    function CommonData(sdk, settings) {
        _classCallCheck(this, CommonData);

        this.settings = settings;
        this.sdk = sdk;
    }

    CommonData.prototype.processDataQuery = function processDataQuery(query, success, error) {
        return this.sdk.processDataQuery(query, this, success, error);
    };

    CommonData.prototype.buildDataQuery = function buildDataQuery(data, op, meta) {
        return this.sdk.buildDataQuery(data, op, meta);
    };

    CommonData.prototype.create = function create(model, success, error) {
        return this.sdk.buildDataQuery(this, model, _DataQuery2.default.operations.Create, success, error);
    };

    CommonData.prototype.getById = function getById(id, success, error) {
        // return utils.buildPromise((success, error) => {
        //     let getByIdQuery = this._buildDataQuery(id, DataQuery.operations.ReadById, success, error);
        //     return super.getById(getByIdQuery);
        // }, success, error);
    };

    CommonData.prototype.get = function get(filterOrQuery, success, error) {
        // if (!filterOrQuery) {
        //     throw 'Filter for get is required';
        // }
        //
        // return utils.buildPromise((success, error) => {
        //     let getQuery = this._buildDataQuery(filterOrQuery, DataQuery.operations.Read, success, error);
        //     return super.get(getQuery);
        // }, success, error);
    };

    CommonData.prototype.count = function count(filterOrQuery, success, error) {
        // return utils.buildPromise((success, error) => {
        //     let countQuery = this._buildDataQuery(filterOrQuery, DataQuery.operations.Count, success, error);
        //     return super.count(countQuery);
        // }, success, error);
    };

    return CommonData;
}();

exports.default = CommonData;

},{"../common/dataQuery/DataQuery":41}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _underscore = require('underscore');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventArgs = function () {
    function EventArgs() {
        _classCallCheck(this, EventArgs);

        this.canceled = false;
    }

    EventArgs.prototype.cancel = function cancel() {
        this.canceled = true;
    };

    return EventArgs;
}();

/*
Adds extended functionality to the event emitter:
    * Cancelable event arguments - the event arguments are always passed as last argument,
      calling cancel will stop other event listeners in the chain from being invoked
    * prependOnceListener - Prepend a listener to the start of the chain - useful if you want
      it to be able to cancel the event
 */


var EventEmitterExtended = function (_EventEmitter) {
    _inherits(EventEmitterExtended, _EventEmitter);

    function EventEmitterExtended() {
        _classCallCheck(this, EventEmitterExtended);

        return _possibleConstructorReturn(this, _EventEmitter.apply(this, arguments));
    }

    EventEmitterExtended.prototype.emit = function emit(type) {
        var _EventEmitter$prototy;

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        args.push(new EventArgs());

        return (_EventEmitter$prototy = _EventEmitter.prototype.emit).call.apply(_EventEmitter$prototy, [this, type].concat(args));
    };

    EventEmitterExtended.prototype.addListener = function addListener(type, listener) {
        var _this2 = this;

        var wrappedListener = function wrappedListener() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            var ev = (0, _underscore.last)(args);
            if (ev.canceled) {
                return;
            }

            return listener.apply(_this2, args);
        };

        return _EventEmitter.prototype.addListener.call(this, type, wrappedListener);
    };

    EventEmitterExtended.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        this.once(type, listener);

        if (!Array.isArray(this._events[type])) {
            return this;
        }

        var lastListener = (0, _underscore.last)(this._events[type]);
        var allListeners = (0, _underscore.without)(this._events[type], lastListener);
        this._events[type] = [lastListener].concat(allListeners);
        return this;
    };

    EventEmitterExtended.prototype.once = function once() {
        var _EventEmitter$prototy2;

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }

        return (_EventEmitter$prototy2 = _EventEmitter.prototype.once).call.apply(_EventEmitter$prototy2, [this].concat(args));
    };

    EventEmitterExtended.prototype.on = function on() {
        return this.addListener.apply(this, arguments);
    };

    return EventEmitterExtended;
}(_events2.default);

exports.default = EventEmitterExtended;

},{"events":2,"underscore":36}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Processor = require('../common/dataQuery/Processor');

var _Processor2 = _interopRequireDefault(_Processor);

var _ErrorProcessor = require('../common/processors/ErrorProcessor');

var _ErrorProcessor2 = _interopRequireDefault(_ErrorProcessor);

var _DataQueryBuilder = require('../common/dataQuery/DataQueryBuilder');

var _DataQueryBuilder2 = _interopRequireDefault(_DataQueryBuilder);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MethodMustBeOverridenError = new Error('Method must be overriden');

var Sdk = function () {
    function Sdk(options) {
        _classCallCheck(this, Sdk);

        this.options = options;
        this.setup = this._getSetup(options);

        this.dataQueryProcessor = this._getDataQueryProcessor();
        this.dataQueryBuilder = this._getDataQueryBuilder();

        this.authentication = this._getAuthentication();

        this.registerErrorProcessor(new _ErrorProcessor2.default());
    }

    Sdk.prototype.registerDataQueryPreProcessor = function registerDataQueryPreProcessor(processor) {
        this.dataQueryProcessor.preProcessors.push(processor);
    };

    Sdk.prototype.registerDataQueryProcessor = function registerDataQueryProcessor(processor) {
        this.dataQueryProcessor.processors.push(processor);
    };

    Sdk.prototype.registerDataQueryPostProcessor = function registerDataQueryPostProcessor(processor) {
        this.dataQueryProcessor.postProcessors.push(processor);
    };

    Sdk.prototype.registerErrorProcessor = function registerErrorProcessor(processor) {
        this.dataQueryProcessor.errorProcessors.push(processor);
    };

    Sdk.prototype.processDataQuery = function processDataQuery(query, data, success, error) {
        return this.dataQueryProcessor.process(query, data, success, error);
    };

    Sdk.prototype.buildDataQuery = function buildDataQuery() {
        var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var op = arguments[1];
        var meta = arguments[2];

        return this.dataQueryBuilder.buildDataQuery(data, op, meta);
    };

    Sdk.prototype.data = function data(name) {
        return this._getData(name);
    };

    Sdk.prototype._getDataQueryProcessor = function _getDataQueryProcessor() {
        return new _Processor2.default(this);
    };

    Sdk.prototype._getDataQueryBuilder = function _getDataQueryBuilder() {
        return new _DataQueryBuilder2.default();
    };

    Sdk.prototype._getSetup = function _getSetup(options) {
        throw MethodMustBeOverridenError;
    };

    Sdk.prototype._getData = function _getData(name) {
        throw MethodMustBeOverridenError;
    };

    Sdk.prototype._getAuthentication = function _getAuthentication() {
        throw MethodMustBeOverridenError;
    };

    return Sdk;
}();

exports.default = Sdk;

},{"../common/dataQuery/DataQueryBuilder":42,"../common/dataQuery/Processor":43,"../common/processors/ErrorProcessor":52,"underscore":36}],40:[function(require,module,exports){
"use strict";

/**
 * Constants used by the SDK* @typedef {Object} Everlive.Constants
 */

var constants = {};

module.exports = constants;

},{}],41:[function(require,module,exports){
'use strict';

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataQuery = function (_EventEmitter) {
    _inherits(DataQuery, _EventEmitter);

    function DataQuery(config) {
        _classCallCheck(this, DataQuery);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.config = config;
        _this.data = config.data;
        _this.query = config.query;
        _this.originalParameters = config.originalParameters;
        _this.operation = config.operation;
        _this.additionalOptions = config.additionalOptions;
        return _this;
    }

    return DataQuery;
}(_events2.default);

module.exports = DataQuery;

},{"events":2}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _DataQuery = require('../../common/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _Query = require('../../common/query/Query');

var _Query2 = _interopRequireDefault(_Query);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataQueryBuilder = function () {
    function DataQueryBuilder() {
        _classCallCheck(this, DataQueryBuilder);
    }

    DataQueryBuilder.prototype._getInitialDataQuery = function _getInitialDataQuery(operation, meta) {
        return new _DataQuery2.default({ meta: meta, operation: operation });
    };

    DataQueryBuilder.prototype.buildDataQuery = function buildDataQuery(data, op, meta) {
        var dataQuery = this._getInitialDataQuery(op, meta);

        if (data instanceof _Query2.default) {
            dataQuery.query = data;
        }

        if (data) {
            dataQuery.additionalOptions = data.additionalOptions;
        }

        var extendedDataQuery = _underscore2.default.extend(dataQuery, meta);

        return extendedDataQuery;
    };

    return DataQueryBuilder;
}();

exports.default = DataQueryBuilder;

},{"../../common/dataQuery/DataQuery":41,"../../common/query/Query":53,"underscore":36}],43:[function(require,module,exports){
'use strict';

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _QueryProcessorIterator = require('../../common/dataQuery/QueryProcessorIterator');

var _QueryProcessorIterator2 = _interopRequireDefault(_QueryProcessorIterator);

var _errors = require('../../common/errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../../common/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QueryProcessor = function () {
    function QueryProcessor(sdk) {
        _classCallCheck(this, QueryProcessor);

        this.sdk = sdk;

        this.preProcessors = [];
        this.processors = [];
        this.postProcessors = [];
        this.errorProcessors = [];
    }

    QueryProcessor.prototype._iterate = function _iterate(query, processors, data, value) {
        var _this = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var iterator = new _QueryProcessorIterator2.default(processors, query);

            var iteratorTimeout = null;
            var onNext = function onNext(processor, value) {
                clearTimeout(iteratorTimeout);
                iteratorTimeout = setTimeout(function () {
                    return iterator.error(new Error('Iterator timed out. Processor: ' + processor.constructor.name + '. Value - ' + JSON.stringify(value)));
                }, 10 * 6000); //throw error if somewhere the chain hangs for more than 10 seconds

                try {
                    return processor.processDataQuery(query, iterator, data, value);
                } catch (e) {
                    return iterator.error(e);
                }
            };

            var cleanUp = function cleanUp() {
                iterator.removeListener('next', onNext);
                clearTimeout(iteratorTimeout);
            };

            iterator.on('next', onNext).once('end', function (value) {
                cleanUp();
                return resolve(value);
            }).once('error', function (err) {
                cleanUp();
                var processedError = _this._processError(query, data, err);
                var error = processedError || err;
                return reject(error);
            }).once('cancel', function (reason) {
                cleanUp();
                return reject({
                    reason: reason,
                    error: _errors2.default.cancelled
                });
            }).start(value);
        });
    };

    QueryProcessor.prototype._preProcess = function _preProcess(query, data) {
        return this._iterate(query, this.preProcessors, data);
    };

    QueryProcessor.prototype._process = function _process(query, data, value) {
        return this._iterate(query, this.processors, data, value);
    };

    QueryProcessor.prototype._postProcess = function _postProcess(query, data, value) {
        return this._iterate(query, this.postProcessors, data, value);
    };

    QueryProcessor.prototype._processError = function _processError(query, data, err) {
        var error = err;
        this.errorProcessors.forEach(function (p) {
            error = p.processError(query, data, error);
        });

        return error;
    };

    QueryProcessor.prototype.process = function process(query, data, success, error) {
        var _this2 = this;

        return (0, _utils.buildPromise)(function (resolve, reject) {
            return _this2._preProcess(query, data).then(function (value) {
                return _this2._process(query, data, value);
            }).then(function (value) {
                return _this2._postProcess(query, data, value);
            }).then(function (res) {
                resolve(res);
            }).catch(function (err) {
                reject(err);
            });
        }, success, error);
    };

    return QueryProcessor;
}();

module.exports = QueryProcessor;

},{"../../common/dataQuery/QueryProcessorIterator":44,"../../common/errors":45,"../../common/utils":54,"rsvp":35}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _EventEmitterExtended2 = require('../../common/EventEmitterExtended');

var _EventEmitterExtended3 = _interopRequireDefault(_EventEmitterExtended2);

var _underscore = require('underscore');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var QueryProcessorIterator = function (_EventEmitterExtended) {
    _inherits(QueryProcessorIterator, _EventEmitterExtended);

    function QueryProcessorIterator(processors, query) {
        _classCallCheck(this, QueryProcessorIterator);

        var _this = _possibleConstructorReturn(this, _EventEmitterExtended.call(this));

        _this.done = false;
        _this.position = -1;

        _this.processors = processors;

        //helps with debugging
        _this.$id = (0, _underscore.random)(0, 5000);
        _this.$query = query;
        _this.$operation = query.operation;

        _this._initialValue = null;
        return _this;
    }

    QueryProcessorIterator.prototype.restart = function restart() {
        var value = arguments.length <= 0 || arguments[0] === undefined ? this._initialValue : arguments[0];

        return this.start(value);
    };

    QueryProcessorIterator.prototype.start = function start(value) {
        this._initialValue = value;
        this.position = -1;
        this.done = false;
        return this.next(value);
    };

    QueryProcessorIterator.prototype.next = function next(value) {
        this.position++;
        if (this.position >= this.processors.length) {
            return this.end(value);
        }

        var nextProcessor = this.processors[this.position];
        return this.emit('next', nextProcessor, value);
    };

    QueryProcessorIterator.prototype.end = function end(value) {
        this.done = true;
        return this.emit('end', value);
    };

    QueryProcessorIterator.prototype.cancel = function cancel(reason) {
        this.done = true;
        return this.emit('cancel', reason);
    };

    QueryProcessorIterator.prototype.error = function error(_error) {
        return this.emit('error', _error);
    };

    return QueryProcessorIterator;
}(_EventEmitterExtended3.default);

exports.default = QueryProcessorIterator;

},{"../../common/EventEmitterExtended":38,"underscore":36}],45:[function(require,module,exports){
'use strict';

var Errors = {};

Errors.cancelled = {
    code: 3000,
    message: 'Cancelled.'
};

module.exports = Errors;

},{}],46:[function(require,module,exports){
'use strict';

require('../common/mixins/mixins');

},{"../common/mixins/mixins":47}],47:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _underscoreDeepExtend = require('../../common/mixins/underscoreDeepExtend');

var _underscoreDeepExtend2 = _interopRequireDefault(_underscoreDeepExtend);

var _underscoreCompactObject = require('../../common/mixins/underscoreCompactObject');

var _underscoreCompactObject2 = _interopRequireDefault(_underscoreCompactObject);

var _underscoreIsObjectEmpty = require('../../common/mixins/underscoreIsObjectEmpty');

var _underscoreIsObjectEmpty2 = _interopRequireDefault(_underscoreIsObjectEmpty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_underscore2.default.mixin({ 'deepExtend': _underscoreDeepExtend2.default });
_underscore2.default.mixin({ 'compactObject': _underscoreCompactObject2.default });
_underscore2.default.mixin({ 'isEmptyObject': _underscoreIsObjectEmpty2.default });

},{"../../common/mixins/underscoreCompactObject":48,"../../common/mixins/underscoreDeepExtend":49,"../../common/mixins/underscoreIsObjectEmpty":50,"underscore":36}],48:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//http://stackoverflow.com/questions/14058193/remove-empty-properties-falsy-values-from-object-with-underscore-js
module.exports = function compactObject(o) {
    var newObject = {};
    _underscore2.default.each(o, function (v, k) {
        if (v !== null && v !== undefined) {
            newObject[k] = v;
        }
    });

    return newObject;
};

},{"underscore":36}],49:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function deepExtend(obj) {
    var parentRE = /#{\s*?_\s*?}/,
        slice = Array.prototype.slice;

    _underscore2.default.each(slice.call(arguments, 1), function (source) {
        for (var prop in source) {
            if (_underscore2.default.isUndefined(obj[prop]) || _underscore2.default.isFunction(obj[prop]) || _underscore2.default.isNull(source[prop]) || _underscore2.default.isDate(source[prop])) {
                obj[prop] = source[prop];
            } else if (_underscore2.default.isString(source[prop]) && parentRE.test(source[prop])) {
                if (_underscore2.default.isString(obj[prop])) {
                    obj[prop] = source[prop].replace(parentRE, obj[prop]);
                }
            } else if (_underscore2.default.isArray(obj[prop]) || _underscore2.default.isArray(source[prop])) {
                if (!_underscore2.default.isArray(obj[prop]) || !_underscore2.default.isArray(source[prop])) {
                    throw new Error('Trying to combine an array with a non-array (' + prop + ')');
                } else {
                    obj[prop] = _underscore2.default.reject(_underscore2.default.deepExtend(_underscore2.default.clone(obj[prop]), source[prop]), function (item) {
                        return _underscore2.default.isNull(item);
                    });
                }
            } else if (_underscore2.default.isObject(obj[prop]) || _underscore2.default.isObject(source[prop])) {
                if (!_underscore2.default.isObject(obj[prop]) || !_underscore2.default.isObject(source[prop])) {
                    throw new Error('Trying to combine an object with a non-object (' + prop + ')');
                } else {
                    obj[prop] = _underscore2.default.deepExtend(_underscore2.default.clone(obj[prop]), source[prop]);
                }
            } else {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

/**
 * Dependency: underscore.js ( http://documentcloud.github.com/underscore/ )
 *
 * Mix it in with underscore.js:
 * _.mixin({deepExtend: deepExtend});
 *
 * Call it like this:
 * var myObj = _.deepExtend(grandparent, child, grandchild, greatgrandchild)
 *
 * Notes:
 * Keep it DRY.
 * This function is especially useful if you're working with JSON config documents. It allows you to create a default
 * config document with the most common settings, then override those settings for specific cases. It accepts any
 * number of objects as arguments, giving you fine-grained control over your config document hierarchy.
 *
 * Special Features and Considerations:
 * - parentRE allows you to concatenate strings. example:
 *   var obj = _.deepExtend({url: "www.example.com"}, {url: "http://#{_}/path/to/file.html"});
 *   console.log(obj.url);
 *   output: "http://www.example.com/path/to/file.html"
 *
 * - parentRE also acts as a placeholder, which can be useful when you need to change one value in an array, while
 *   leaving the others untouched. example:
 *   var arr = _.deepExtend([100,    {id: 1234}, true,  "foo",  [250, 500]],
 *                          ["#{_}", "#{_}",     false, "#{_}", "#{_}"]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - The previous example can also be written like this:
 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
 *                          ["#{_}", {},          false, "#{_}", []]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - And also like this:
 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
 *                          ["#{_}", {},          false]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - Array order is important. example:
 *   var arr = _.deepExtend([1, 2, 3, 4], [1, 4, 3, 2]);
 *   console.log(arr);
 *   output: [1, 4, 3, 2]
 *
 * - You can remove an array element set in a parent object by setting the same index value to null in a child object.
 *   example:
 *   var obj = _.deepExtend({arr: [1, 2, 3, 4]}, {arr: ["#{_}", null]});
 *   console.log(obj.arr);
 *   output: [1, 3, 4]
 *
 **/
/*  Copyright (C) 2012-2014  Kurt Milam - http://xioup.com | Source: https://gist.github.com/1868955
 *   
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **/

// Based conceptually on the _.extend() function in underscore.js ( see http://documentcloud.github.com/underscore/#extend for more details )

},{"underscore":36}],50:[function(require,module,exports){
// http://stackoverflow.com/questions/4994201/is-object-empty
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEmpty(obj) {

    // null and undefined are "empty"
    if (obj == null) return true;

    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0) return false;
    if (obj.length === 0) return true;

    // Otherwise, does it have any properties of its own?
    // Note that this doesn't handle
    // toString and valueOf enumeration bugs in IE < 9
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }

    return true;
}

module.exports = isEmpty;

},{}],51:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var isNativeScript = Boolean(typeof android !== 'undefined' && android && android.widget && android.widget.Button || typeof UIButton !== 'undefined' && UIButton);

var platform;
var isCordova = false;
var isWindowsPhone = false;
var isAndroid = false;

if (typeof window !== 'undefined' && !isNativeScript) {
    isCordova = /^file:\/{3}[^\/]|x-wmapp/i.test(window.location.href) && /ios|iphone|ipod|ipad|android|iemobile/i.test(navigator.userAgent);
    isWindowsPhone = isCordova && /iemobile/i.test(navigator.userAgent);
    isAndroid = isCordova && cordova.platformId === 'android';
}

var isNodejs = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;
var isDesktop = !isNativeScript && !isCordova && !isNodejs;

if (isNativeScript) {
    platform = 'ns';
} else if (isNodejs) {
    platform = 'nodejs';
} else if (isDesktop) {
    platform = 'desktop';
} else if (isCordova) {
    platform = 'cordova';
}

var isInAppBuilderSimulator = function isInAppBuilderSimulator() {
    return typeof window !== 'undefined' && window.navigator && window.navigator.simulator;
};

module.exports = {
    isCordova: isCordova,
    isNativeScript: isNativeScript,
    isDesktop: isDesktop,
    isWindowsPhone: isWindowsPhone,
    isAndroid: isAndroid,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs,
    platform: platform,
    isInAppBuilderSimulator: isInAppBuilderSimulator
};

},{}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = require('../../common/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ErrorProcessor = function () {
    function ErrorProcessor() {
        _classCallCheck(this, ErrorProcessor);
    }

    ErrorProcessor.prototype.processError = function processError(query, data, err) {
        var setup = data.sdk.setup;

        var parseOnlyCompleteDateTimeString = setup && setup.parseOnlyCompleteDateTimeObjects;
        var reviver = _utils.parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

        return _utils.parseUtilities.parseXhrError(reviver, err);
    };

    return ErrorProcessor;
}();

exports.default = ErrorProcessor;

},{"../../common/utils":54}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Query = function Query() {
  _classCallCheck(this, Query);
};

exports.default = Query;

},{}],54:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _platform = require('../common/platform');

var _platform2 = _interopRequireDefault(_platform);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _EverliveError = require('../everlive/EverliveError');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new _EverliveError.EverliveError(message);
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = utils.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.getCallbacks = function (success, error) {
    var promise;
    var createPromise = function createPromise() {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            success = function success(data) {
                resolve(data);
            };
            error = function error(_error) {
                reject(_error);
            };
        });
    };

    if (_platform2.default.isNodejs) {
        // node js style continuation
        if (typeof success === 'function' && typeof error !== 'function') {
            var callback = success;
            success = function success(data, response) {
                callback(null, data, response);
            };
            error = function error(_error2) {
                callback(_error2);
            };
        } else if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    } else {
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    }

    return { promise: promise, success: success, error: error };
};

utils.parseUtilities = {
    getReviver: function getReviver(parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        };
    },

    parseIsoDateString: function parseIsoDateString(string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                } else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(Date.UTC(Number(match[1]), // year
            Number(match[3]) - 1 || 0, // month
            Number(match[5]) || 0, // day
            Number(match[7]) || 0, // hour
            Number(match[8]) || 0, // minute
            Number(match[10]) || 0, // second
            Number(secondParts) || 0));

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+") offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function parseOnlyCompleteDateTimeString(string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function traverse(obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
        return obj;
    },

    traverseAndRevive: function traverseAndRevive(data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        return utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function parseError(reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return { message: error.message, code: error.errorCode };
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function _parseInternal(reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function _transformResult(data, additionalProperties) {
        if (data) {
            var result = _underscore2.default.extend({}, additionalProperties);
            result.result = data.Result === undefined ? data.result : data.Result;
            result.count = data.Count === undefined ? data.count : data.Count;
            return result;
        } else {
            return data;
        }
    },

    parseResult: function parseResult(reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, { count: data.Count });
    },

    parseSingleResult: function parseSingleResult(reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function parseUpdateResult(reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, { ModifiedAt: data.ModifiedAt });
    },

    parseJSON: function parseJSON(json) {
        return JSON.parse(json, utils.parseUtilities.getReviver());
    },

    parseXhrResponse: function parseXhrResponse(xhrRequest) {
        var type = xhrRequest.getResponseHeader('content-type');
        var isJson = type && type.toLowerCase().indexOf('json') > -1;
        var response = xhrRequest.responseText || xhrRequest.statusText;

        return isJson ? utils.parseUtilities.parseJSON(response) : response;
    },
    parseXhrError: function parseXhrError(reviver, xhrRequest) {
        if (xhrRequest instanceof Error) {
            return xhrRequest;
        }

        var message = xhrRequest.responseText || xhrRequest.statusText || xhrRequest;
        return utils.parseUtilities.parseError(reviver, message);
    },

    parseErrorOrResponse: function parseErrorOrResponse(error) {
        if (error instanceof XMLHttpRequest) {
            var parsedError = utils.parseUtilities.parseXhrResponse(error);
            //seems that parseXhrResponse is inconsistent
            return {
                code: parsedError.code || parsedError.errorCode,
                message: parsedError.message
            };
        }

        return utils.parseUtilities.parseError(null, error);
    }
};

utils.isDate = function (date) {
    return date && (date instanceof Date || !_underscore2.default.isNaN(Date.parse(date)));
};

utils.cloneDate = function (date) {
    return new Date(date);
};

// http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid
utils.isGuid = function (str) {
    return (/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str)
    );
};

utils.successfulPromise = function (data) {
    return new _rsvp2.default.Promise(function (resolve) {
        resolve(data);
    });
};

utils.rejectedPromise = function (err) {
    return new _rsvp2.default.Promise(function (resolve, reject) {
        reject(err);
    });
};

utils.uuid = function () {
    //http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
    });

    return uuid;
};

module.exports = utils;

},{"../common/platform":51,"../everlive/EverliveError":58,"rsvp":35,"underscore":36}],55:[function(require,module,exports){
'use strict';

var _EverliveError = require('../everlive/EverliveError');

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {

    function AutoQueue(maxConcurrentTasks) {
        maxConcurrentTasks = parseInt(maxConcurrentTasks || _constants2.default.MaxConcurrentDownloadTasks);

        if (isNaN(maxConcurrentTasks) || maxConcurrentTasks <= 0) {
            throw new _EverliveError.EverliveError('The maxConcurrentTasks must be a number larger than 0');
        }

        this.maxConcurrentTasks = maxConcurrentTasks;
        this.runningTasksCount = 0;
        this.tasks = [];
    }

    AutoQueue.prototype = {
        /**
         * @param {Function} task
         * @param {Function} taskSuccess
         * @param {Function} taskError
         */
        enqueue: function enqueue(task, taskSuccess, taskError) {
            if (!_underscore2.default.isFunction(taskSuccess) || !_underscore2.default.isFunction(taskError)) {
                throw new _EverliveError.EverliveError('taskSuccess and taskError functions must be provided');
            }

            var args = [].splice.call(arguments, 3);

            this.tasks.push({
                task: task,
                args: args,
                success: taskSuccess,
                error: taskError
            });

            this._runNext();
        },

        _runNext: function _runNext() {
            var self = this;

            if (self.runningTasksCount === self.maxConcurrentTasks || !self.tasks.length) {
                return;
            }

            self.runningTasksCount++;

            var nextTask = this.tasks.shift();
            var task = nextTask.task;
            var args = nextTask.args;
            var taskSuccess = nextTask.success;
            var taskError = nextTask.error;

            args.unshift(function executedCallback(err) {
                self.runningTasksCount--;

                if (err) {
                    taskError(err);
                } else {
                    taskSuccess.apply(null, [].splice.call(arguments, 1));
                }

                self._runNext();
            });

            task.apply(null, args);
        }
    };

    return AutoQueue;
}();

},{"../everlive/EverliveError":58,"../everlive/constants":70,"underscore":36}],56:[function(require,module,exports){
'use strict';

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var apply = function apply(obj) {
    obj._emitter = new _events2.default();

    obj._emitterProxy = function (event, args) {
        obj._emitter[event].apply(obj._emitter, args);
    };

    obj.addListener = function () {
        obj._emitterProxy('addListener', arguments);
    };

    obj.on = obj.addListener;

    obj.removeListener = function () {
        obj._emitterProxy('removeListener', arguments);
    };

    obj.off = obj.removeListener;

    obj.once = function () {
        obj._emitterProxy('once', arguments);
    };

    obj.removeAllListeners = function () {
        obj._emitterProxy('removeAllListeners', arguments);
    };
};

module.exports = {
    apply: apply
};

},{"events":2}],57:[function(require,module,exports){
'use strict';

var _Sdk2 = require('../common/Sdk');

var _Sdk3 = _interopRequireDefault(_Sdk2);

var _Setup = require('../everlive/Setup');

var _Setup2 = _interopRequireDefault(_Setup);

var _Data = require('../everlive/types/Data');

var _Data2 = _interopRequireDefault(_Data);

var _Users = require('../everlive/types/Users');

var _Users2 = _interopRequireDefault(_Users);

var _Files = require('../everlive/types/Files');

var _Files2 = _interopRequireDefault(_Files);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _utils = require('../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _Push = require('../everlive/Push');

var _Push2 = _interopRequireDefault(_Push);

var _Authentication = require('../everlive/auth/Authentication');

var _Authentication2 = _interopRequireDefault(_Authentication);

var _offline = require('../everlive/offline/offline');

var _offline2 = _interopRequireDefault(_offline);

var _caching = require('../everlive/caching/caching');

var _caching2 = _interopRequireDefault(_caching);

var _Request = require('../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _EverliveError = require('../everlive/EverliveError');

var _helpers = require('../everlive/helpers/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _EventEmitterProxy = require('../everlive/EventEmitterProxy');

var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

var _BusinessLogic = require('../everlive/business-logic/BusinessLogic');

var _BusinessLogic2 = _interopRequireDefault(_BusinessLogic);

var _DataPreprocessor = require('../everlive/types/preProcessors/DataPreprocessor');

var _DataPreprocessor2 = _interopRequireDefault(_DataPreprocessor);

var _OfflineQueryPreprocessor = require('../everlive/types/preProcessors/OfflineQueryPreprocessor');

var _OfflineQueryPreprocessor2 = _interopRequireDefault(_OfflineQueryPreprocessor);

var _BusinessLogicQueryProcessor = require('../everlive/types/processors/BusinessLogicQueryProcessor');

var _BusinessLogicQueryProcessor2 = _interopRequireDefault(_BusinessLogicQueryProcessor);

var _EventQueryProcessor = require('../everlive/types/processors/EventQueryProcessor');

var _EventQueryProcessor2 = _interopRequireDefault(_EventQueryProcessor);

var _AuthenticationProcessor = require('../everlive/types/processors/AuthenticationProcessor');

var _AuthenticationProcessor2 = _interopRequireDefault(_AuthenticationProcessor);

var _OfflineQueryProcessor = require('../everlive/types/processors/OfflineQueryProcessor');

var _OfflineQueryProcessor2 = _interopRequireDefault(_OfflineQueryProcessor);

var _OnlineQueryProcessor = require('../everlive/types/processors/OnlineQueryProcessor');

var _OnlineQueryProcessor2 = _interopRequireDefault(_OnlineQueryProcessor);

var _CacheQueryProcessor = require('../everlive/types/processors/CacheQueryProcessor');

var _CacheQueryProcessor2 = _interopRequireDefault(_CacheQueryProcessor);

var _ResponseParserProcessor = require('../everlive/response/ResponseParserProcessor');

var _ResponseParserProcessor2 = _interopRequireDefault(_ResponseParserProcessor);

var _ResponseTransformProcessor = require('../everlive/response/ResponseTransformProcessor');

var _ResponseTransformProcessor2 = _interopRequireDefault(_ResponseTransformProcessor);

var _DataQueryBuilder = require('../everlive/dataQuery/DataQueryBuilder');

var _DataQueryBuilder2 = _interopRequireDefault(_DataQueryBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// An array keeping initialization functions called by the Everlive constructor.
// These functions will be used to extend the functionality of an Everlive instance.
var initializations = [];
function protectOfflineEnabled() {
    if (!this._isOfflineStorageEnabled()) {
        throw new _EverliveError.EverliveError('You have instantiated the SDK without support for offline storage');
    }
}

var Everlive = function (_Sdk) {
    _inherits(Everlive, _Sdk);

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */


    /**
     * Adds an event listener to the SDK.
     * @method addListener
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK.
     * @method on
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method removeListener
     * @param {String} eventName The name of the event for which to stop listening.
     * @param {Function} eventListener The event listener to remove.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method off
     * @param {Function} eventListener
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK which will be called only the first time the event is emitted.
     * @method once
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes all SDK event listeners.
     * @memberOf Everlive.prototype
     * @method removeAllListeners
     */

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */

    Everlive.init = function init(options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    Everlive.disableRequestCache = function disableRequestCache() {
        return _utils2.default.disableRequestCache();
    };

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your App ID.
     * @param {string} options.apiKey - Your API Key. *Deprecated*: use options.appId instead.
     * @param {string} options.appId - Your Telerik Platform app's App ID.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.masterKey] - The master key of the Telerik Platform app. Use this authorization scheme for operations that require it or to override you app's access control. Use only for development purposes. Do not deploy it with your app.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offline] - Set this option to true to enable Offline Support using the default offline settings.
     * @param {boolean} [options.offline.enabled=false] - When using an object to initialize Offline Support with non-default settings, set this option to enable or disable Offline Support.
     * @param {boolean} [options.offline.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offline.conflicts.strategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {boolean} [options.offline.syncUnmodified=false] - Whether to synchronize items updated or deleted on the server but not on the device.
     * @param {object} [options.offline.storage] - An object specifying settings for the offline storage.
     * @param {string} [options.offline.storage.provider=_platform dependant_] - Allows you to select an offline storage provider. Possible values: Everlive.Constants.StorageProvider.LocalStorage, Everlive.Constants.StorageProvider.FileSystem, Everlive.Constants.StorageProvider.Custom. Default value: Cordova, Web: Everlive.Constants.StorageProvider.LocalStorage; NativeScript, Node.js: Everlive.Constants.StorageProvider.FileSystem.
     * @param {string} [options.offline.storage.storagePath=el_store] - A relative path specifying where data will be saved if the FileSystem provider is used.
     * @param {number} [options.offline.storage.requestedQuota=10485760] - How much memory (in bytes) to be requested when using FileSystem for persistence. This option is only valid for Chrome as the other platforms use all the available space.
     * @param {object} [options.offline.storage.implementation] - When storage.provider is set to custom, use this object to specify your custom offline storage implementation.
     * @param {string} [options.offline.encryption.key] - A key that will be used to encrypt the data stored offline.
     * @param {string} [options.offline.files.storagePath=el_file_store] - A relative path specifying where the files will be saved if file system is used for persistence of files in offline mode.
     * @param {string} [options.offline.files.metaPath=el_file_mapping] - A relative path specifying where the metadata file will be saved if file system is used for persistence of files in offline mode.
     * @param {object|boolean} [options.offline.files] - Set this option to true to enable support for files in offline mode.
     * @param {number} [options.offline.files.maxConcurrentDownloads] - The maximum amount of files that can be downloaded simultaneously.
     * @param {boolean} [options.authentication.persist=false] - Indicates whether the current user's authentication will be persisted.
     * @param {Function} [options.authentication.onAuthenticationRequired] - Invoked when the user's credentials have expired. Allowing you to perform custom logic.
     * @param {object} [options.helpers] - An object holding options for all Everlive helper components.
     * @param {object} [options.helpers.html] - HTML Helper configuration objects.
     * @param {boolean} [options.helpers.html.processOnLoad=false] - Whether to process all HTML elements when the window loads.
     * @param {boolean} [options.helpers.html.processOnResize=false] - Whether to process all HTML elements when the window resizes.
     * @param {string} [options.helpers.html.loadingImageUrl] - The image to be displayed while the original image is being processed.
     * @param {string} [options.helpers.html.errorImageUrl] - The image to be displayed when the original image processing fails.
     * @param {object} [options.helpers.html.attributes] - HTML Helper attributes configuration object.
     * @param {object} [options.helpers.html.attributes.loadingImage=data-loading-image] - A custom name for the attribute to be used to set a loading image.
     * @param {object} [options.helpers.html.attributes.errorImage=data-error-image] - A custom name for the attribute to be used to set an error image.
     * @param {object} [options.helpers.html.attributes.dpi=data-dpi] - A custom name for the attribute to be used to specify DPI settings.
     * @param {object} [options.helpers.html.attributes.imageSource=data-src] - A custom name for the attribute to be used to set the image source.
     * @param {object} [options.helpers.html.attributes.fileSource=data-href] - A custom name for the attribute to be used to set the anchor source.
     * @param {object} [options.helpers.html.attributes.enableOffline=data-offline] - A custom name for the attribute to be used to control offline processing.
     * @param {object} [options.helpers.html.attributes.enableResponsive=data-responsive] - A custom name for the attribute to be used to control Responsive Images processing.
     * @param {object|boolean} [options.caching=false] - Set this option to true to enable caching using the default cache settings.
     * @param {number} [options.caching.maxAge=60] - Global setting for maximum age of cached items in minutes.
     * @param {boolean} [options.caching.enabled=false] - Global setting for enabling or disabling cache.
     * @param {object} [options.caching.typeSettings] - Specify per-content-type settings that override the global settings.
     */


    function Everlive(options) {
        _classCallCheck(this, Everlive);

        var _this = _possibleConstructorReturn(this, _Sdk.call(this, options));

        _this.push = _this._getPush();
        _this.files = _this.Files = _this._getFiles(); //TODO: remove Files as they are deprecated
        _this.users = _this.Users = _this._getUsers(); //TODO: remove Users as its obsolete
        _this.businessLogic = _this._getBusinessLogic();

        //some fields from the setup need to propagate to the initializations, e.g. the appId and apiKey
        //since they are being set correctly when appId or apiKey is passed to the options
        var fieldsToPropagate = _underscore2.default.pick(_this.setup, ['appId', 'apiKey']);
        var extendedOptions = _underscore2.default.extend({}, options, fieldsToPropagate);
        _underscore2.default.each(initializations, function (init) {
            init.func.call(_this, extendedOptions);
        });

        if (Everlive.$ === null) {
            Everlive.$ = _this;
        }

        _this.registerDataQueryPreProcessor(new _DataPreprocessor2.default());
        _this.registerDataQueryPreProcessor(new _OfflineQueryPreprocessor2.default());

        _this.registerDataQueryProcessor(new _BusinessLogicQueryProcessor2.default());
        _this.registerDataQueryProcessor(new _EventQueryProcessor2.default());
        _this.registerDataQueryProcessor(new _AuthenticationProcessor2.default());
        _this.registerDataQueryProcessor(new _OfflineQueryProcessor2.default());
        _this.registerDataQueryProcessor(new _OnlineQueryProcessor2.default());
        _this.registerDataQueryProcessor(new _CacheQueryProcessor2.default());

        _this.registerDataQueryPostProcessor(new _ResponseParserProcessor2.default());
        _this.registerDataQueryPostProcessor(new _ResponseTransformProcessor2.default());

        _EventEmitterProxy2.default.apply(_this);
        return _this;
    }

    /**
     * Creates a new {@link Data} class.
     * @memberOf Everlive.prototype
     * @instance
     * @param {String} collectionName The name of the collection to be used.
     * @returns {Data}
     */


    Everlive.prototype._getData = function _getData(collectionName) {
        return new _Data2.default(this, collectionName);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */


    Everlive.prototype.buildUrl = function buildUrl() {
        return _utils2.default.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */


    Everlive.prototype.buildAuthHeader = function buildAuthHeader() {
        return (0, _utils.buildAuthHeader)(this.setup);
    };

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see [authentication.getAuthenticationStatus]{@link ../Authentication/authentication.getAuthenticationStatus}
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see [authentication.getAuthenticationStatus]{@link ../Authentication/authentication.getAuthenticationStatus}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Everlive.prototype.authInfo = function authInfo(success, error) {
        var _this2 = this;

        return _utils2.default.buildPromise(function (success, error) {
            var setup = _this2.setup;
            if (setup.masterKey) {
                return success({ status: Everlive.AuthStatus.masterKey });
            }

            if (!setup.token) {
                return success({ status: Everlive.AuthStatus.unauthenticated });
            }

            if (_this2.authentication && _this2.authentication.isAuthenticationInProgress()) {
                return success({ status: Everlive.AuthStatus.authenticating });
            }

            _this2.users.skipAuth(true).currentUser().then(function (res) {
                return success({ status: Everlive.AuthStatus.authenticated, user: res.result });
            }, function (err) {
                if (_this2.authentication && _this2.authentication.isAuthenticationInProgress()) {
                    return success({ status: Everlive.AuthStatus.authenticating });
                } else if (err.code === _EverliveError.EverliveErrors.invalidRequest.code || err.code === _EverliveError.EverliveErrors.expiredToken.code) {
                    // invalid request, i.e. the access token is invalid or missing
                    return success({ status: Everlive.AuthStatus.invalidAuthentication });
                } else {
                    return error(err);
                }
            });
        }, success, error);
    };

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the App ID section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */


    Everlive.prototype.request = function request(options) {
        return new _Request2.default(this.setup, options);
    };

    /**
     * Sets the SDK to work in offline mode.
     * @method offline
     * @memberOf Everlive.prototype
     * @param {boolean} [isOffline = true] Boolean parameter for setting the SDK to online or offline mode.
     */


    Everlive.prototype.offline = function offline() {
        protectOfflineEnabled.call(this);

        var isOffline;
        if (arguments.length === 0) {
            isOffline = true;
        } else {
            isOffline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(isOffline);
    };

    /**
     * Sets the SDK to work in online mode.
     * @method online
     * @memberOf Everlive.prototype
     * @param {boolean} [isOnline = true] Boolean parameter for setting the SDK to online or offline mode.
     */


    Everlive.prototype.online = function online() {
        protectOfflineEnabled.call(this);

        var isOnline;
        if (arguments.length === 0) {
            isOnline = true;
        } else {
            isOnline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(!isOnline);
    };

    /**
     * Check if the SDK is in offline mode.
     * @method isOffline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in offline mode.
     */


    Everlive.prototype.isOffline = function isOffline() {
        protectOfflineEnabled.call(this);
        return !this.isOnline();
    };

    /**
     * Check if the SDK is in online mode.
     * @method isOnline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in online mode.
     */


    Everlive.prototype.isOnline = function isOnline() {
        return this.offlineStorage.isOnline();
    };

    /**
     * Starts the synchronization procedure. Emits the 'syncStart' event when started and the 'syncEnd' event when the procedure finishes. 'syncEnd' contains information about the completed sync operation that you can use to find out how many items were synchronized.
     * @method sync
     * @memberOf Everlive.prototype
     */


    Everlive.prototype.sync = function sync() {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
    };

    Everlive.prototype._isOfflineStorageEnabled = function _isOfflineStorageEnabled() {
        var offlineStorageOptions = this.setup.offlineStorage || this.setup.offline;
        return offlineStorageOptions && offlineStorageOptions.enabled !== false;
    };

    Everlive.prototype._getDataQueryBuilder = function _getDataQueryBuilder() {
        return new _DataQueryBuilder2.default();
    };

    Everlive.prototype._getSetup = function _getSetup(options) {
        return new _Setup2.default(options);
    };

    Everlive.prototype._getUsers = function _getUsers() {
        return new _Users2.default(this);
    };

    Everlive.prototype._getAuthentication = function _getAuthentication() {
        return new _Authentication2.default(this);
    };

    Everlive.prototype._getPush = function _getPush() {
        return new _Push2.default(this);
    };

    Everlive.prototype._getFiles = function _getFiles() {
        return new _Files2.default(this);
    };

    Everlive.prototype._getBusinessLogic = function _getBusinessLogic() {
        return new _BusinessLogic2.default(this);
    };

    return Everlive;
}(_Sdk3.default);

Everlive.$ = null;
Everlive.idField = _constants2.default.idField;
Everlive.initializations = initializations;
Everlive.AuthStatus = _constants2.default.AuthStatus;


var initDefault = function initDefault() {
    /**
     * @memberOf Everlive
     * @instance
     * @deprecated
     * @see {@link Everlive.users}
     * @description An instance of the [Users]{@link Users} class for working with users.
     * @member {Users} Users
     */
    this.Users = users;

    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [Users]{@link Users} class for working with users.
     * @member {users} users
     */
    this.users = users;

    /**
     * @memberOf Everlive
     * @instance
     * @deprecated Use everlive.files instead.
     * @see {@link Everlive.files}
     * @description An instance of the [Files]{@link Files} class for working with files.
     * @member {Files} Files
     */
    this.Files = files;

    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [Files]{@link Files} class for working with files.
     * @member {Files} files
     */
    this.files = files;

    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [Push]{@link Push} class for working with push notifications.
     * @member {Push} push
     */
    this.push = new _Push2.default(this);

    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [BusinessLogic]{@link BusinessLogic} class for invoking cloud functions and stored procedures through the SDK
     * @member {businessLogic} businessLogic
     */
    this.businessLogic = new _BusinessLogic2.default(this.setup);
};

var initAuthentication = function initAuthentication() {
    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
     * @member {Authentication} authentication
     */
    /**
     * @memberOf Everlive
     * @instance
     * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
     * @member {authentication} authentication
     */
    var auth = this._createAuthentication(this.setup.authentication);
    this.authentication = this.Authentication = auth;
};

var initializeHelpers = function initializeHelpers(options) {
    var _this3 = this;

    this.helpers = {};

    _underscore2.default.each(_helpers2.default, function (helper) {
        var helperOptions = options.helpers ? options.helpers[helper.name] : null;
        _this3.helpers[helper.name] = new helper.ctor(_this3, helperOptions);
    });
};

initializations.push({ name: 'caching', func: _caching2.default.initCaching });
initializations.push({ name: 'offlineStorage', func: _offline2.default.initOfflineStorage });
initializations.push({ name: 'cacheStore', func: _caching2.default._initStore });
initializations.push({ name: 'helpers', func: initializeHelpers });

module.exports = Everlive;

},{"../common/Sdk":39,"../everlive/EventEmitterProxy":56,"../everlive/EverliveError":58,"../everlive/Push":62,"../everlive/Request":63,"../everlive/Setup":64,"../everlive/auth/Authentication":65,"../everlive/business-logic/BusinessLogic":67,"../everlive/caching/caching":69,"../everlive/constants":70,"../everlive/dataQuery/DataQueryBuilder":72,"../everlive/helpers/helpers":75,"../everlive/offline/offline":85,"../everlive/response/ResponseParserProcessor":103,"../everlive/response/ResponseTransformProcessor":104,"../everlive/types/Data":110,"../everlive/types/Files":111,"../everlive/types/Users":112,"../everlive/types/preProcessors/DataPreprocessor":113,"../everlive/types/preProcessors/OfflineQueryPreprocessor":114,"../everlive/types/processors/AuthenticationProcessor":115,"../everlive/types/processors/BusinessLogicQueryProcessor":116,"../everlive/types/processors/CacheQueryProcessor":117,"../everlive/types/processors/EventQueryProcessor":118,"../everlive/types/processors/OfflineQueryProcessor":119,"../everlive/types/processors/OnlineQueryProcessor":120,"../everlive/utils":121,"underscore":36}],58:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _errors = require('../common/errors');

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 10001,
        message: 'A conflict occurred while syncing data.'
    },
    syncError: {
        code: 10002,
        message: 'Synchronization failed for item.'
    },
    syncInProgress: {
        code: 10003,
        message: 'Cannot perform operation while synchronization is in progress.'
    },
    syncCancelledByUser: {
        code: 10004,
        message: 'Synchronization cancelled by user.'
    },
    syncErrorUnknown: {
        code: 10005,
        message: 'An unknown error occurred while synchronizing. Please make sure there is internet connectivity.'
    },
    operationNotSupportedOffline: {
        code: 20000 // the error message is created dynamically based on the query filter for offline storage
    },
    invalidId: {
        code: 20001,
        message: 'Invalid or missing Id in model.'
    },
    bodyWithGetRequestNotSupported: {
        code: 601,
        message: 'Sending a request body is not supported for "GET" requests.'
    },
    invalidOrMissingFunctionName: {
        code: 601,
        message: 'Invalid or missing cloud function name.'
    },
    invalidOrMissingProcedureName: {
        code: 601,
        message: 'Invalid or missing procedure name.'
    },
    generalDatabaseError: {
        code: 107,
        message: 'General database error.'
    },
    invalidToken: {
        code: 301,
        message: 'Invalid access token.'
    },
    expiredToken: {
        code: 302,
        message: 'Expired access token.'
    },
    invalidExpandExpression: {
        code: 618,
        message: 'Invalid expand expression.'
    },
    invalidRequest: {
        code: 601,
        message: 'Invalid request.'
    },
    missingContentType: {
        code: 701,
        message: 'ContentType not specified.'
    },
    missingOrInvalidFileContent: {
        code: 702,
        message: 'Missing or invalid file content.'
    },
    customFileSyncNotSupported: {
        code: 703,
        message: 'Custom ConflictResolution for files is not allowed.'
    },
    cannotDownloadOffline: {
        code: 704,
        message: 'Cannot download a file while offline.'
    },
    cannotForceCacheWhenDisabled: {
        code: 705,
        message: 'Cannot use forceCache while the caching is disabled.'
    },
    filesNotSupportedInBrowser: {
        code: 706,
        message: 'Create and Update operations are not supported for Files in browsers while in offline mode.'
    },
    pushNotSupportedOffline: {
        code: 707,
        message: 'Push is not supported in offline mode.'
    },
    singleValueExpected: {
        code: 710
    }
};

EverliveErrors = _underscore2.default.deepExtend(EverliveErrors, _errors2.default);

var EverliveErrorHelper = {
    buildSingleValueExpectedErrorMessage: function buildSingleValueExpectedErrorMessage(operation) {
        var errorMessage = 'A single value is expected in ' + operation + ' query modifier.';
        return errorMessage;
    }
};

var EverliveError = function () {
    function EverliveError(message, code) {
        var tmpError = Error.apply(this);

        if ((typeof message === 'undefined' ? 'undefined' : _typeof(message)) === 'object') {
            var err = message;
            message = err.message;
            code = err.code;
        }

        tmpError.message = message;
        tmpError.code = code || 0;
        tmpError.name = this.name = 'EverliveError';

        this.message = tmpError.message;
        this.code = code;

        Object.defineProperty(this, 'stack', {
            get: function get() {
                return tmpError.stack;
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            stack: this.stack
        };
    };

    return EverliveError;
}();

var DeviceRegistrationError = function () {
    var DeviceRegistrationError = function DeviceRegistrationError(errorType, message, additionalInformation) {
        var errorCode = additionalInformation ? additionalInformation.code : undefined;
        EverliveError.call(this, message, errorCode);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}();

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    EverliveErrorHelper: EverliveErrorHelper,
    DeviceRegistrationError: DeviceRegistrationError
};

},{"../common/errors":45,"underscore":36}],59:[function(require,module,exports){
'use strict';

var _bsExpandProcessor = require('../scripts/bs-expand-processor');

var _bsExpandProcessor2 = _interopRequireDefault(_bsExpandProcessor);

var _DataQuery = require('../everlive/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _Query = require('../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _AggregateQuery = require('../everlive/query/AggregateQuery');

var _AggregateQuery2 = _interopRequireDefault(_AggregateQuery);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    return new _bsExpandProcessor2.default({
        executionNodeFunction: function executionNodeFunction(node, expandContext, done) {
            var targetTypeName = node.targetTypeName.toLowerCase() === _constants2.default.FilesTypeNameLegacy ? _constants2.default.FilesTypeName : node.targetTypeName;
            var query;
            if (node.aggregate) {
                query = new _DataQuery2.default({
                    operation: _DataQuery2.default.operations.Aggregate,
                    meta: {
                        collectionName: targetTypeName
                    },
                    query: new _AggregateQuery2.default(node.filter, node.select, node.sort, node.skip, node.take, null, node.aggregate)
                });
            } else {
                query = new _DataQuery2.default({
                    operation: _DataQuery2.default.operations.Read,
                    meta: {
                        collectionName: targetTypeName
                    },
                    query: new _Query2.default(node.filter, node.select, node.sort, node.skip, node.take)
                });
            }

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        }
    });
}();

},{"../everlive/constants":70,"../everlive/dataQuery/DataQuery":71,"../everlive/query/AggregateQuery":94,"../everlive/query/Query":96,"../scripts/bs-expand-processor":127}],60:[function(require,module,exports){
"use strict";

module.exports = function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function addOperand(operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}();

},{}],61:[function(require,module,exports){
"use strict";

module.exports = function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}();

},{}],62:[function(require,module,exports){
'use strict';

var _utils = require('../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../everlive/EverliveError');

var _CurrentDevice = require('../everlive/push/CurrentDevice');

var _CurrentDevice2 = _interopRequireDefault(_CurrentDevice);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data(_constants2.default.Push.NotificationsType);
        this.devices = el.data(_constants2.default.Push.DevicesType);
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function ensurePushIsAvailable() {
            _CurrentDevice2.default.ensurePushIsAvailable();
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function currentDevice(emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }

            if (!this._currentDevice) {
                this._currentDevice = new _CurrentDevice2.default(this);
            }

            this._currentDevice.emulatorMode = emulatorMode || _utils2.default._inAppBuilderSimulator();

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function register(settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function successCallback(token, callback) {
                var result = new _utils.DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function errorCallback(err, callback) {
                var registrationError = _EverliveError.DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function clearBadgeIfNeeded(token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType();
                var clearBadge = platformType === _constants.Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return (0, _utils.buildPromise)(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration().then(function () {
                        currentDevice.updateRegistration(customParameters, function () {
                            clearBadgeIfNeeded(token, successCb, errorCb);
                        }, function (err) {
                            errorCallback(err, errorCb);
                        });
                    }, function (err) {
                        if (err.code === 801) {
                            //Not registered
                            currentDevice.register(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, errorCb);
                        } else {
                            errorCallback(err, errorCb);
                        }
                    });
                }, function (err) {
                    var deviceRegistrationError = _EverliveError.DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function unregister(onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function updateRegistration(customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function setBadgeNumber(badge, onSuccess, onError) {
            var self = this;

            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return (0, _utils.buildPromise)(function (success, error) {
                    error(new _EverliveError.EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return (0, _utils.buildPromise)(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(function () {
                    if (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification && !_utils2.default._inAppBuilderSimulator()) {
                        return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                    } else {
                        return successCb();
                    }
                }, errorCb);
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function clearBadgeNumber(onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function getRegistration(onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function send(notification, onSuccess, onError) {
            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function areNotificationsEnabled(options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.areNotificationsEnabled(options, onSuccess, onError);
        },

        /**
         * Currently available only for iOS
         * Use this method in case you are working with iOS interactive push notifications in background mode, including TextInput, or iOS silent push notifications
         * Call it once you are done with processing your push notification in notificationCallbackIOS.
         * @method notificationProcessed
         * @name notificationProcessed
         * @memberOf Push.prototype
         */
        /**
         * Use this method in case you are working with iOS interactive push notifications in background mode, including TextInput, or iOS silent push notifications
         * Call it once you are done with processing your push notification in notificationCallbackIOS.
         * @method notificationProcessed
         * @name notificationProcessed
         * @memberOf Push.prototype
         */
        notificationProcessed: function notificationProcessed() {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            currentDevice.notificationProcessed();
        }
    };

    return Push;
}();

},{"../everlive/EverliveError":58,"../everlive/constants":70,"../everlive/push/CurrentDevice":92,"../everlive/utils":121}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _reqwest = require('../everlive/reqwest.everlive');

var _reqwest2 = _interopRequireDefault(_reqwest);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _everlive = require('../everlive/everlive.platform');

var _Query = require('../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Request = function () {
    Request.sendRequest = function sendRequest(request) {
        var url = request.buildUrl();
        url = _utils2.default.disableRequestCache(url, request.method);
        request.method = request.method || _constants2.default.HttpMethod.GET;
        var data = request.method === _constants2.default.HttpMethod.GET ? request.data : JSON.stringify(request.data);
        request.headers['Accept'] = '*/*'; // Reqwest is case sensitive regarding this header

        var requestParams = {
            url: url,
            method: request.method,
            data: data,
            headers: request.headers,
            contentType: 'application/json'
        };

        if (!_everlive.isNodejs) {
            requestParams.crossOrigin = true;
        }

        return new _rsvp2.default.Promise(function (resolve, reject) {
            return (0, _reqwest2.default)(requestParams).then(function (res) {
                resolve(res);
            }, function (err) {
                reject(err);
            });
        });
    };

    function Request(setup, options) {
        _classCallCheck(this, Request);

        (0, _utils.guardUnset)(setup, 'setup');
        (0, _utils.guardUnset)(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;

        this._headers = {};

        _underscore2.default.extend(this, options);
        this._init(options);
    }

    //make sure that the headers are always normalized


    // Calls the underlying Ajax library
    // If there is a logged in user for the Everlive instance then her/his authentication will be used.
    Request.prototype.buildAuthHeader = function buildAuthHeader() {
        return _utils.buildAuthHeader.apply(undefined, arguments);
    };

    Request.prototype.send = function send() {
        return Request.sendRequest(this);
    };

    // Builds the URL of the target Everlive service


    Request.prototype.buildUrl = function buildUrl() {
        var url = _utils2.default.buildUrl(this.setup) + this.endpoint;

        if (_underscore2.default.size(this.queryStringParams)) {
            url = url + '?' + _utils2.default.toQueryString(this.queryStringParams);
        }

        return url;
    };

    // Processes the given query to return appropriate headers to be used by the request


    Request.prototype.buildQueryHeaders = function buildQueryHeaders(query) {
        if (query) {
            if (query instanceof _Query2.default) {
                return Request.prototype._buildQueryHeaders(query);
            } else {
                return Request.prototype._buildFilterHeader(query.filter);
            }
        } else {
            return {};
        }
    };

    // Initialize the Request object by using the passed options


    Request.prototype._init = function _init(options) {
        _underscore2.default.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.query));
        this.encodeHeaders();
    };

    // Translates an Everlive.Query to request headers


    Request.prototype._buildQueryHeaders = function _buildQueryHeaders(query) {
        query = query.build();
        var headers = {};
        if (query.$where !== null) {
            headers[_constants.Headers.filter] = JSON.stringify(query.$where);
        }
        if (query.$select !== null) {
            headers[_constants.Headers.select] = JSON.stringify(query.$select);
        }
        if (query.$sort !== null) {
            headers[_constants.Headers.sort] = JSON.stringify(query.$sort);
        }
        if (query.$skip !== null) {
            headers[_constants.Headers.skip] = query.$skip;
        }
        if (query.$take !== null) {
            headers[_constants.Headers.take] = query.$take;
        }
        if (query.$expand !== null) {
            headers[_constants.Headers.expand] = JSON.stringify(query.$expand);
        }
        if (query.$aggregate !== null) {
            headers[_constants.Headers.aggregate] = JSON.stringify(query.$aggregate);
        }

        return headers;
    };

    Request.prototype._buildFilterHeader = function _buildFilterHeader(filter) {
        var headers = {};
        headers[_constants.Headers.filter] = JSON.stringify(filter);
        return headers;
    };

    Request.prototype.encodeHeaders = function encodeHeaders() {
        var headers = this.headers;
        _underscore2.default.each(_constants.EncodableHeaders, function (headerName) {
            if (headers[headerName] !== undefined) {
                headers[headerName] = encodeURIComponent(headers[headerName]);
            }
        });
    };

    _createClass(Request, [{
        key: 'headers',
        get: function get() {
            return this._headers;
        },
        set: function set(val) {
            // If we let two identical headers with different casing slip into a request
            // the browser concatenates them which brings chaos to earth
            this._headers = _utils2.default.normalizeKeys(val);
        }
    }]);

    return Request;
}();

Request.reviver = _utils.parseUtilities.getReviver();
Request.parsers = {
    simple: {
        result: _utils.parseUtilities.parseResult.bind(null, Request.reviver),
        error: _utils.parseUtilities.parseXhrError.bind(null, Request.reviver)
    },
    single: {
        result: _utils.parseUtilities.parseSingleResult.bind(null, Request.reviver),
        error: _utils.parseUtilities.parseXhrError.bind(null, Request.reviver)
    },
    update: {
        result: _utils.parseUtilities.parseUpdateResult.bind(null, Request.reviver),
        error: _utils.parseUtilities.parseXhrError.bind(null, Request.reviver)
    },
    customRequest: {
        result: _underscore2.default.identity,
        error: _utils.parseUtilities.parseXhrResponse
    }
};
exports.default = Request;

},{"../everlive/constants":70,"../everlive/everlive.platform":74,"../everlive/query/Query":96,"../everlive/reqwest.everlive":100,"../everlive/utils":121,"rsvp":35,"underscore":36}],64:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _AuthenticationSetup = require('../everlive/auth/AuthenticationSetup');

var _AuthenticationSetup2 = _interopRequireDefault(_AuthenticationSetup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    var everliveUrl = _constants2.default.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.appId = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.principalId = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;

        if (typeof options === 'string') {
            this.appId = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _underscore2.default.extend(this, options);
            if (options.apiKey) {
                this.appId = options.apiKey; // backward compatibility
            }
        }

        this.apiKey = this.appId;

        this.authentication = new _AuthenticationSetup2.default(this, options.authentication);
    }

    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
        this.token = token;
        this.tokenType = tokenType;
        this.principalId = principalId;
    };

    Setup.prototype.getAuthorizationProperties = function () {
        return {
            token: this.token,
            tokenType: this.tokenType,
            principalId: this.principalId
        };
    };

    return Setup;
}();

},{"../everlive/auth/AuthenticationSetup":66,"../everlive/constants":70,"underscore":36}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _Everlive = require('../../everlive/Everlive');

var _Everlive2 = _interopRequireDefault(_Everlive);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _LocalStore = require('../../everlive/storages/LocalStore');

var _LocalStore2 = _interopRequireDefault(_LocalStore);

var _EverliveError = require('../../everlive/EverliveError');

var _Data2 = require('../../everlive/types/Data');

var _Data3 = _interopRequireDefault(_Data2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Authentication = function (_Data) {
    _inherits(Authentication, _Data);

    /**
     * @class Authentication
     * @classdesc A class for managing authentication of a user in your application.
     * @protected
     * @param sdk {Everlive} Everlive Object
     */
    function Authentication(sdk) {
        _classCallCheck(this, Authentication);

        var _this = _possibleConstructorReturn(this, _Data.call(this, sdk, 'Users'));

        _this.authSetup = sdk.setup.authentication || {};
        _this._authenticationCallbacks = null;
        if (_this.authSetup.persist) {
            _this._localStore = new _LocalStore2.default(sdk);
            var localStoreKey = _this._getLocalStoreKey();
            var authOptions = _this._localStore.getItem(localStoreKey);
            var authInfo = void 0;
            if (authOptions) {
                authInfo = JSON.parse(_this._localStore.getItem(localStoreKey));
            }
            if (authInfo) {
                _this.sdk.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
            }
        }
        return _this;
    }

    Authentication.prototype._getLocalStoreKey = function _getLocalStoreKey() {
        return _constants2.default.AuthStoreKey + this.sdk.setup.apiKey + '$authentication';
    };

    /** Ensures that authentication is completed before continuing.
     * @memberOf Authentication.prototype
     * @private
     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
     * @throws throws an error if no onAuthenticationRequired handler is provided to the setup.
     */


    Authentication.prototype._ensureAuthentication = function _ensureAuthentication() {
        if (!this.isAuthenticationInProgress()) {
            throw new Error('onAuthenticationRequired option of Everlive.Setup.Authentication is required.');
        }
        if (this.isAuthenticating()) {
            return this._authenticationCallbacks.promise;
        }

        this.clearAuthorization();
        this.authSetup.onAuthenticationRequired.call(this);
        this._authenticationCallbacks = _utils2.default.getCallbacks();
        return this._authenticationCallbacks.promise;
    };

    Authentication.prototype._loginSuccess = function _loginSuccess(data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
    };

    Authentication.prototype._logoutSuccess = function _logoutSuccess() {
        this.clearAuthorization();
    };

    Authentication.prototype._loginWithProvider = function _loginWithProvider(identity, success, error) {
        var _this2 = this;

        var user = {
            Identity: identity
        };

        var dataQuery = this.buildDataQuery(user, _constants.DataQueryOperations.UserLoginWithProvider);
        return (0, _utils.buildPromise)(function (success, error) {
            return _this2.processDataQuery(dataQuery).then(function () {
                _this2._loginSuccess.apply(_this2, arguments);
                return success.apply(undefined, arguments);
            }).catch(error);
        }, success, error);
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.login = function login(username, password, success, error) {
        var _this3 = this;

        var grant_type = 'password';
        var data = { grant_type: grant_type, username: username, password: password };
        var dataQuery = this.buildDataQuery(data, _constants.DataQueryOperations.UserLogin);
        return (0, _utils.buildPromise)(function (success, error) {
            return _this3.processDataQuery(dataQuery).then(function () {
                _this3._loginSuccess.apply(_this3, arguments);
                return success.apply(undefined, arguments);
            }).catch(error);
        }, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.logout = function logout(success, error) {
        var _this4 = this;

        var dataQuery = this.buildDataQuery(null, _constants.DataQueryOperations.UserLogout);
        return (0, _utils.buildPromise)(function (success, error) {
            return _this4.processDataQuery(dataQuery).then(function () {
                _this4._logoutSuccess.apply(_this4, arguments);
                return success.apply(undefined, arguments);
            }).catch(function (err) {
                if (err.code === 301) {
                    //invalid token
                    _this4.clearAuthorization();
                }

                return error(err);
            });
        }, success, error);
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.loginWithFacebook = function loginWithFacebook(accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.loginWithADFS = function loginWithADFS(accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.loginWithLiveID = function loginWithLiveID(accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.loginWithGoogle = function loginWithGoogle(accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.loginWithTwitter = function loginWithTwitter(token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Authentication.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */


    Authentication.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this.sdk.setup.setAuthorizationProperties(token, tokenType, principalId);

        if (this.authSetup.persist) {
            var localStoreKey = this._getLocalStoreKey();
            var authorizationProperties = this.sdk.setup.getAuthorizationProperties();
            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
        }

        if (this._authenticationCallbacks) {
            this._authenticationCallbacks.success();
            this._authenticationCallbacks = null;
        }
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
     * @method clearAuthorization
     * @memberOf Authentication.prototype
     */


    Authentication.prototype.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null, null);
        this.clearPersistedAuthentication();
    };

    /**
     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
     * @method clearPersistedAuthentication
     * @memberOf Authentication.prototype
     */


    Authentication.prototype.clearPersistedAuthentication = function clearPersistedAuthentication() {
        if (this._localStore) {
            var localStoreKey = this._getLocalStoreKey();
            this._localStore.removeItem(localStoreKey);
            this.sdk.setup.setAuthorizationProperties(null, null, null);
        }
    };

    /**
     * @memberOf Authentication.prototype
     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
     * @returns {boolean} whether an onAuthenticationRequired function is provided
     */


    Authentication.prototype.isAuthenticationInProgress = function isAuthenticationInProgress() {
        return typeof this.authSetup.onAuthenticationRequired === 'function';
    };

    /**
     * A method that should be called with the authentication result.
     * @memberOf Authentication.prototype
     * @param authentication authentication object containing information about the
     * @param authentication.access_token
     * @param authentication.token_type
     * @param authentication.principal_id
     */


    Authentication.prototype.completeAuthentication = function completeAuthentication(authentication) {
        this.sdk.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
    };

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Authentication.prototype.getAuthenticationStatus = function getAuthenticationStatus(success, error) {
        var _this5 = this;

        return _utils2.default.buildPromise(function (success, error) {
            var setup = _this5.sdk.setup;
            if (setup.masterKey) {
                return success({ status: _constants2.default.AuthStatus.masterKey });
            }

            if (!setup.token) {
                return success({ status: _constants2.default.AuthStatus.unauthenticated });
            }

            if (_this5.isAuthenticationInProgress()) {
                return success({ status: _constants2.default.AuthStatus.authenticating });
            }

            return _this5.sdk.users.skipAuth(true).currentUser().then(function (res) {
                return success({ status: _constants2.default.AuthStatus.authenticated, user: res.result });
            }, function (err) {
                if (_this5.isAuthenticationInProgress()) {
                    return success({ status: _constants2.default.AuthStatus.authenticating });
                } else if (err.code === _EverliveError.EverliveErrors.invalidRequest.code || err.code === _EverliveError.EverliveErrors.invalidToken.code) {
                    // invalid request, i.e. the access token is invalid or missing
                    return success({ status: _constants2.default.AuthStatus.invalidAuthentication });
                } else if (err.code === _EverliveError.EverliveErrors.expiredToken.code) {
                    return success({ status: _constants2.default.AuthStatus.expiredAuthentication });
                } else {
                    return error(err);
                }
            });
        }, success, error);
    };

    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
     * @memberOf Everlive.prototype
     * @returns {boolean}
     */


    Authentication.prototype.isAuthenticating = function isAuthenticating() {
        return !!this._authenticationCallbacks;
    };

    return Authentication;
}(_Data3.default);

exports.default = Authentication;

},{"../../everlive/Everlive":57,"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/storages/LocalStore":107,"../../everlive/types/Data":110,"../../everlive/utils":121}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AuthenticationSetup = function AuthenticationSetup(everlive) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, AuthenticationSetup);

    this.onAuthenticationRequired = options.onAuthenticationRequired;
    this.persist = options.persist;
    this.everlive = everlive;
};

exports.default = AuthenticationSetup;

},{}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../../everlive/EverliveError');

var _Data2 = require('../../everlive/types/Data');

var _Data3 = _interopRequireDefault(_Data2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BusinessLogic = function (_Data) {
    _inherits(BusinessLogic, _Data);

    BusinessLogic._isValidFuncName = function _isValidFuncName(name) {
        return _underscore2.default.isString(name) && name !== '';
    };

    /**
     * @class BusinessLogic
     * @classdesc A class for invoking your app's Business Logic such as Cloud Functions and Stored Procedures.
     * @protected
     * @param sdk {Everlive} The sdk instance
     * @param setup {Object} Everlive setup object.
     */


    function BusinessLogic(sdk) {
        _classCallCheck(this, BusinessLogic);

        return _possibleConstructorReturn(this, _Data.call(this, sdk, 'BusinessLogic'));
    }

    BusinessLogic.prototype._invokeFunction = function _invokeFunction(params, operation) {
        var customParameters = params.customParameters;
        var method = params.method;
        var endpoint = params.endpoint;
        var success = params.success;
        var error = params.error;


        var additionalOptions = _underscore2.default.extend({
            customParameters: customParameters,
            method: method,
            endpoint: endpoint,
            authHeaders: true,
            isCustomRequest: true
        }, params);
        var dataQuery = this.buildDataQuery({ additionalOptions: additionalOptions }, operation);
        return this.processDataQuery(dataQuery, success, error);
    };

    /**
     * Invokes a Cloud Function from the app's Business Logic layer.
     * @method invokeCloudFunction
     * @memberOf BusinessLogic.prototype
     * @param {String} funcName The name of the function to invoke.
     * @param {Object} params An object containing all invocation request parameters.
     * @param {HttpMethod} [params.method=GET] HTTP request method.
     * @param {Object} [params.queryStringParams] Parameters to be passed in the query string.
     * @param {Object} [params.data] Data to be sent with the request.
     * @param {Boolean} [params.authHeaders=true] Whether to send the credentials of the currently logged-in user.
     * @param {Object} [params.headers] Additional headers to be sent with the request.
     * @param {Object} [params.customParameters] Custom parameters to be sent with the request. They will be accessible in the Cloud Function code.
     * @returns {Promise} A promise resolved on successful response and rejected on error response.
     */
    /**
     * Invokes a Cloud Function from the app's Business Logic layer.
     * @method invokeCloudFunction
     * @memberOf BusinessLogic.prototype
     * @param {String} funcName The name of the function to invoke.
     * @param {Object} params An object containing all invocation request parameters.
     * @param {HttpMethod} [params.method=GET] HTTP request method.
     * @param {Object} [params.queryStringParams] Parameters to be passed in the query string.
     * @param {Object} [params.data] Data to be sent with the request.
     * @param {Boolean} [params.authHeaders=true] Whether to send the credentials of the currently logged-in user.
     * @param {Object} [params.headers] Additional headers to be sent with the request.
     * @param {Object} [params.customParameters] Custom parameters to be sent with the request. They will be accessible in the Cloud Function code.
     * @param {Function} success Success callback function.
     * @param {Function} error Error callback function.
     */


    BusinessLogic.prototype.invokeCloudFunction = function invokeCloudFunction(funcName, params, success, error) {
        if (!BusinessLogic._isValidFuncName(funcName)) {
            var err = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.invalidOrMissingFunctionName);
            return _utils2.default.callbackAndPromiseErrorResponse(err, error);
        }

        params = _underscore2.default.extend({
            method: _constants2.default.HttpMethod.GET,
            success: success,
            error: error
        }, params);

        if (params.method.toUpperCase() === _constants2.default.HttpMethod.GET && _underscore2.default.size(params.data)) {
            var _err = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.bodyWithGetRequestNotSupported);
            return _utils2.default.callbackAndPromiseErrorResponse(_err, error);
        }

        params.endpoint = _path2.default.join(_constants2.default.cloudFuncsEndpoint, funcName);
        return this._invokeFunction(params, _constants.DataQueryOperations.InvokeCloudFunction);
    };

    /**
     * Invokes a Stored Procedure from the app's Business Logic layer.
     * @method invokeStoredProcedure
     * @memberOf BusinessLogic.prototype
     * @param {String} funcName The name of the Stored Procedure to invoke.
     * @param {Object} funcParams Parameters to be passed to the Stored Procedure.
     * @returns {Promise} A promise resolved on successful response and rejected on error response.
     */
    /**
     * Invokes a Stored Procedure from the app's Business Logic layer.
     * @method invokeStoredProcedure
     * @memberOf BusinessLogic.prototype
     * @param {String} funcName The name of the stored procedure to invoke.
     * @param {Object} funcParams Parameters to be passed to the Stored Procedure.
     * @param {Function} success Success callback function.
     * @param {Function} error Error callback function.
     */


    BusinessLogic.prototype.invokeStoredProcedure = function invokeStoredProcedure(funcName, funcParams, success, error) {
        if (!BusinessLogic._isValidFuncName(funcName)) {
            var err = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.invalidOrMissingProcedureName);
            return _utils2.default.callbackAndPromiseErrorResponse(err, error);
        }

        var reqParams = {
            method: _constants2.default.HttpMethod.POST,
            endpoint: _path2.default.join(_constants2.default.sqlProceduresEndpoint, funcName),
            data: funcParams || {},
            success: success,
            error: error
        };

        return this._invokeFunction(reqParams, _constants.DataQueryOperations.InvokeStoredProcedure);
    };

    return BusinessLogic;
}(_Data3.default);

exports.default = BusinessLogic;

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/types/Data":110,"../../everlive/utils":121,"path":4,"underscore":36}],68:[function(require,module,exports){
'use strict';

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _jsonStableStringify = require('json-stable-stringify');

var _jsonStableStringify2 = _interopRequireDefault(_jsonStableStringify);

var _RequestService = require('../../everlive/services/RequestService');

var _offlinePersisters = require('../../everlive/offline/offlinePersisters');

var _offlinePersisters2 = _interopRequireDefault(_offlinePersisters);

var _offline = require('../../everlive/offline/offline');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CacheModule = function CacheModule(options, everlive) {
    this.options = options;
    this.typeSettings = this.options.typeSettings;
    this.maxAgeInMs = this.options.maxAge * 60 * 1000;
    this._everlive = everlive;
};

var cacheableOperations = [_constants.DataQueryOperations.Read, _constants.DataQueryOperations.ReadById, _constants.DataQueryOperations.Count];

/**
 * @class CacheModule
 * @classDesc A class providing access to the various caching features.
 */

/**
 * Represents the {@link CacheModule} class.
 * @memberOf Everlive.prototype
 * @member {CacheModule} cache
 */
CacheModule.prototype = {
    _hash: function _hash(obj) {
        return (0, _jsonStableStringify2.default)(obj);
    },

    // using the offline storage options to initialize the same type of storage
    _initStore: function _initStore(sdkOptions) {
        if (!this.persister) {
            var offlineStorageOptions = (0, _offline.buildOfflineStorageOptions)(sdkOptions);
            var storageKey = this.options.storage.storagePath + '_' + sdkOptions.apiKey;

            this.persister = _offlinePersisters2.default.getPersister(storageKey, offlineStorageOptions);
        }
    },

    _getCacheData: function _getCacheData() {
        var self = this;

        if (!this.cacheData) {
            return this._persisterGetAllDataWrap().then(function (cacheData) {
                self.cacheData = cacheData;
                return self.cacheData;
            });
        }

        return _utils2.default.successfulPromise(this.cacheData);
    },

    _persisterGetAllDataWrap: function _persisterGetAllDataWrap() {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            return self.persister.getAllData(resolve, reject);
        });
    },

    _persisterSaveDataWrap: function _persisterSaveDataWrap(contentType, data) {
        var self = this;
        return new _rsvp2.default.Promise(function (resolve, reject) {
            return self.persister.saveData(contentType, JSON.stringify(data), resolve, reject);
        });
    },

    _getCacheDataForContentType: function _getCacheDataForContentType(contentType) {
        return this._getCacheData().then(function (cacheData) {
            if (typeof cacheData[contentType] === 'string') {
                cacheData[contentType] = JSON.parse(cacheData[contentType]);
            } else {
                cacheData[contentType] = cacheData[contentType] || {};
            }

            return _underscore2.default.clone(cacheData[contentType]);
        });
    },

    _persistCacheData: function _persistCacheData(contentType, cacheData) {
        var self = this;

        return this._getCacheDataForContentType(contentType).then(function () {
            var dataToCache = _underscore2.default.extend({}, self.cacheData[contentType], cacheData);
            self.cacheData[contentType] = _underscore2.default.compactObject(dataToCache);
            return self._persisterSaveDataWrap(contentType, self.cacheData[contentType]);
        });
    },

    isQueryUnsupportedOffline: function isQueryUnsupportedOffline(dataQuery) {
        var hasPowerfieldsExpression = !!dataQuery.getHeader(_constants2.default.Headers.powerFields);
        var queryParams = dataQuery.getQueryParameters();
        var dataQueryFilter = queryParams.filter;
        var unsupportedDbOperators = _utils2.default.getUnsupportedOperators(dataQueryFilter);
        var hasUnsupportedOperators = unsupportedDbOperators.length !== 0;
        return hasPowerfieldsExpression || hasUnsupportedOperators;
    },

    _shouldSkipCache: function _shouldSkipCache(dataQuery) {
        var operationShouldSkipCache = cacheableOperations.indexOf(dataQuery.operation) === -1;
        var collectionName = dataQuery.collectionName;
        var typeSettings = this.typeSettings;
        var cacheDisabledForContentType = typeSettings && typeSettings && typeSettings[collectionName] && typeSettings[collectionName].enabled === false;
        var ignoreCacheForQuery = dataQuery.ignoreCache;

        var isUnsupportedOffline = this.isQueryUnsupportedOffline(dataQuery);
        var isForCurrentUser = dataQuery.additionalOptions && dataQuery.additionalOptions.id === 'me';

        return operationShouldSkipCache || cacheDisabledForContentType || isForCurrentUser || ignoreCacheForQuery || isUnsupportedOffline;
    },

    _processCacheItem: function _processCacheItem(dataQuery, data) {
        var self = this;

        var contentType = dataQuery.collectionName;
        var hash = this._getHashForQuery(dataQuery);

        return self._getCacheDataForContentType(contentType).then(function (cacheData) {
            if (cacheData[hash]) {
                return self._isHashExpired(contentType, hash, dataQuery.maxAge).then(function (isExpired) {
                    if (isExpired && !dataQuery.forceCache) {
                        return self._purgeForHash(contentType, hash).then(function () {
                            return self._cacheQuery(dataQuery, hash, data);
                        });
                    } else {
                        //If cache is used, change 'me' to the ID of the logged in user (only for currentUser() requests).
                        if (dataQuery.operation === _constants.DataQueryOperations.ReadById && dataQuery.additionalOptions.id === 'me') {
                            dataQuery.additionalOptions.id = self._everlive.setup.principalId;
                        }

                        return self._everlive.offlineStorage.processQuery(dataQuery);
                    }
                });
            } else {
                return self._cacheQuery(dataQuery, hash, data);
            }
        });
    },

    _addObjectToCache: function _addObjectToCache(obj, contentType, maxAge) {
        var itemHash = obj.Id;
        return this._cacheResultFromDataQuery(contentType, itemHash, maxAge);
    },

    _cacheQuery: function _cacheQuery(dataQuery, hash, data) {
        var self = this;
        var contentType = dataQuery.collectionName;

        var promise = new _rsvp2.default.Promise(function (resolve, reject) {
            var result = void 0;
            return _RequestService.RequestService.handleRequestProcessing(dataQuery, data).then(function (response) {
                result = response.result || response;
                return self._getCacheData();
            }).then(function success() {
                var cacheForItems = [];
                var resultToCache = result.Result || result;
                if (dataQuery.operation !== _constants.DataQueryOperations.Count) {
                    if (Array.isArray(resultToCache)) {
                        _underscore2.default.each(resultToCache, function (singleResult) {
                            var cacheItemPromise = self._addObjectToCache(singleResult, contentType);
                            cacheForItems.push(cacheItemPromise);
                        });
                    } else if (_underscore2.default.isObject(resultToCache)) {
                        var cacheItemPromise = self._addObjectToCache(resultToCache, contentType);
                        cacheForItems.push(cacheItemPromise);
                    }
                }

                return _rsvp2.default.all(cacheForItems);
            }).then(function success() {
                if (dataQuery.operation !== _constants.DataQueryOperations.Count) {
                    return self._cacheResultFromDataQuery(contentType, hash);
                }
            }).then(function success() {
                resolve(result);
            }).catch(function (err) {
                reject(err);
            });
        });

        return promise;
    },

    _cacheResultFromDataQuery: function _cacheResultFromDataQuery(contentType, hash) {
        var cacheData = {};
        cacheData[hash] = {
            cachedAt: Date.now()
        };

        return this._persistCacheData(contentType, cacheData);
    },

    _getExpirationForHash: function _getExpirationForHash(contentType, hash) {
        return this._getCacheDataForContentType(contentType).then(function (cacheData) {
            return cacheData[hash].cachedAt;
        });
    },

    _isHashExpired: function _isHashExpired(contentType, hash, maxAge) {
        var self = this;

        return this._getExpirationForHash(contentType, hash).then(function (cachedAt) {
            var maxAgeForContentType = self.typeSettings && self.typeSettings[contentType] ? self.typeSettings[contentType].maxAge * 60 * 1000 : null;
            var cacheAge;
            if (maxAge || maxAge === 0) {
                cacheAge = maxAge;
            } else if (maxAgeForContentType || maxAgeForContentType === 0) {
                cacheAge = maxAgeForContentType;
            } else {
                cacheAge = self.maxAgeInMs;
            }
            return cachedAt + cacheAge < Date.now();
        });
    },

    _purgeForHash: function _purgeForHash(contentType, hash) {
        var cacheData = {};
        cacheData[hash] = null;

        return this._persistCacheData(contentType, cacheData);
    },

    _getHashForQuery: function _getHashForQuery(dataQuery) {
        if (dataQuery.operation === _constants.DataQueryOperations.ReadById) {
            return dataQuery.additionalOptions.id;
        }

        var queryParams = dataQuery.getQueryParameters();
        return this._hash(queryParams);
    },

    /**
     * Clears the cached data for a specified content type.
     * @method clear
     * @name clear
     * @param {string} contentType The content type to clear.
     * @memberOf CacheModule.prototype
     * @returns {Promise}
     */
    /**
     * Clears the cached data for a specified content type.
     * @method clear
     * @name clear
     * @param {string} contentType The content type to clear.
     * @memberOf CacheModule.prototype
     * @param {function} [success] A success callback.
     * @param {function} [error] An error callback.
     */
    clear: function clear(contentType, success, error) {
        var self = this;

        return (0, _utils.buildPromise)(function (success, error) {
            return self.persister.purge(contentType, function () {
                delete self.cacheData[contentType];
                if (self._everlive.offlineStorage.setup.enabled) {
                    success();
                } else {
                    self._everlive.offlineStorage._queryProcessor._persister.purge(contentType, success, error);
                }
            }, error);
        }, success, error);
    },

    /**
     * Clears all data from the cache.
     * @method clearAll
     * @name clearAll
     * @memberOf CacheModule.prototype
     * @returns {Promise}
     */
    /**
     * Clears all data from the cache.
     * @method clearAll
     * @name clearAll
     * @memberOf CacheModule.prototype
     * @param {function} [success] A success callback.
     * @param {function} [error] An error callback.
     */
    clearAll: function clearAll(success, error) {
        var self = this;
        self.cacheData = null;

        return (0, _utils.buildPromise)(function (success, error) {
            return self.persister.purgeAll(function () {
                if (self._everlive.offlineStorage.setup.enabled) {
                    success();
                } else {
                    self._everlive.offlineStorage._queryProcessor._persister.purgeAll(success, error);
                }
            }, error);
        }, success, error);
    }
};

module.exports = CacheModule;

},{"../../everlive/constants":70,"../../everlive/offline/offline":85,"../../everlive/offline/offlinePersisters":86,"../../everlive/services/RequestService":105,"../../everlive/utils":121,"json-stable-stringify":8,"rsvp":35,"underscore":36}],69:[function(require,module,exports){
'use strict';

var _CacheModule = require('../../everlive/caching/CacheModule');

var _CacheModule2 = _interopRequireDefault(_CacheModule);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getDefaultOptions = function getDefaultOptions() {
    return {
        maxAge: 60,
        enabled: false,
        storage: {
            storagePath: 'el_cache'
        }
    };
};

module.exports = {
    initCaching: function initCaching(options) {
        var cachingOptions;
        var defaultOptions = getDefaultOptions();
        if (options.caching === true) {
            cachingOptions = _underscore2.default.deepExtend({}, defaultOptions);
            cachingOptions.enabled = true;
        } else {
            cachingOptions = _underscore2.default.deepExtend(defaultOptions, options.caching);
        }

        if (options.caching !== false) {
            this.setup.caching = cachingOptions;
        }

        this.cache = new _CacheModule2.default(cachingOptions, this);
    },
    _initStore: function _initStore(options) {
        this.cache._initStore(options);
    }
};

},{"../../everlive/caching/CacheModule":68,"underscore":36}],70:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _constants = require('../common/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Constants used by the SDK* @typedef {Object} Everlive.Constants
 */

var constants = {
    idField: 'Id',
    guidEmpty: '00000000-0000-0000-0000-000000000000',
    cloudFuncsEndpoint: 'Functions',
    sqlProceduresEndpoint: 'Invoke/SqlProcedures',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom',
        Skip: 'skip'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.StorageProvider
     */
    StorageProvider: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },

    DefaultStoragePath: 'el_store',

    // the default location for storing files offline
    DefaultFilesStoragePath: 'el_file_store',

    // the default location for storing offline to online location map
    DefaultFilesMetadataPath: 'el_file_mapping',

    EncryptionProvider: {
        Default: 'default',
        Custom: 'custom'
    },

    // The headers used by the Everlive services
    Headers: {
        ContentType: 'content-type',

        filter: 'x-everlive-filter',
        select: 'x-everlive-fields',
        sort: 'x-everlive-sort',
        skip: 'x-everlive-skip',
        take: 'x-everlive-take',
        expand: 'x-everlive-expand',
        singleField: 'x-everlive-single-field',
        includeCount: 'x-everlive-include-count',
        powerFields: 'x-everlive-power-fields',
        debug: 'x-everlive-debug',
        overrideSystemFields: 'x-everlive-override-system-fields',
        sdk: 'x-everlive-sdk',
        sync: 'x-everlive-sync',
        aggregate: 'x-everlive-aggregate',
        customParameters: 'x-everlive-custom-parameters'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @property {string} expiredAuthentication Indicates that a user's authentication has expired and that the user must log back in.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated',
        expiredAuthentication: 'expiredAuthentication',
        authenticating: 'authenticating'
    },
    offlineItemStates: {
        created: 'create',
        modified: 'update',
        deleted: 'delete'
    },

    /**
     * HTTP Methods
     * @typedef {string} constants.HttpMethod
     * @property {string} GET
     * @property {string} POST
     * @property {string} PUT
     * @property {string} DELETE
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

constants.SyncErrors = {
    generalError: 'generalError',
    itemSyncError: 'itemSyncError'
};

constants.syncBatchSize = 10;

constants.AuthStoreKey = '__everlive_auth_key';

constants.CachingStoreKey = '__everlive_cache';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes
constants.fileUploadKey = 'fileUpload';
constants.fileUploadDelimiter = '_';

constants.FilesTypeNameLegacy = 'system.files';
constants.FilesTypeName = 'Files';

constants.MaxConcurrentDownloadTasks = 3;

constants.DefaultFilesystemStorageQuota = 10485760;
constants.Events = {
    SyncStart: 'syncStart',
    SyncEnd: 'syncEnd',
    Processed: 'processed',
    ItemProcessed: 'itemProcessed',
    BeforeExecute: 'beforeExecute'
};

constants.DataQueryOperations = {
    Read: 'read',
    Create: 'create',
    Update: 'update',
    Delete: 'destroy',
    DeleteById: 'destroySingle',
    ReadById: 'readById',
    Count: 'count',
    RawUpdate: 'rawUpdate',
    SetAcl: 'setAcl',
    SetOwner: 'setOwner',
    UpdateById: 'updateSingle', // used only by the event query
    UserLogin: 'login',
    UserLogout: 'logout',
    UserChangePassword: 'changePassword',
    UserLoginWithProvider: 'loginWith',
    UserLinkWithProvider: 'linkWith',
    UserUnlinkFromProvider: 'unlinkFrom',
    UserResetPassword: 'resetPassword',
    UserSetPassword: 'setPassword',
    FilesUpdateContent: 'updateContent',
    FilesGetDownloadUrlById: 'downloadUrlById',
    Aggregate: 'aggregate',
    InvokeCloudFunction: 'invokeCloudFunction',
    InvokeStoredProcedure: 'invokeStoredProcedure'
};

constants.Aggregation = {
    MaxDocumentsCount: 100000
};

constants.Push = {
    NotificationsType: 'Push/Notifications',
    DevicesType: 'Push/Devices'
};

constants.EncodableHeaders = [constants.Headers.filter, constants.Headers.expand, constants.Headers.powerFields, constants.Headers.customParameters];

_underscore2.default.deepExtend(constants, _constants2.default);

module.exports = constants;

},{"../common/constants":40,"underscore":36}],71:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _constants = require('../../everlive/constants');

var _Query = require('../../common/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _DataQuery = require('../../common/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _platform = require('../../common/platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataQuery = function (_CommonDataQuery) {
    _inherits(DataQuery, _CommonDataQuery);

    function DataQuery(config) {
        _classCallCheck(this, DataQuery);

        var _this = _possibleConstructorReturn(this, _CommonDataQuery.call(this, config));

        _this.headers = config.headers || {};
        _this.useOffline = config.useOffline;
        _this.applyOffline = config.applyOffline;
        _this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
        _this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
        _this._normalizedHeaders = null;
        _this.isSync = config.isSync;

        // TODO remove when the offline module is ready
        var meta = config.meta || config.config.meta || {};
        if (meta.collectionName) {
            _this.collectionName = meta.collectionName;
        }
        return _this;
    }

    DataQuery.prototype._normalizeHeaders = function _normalizeHeaders() {
        this._normalizedHeaders = _utils2.default.normalizeKeys(this.headers);
    };

    DataQuery.prototype.getHeader = function getHeader(header) {
        this._normalizeHeaders();
        var normalizedHeader = header.toLowerCase();
        return this._normalizedHeaders[normalizedHeader];
    };

    DataQuery.prototype.getHeaders = function getHeaders() {
        this._normalizeHeaders();
        var headers = _underscore2.default.deepExtend(this._normalizedHeaders);
        return headers;
    };

    DataQuery.prototype.getHeaderAsJSON = function getHeaderAsJSON(header) {
        this._normalizeHeaders();

        var headerValue;
        if (header) {
            headerValue = this._normalizedHeaders[header.toLowerCase()];
        }

        if (_underscore2.default.isObject(headerValue)) {
            return headerValue;
        }
        if (_underscore2.default.isString(headerValue)) {
            try {
                return JSON.parse(headerValue);
            } catch (e) {
                return headerValue;
            }
        } else {
            return headerValue;
        }
    };

    DataQuery.prototype.getQueryParameters = function getQueryParameters() {
        var queryParams = {};

        if (this.operation === DataQuery.operations.ReadById) {
            queryParams.expand = this.getHeaderAsJSON(_constants.Headers.expand);
            queryParams.select = this.getHeaderAsJSON(_constants.Headers.select);
        } else if (!this.additionalOptions || this.additionalOptions.id === undefined) {
            var sort = this.getHeaderAsJSON(_constants.Headers.sort);
            var limit = this.getHeaderAsJSON(_constants.Headers.take);
            var skip = this.getHeaderAsJSON(_constants.Headers.skip);
            var select = this.getHeaderAsJSON(_constants.Headers.select);
            var filter = this.getHeaderAsJSON(_constants.Headers.filter);
            var expand = this.getHeaderAsJSON(_constants.Headers.expand);
            var aggregate = this.getHeaderAsJSON(_constants.Headers.aggregate);

            if (this.query instanceof _Query2.default) {
                var filterObj = this.query.build();
                queryParams.filter = filterObj.$where || filter || {};
                queryParams.sort = filterObj.$sort || sort;
                queryParams.limit = filterObj.$take || limit;
                queryParams.skip = filterObj.$skip || skip;
                queryParams.select = filterObj.$select || select;
                queryParams.expand = filterObj.$expand || expand;
                queryParams.aggregate = filterObj.$aggregate || aggregate;
            } else {
                // TODO left for backward compatibility, should be removed later
                queryParams.filter = this.filter || filter || this.config.filter || {};
                queryParams.sort = sort;
                queryParams.limit = limit;
                queryParams.skip = skip;
                queryParams.select = select;
                queryParams.expand = expand;
                queryParams.aggregate = aggregate;
            }
        }

        return queryParams;
    };

    DataQuery.prototype.applyEventQuery = function applyEventQuery(eventQuery) {
        this._applyCustomHeaders(eventQuery);
        this._applyEventQueryHeaders(eventQuery);
        this._applyEventQueryParams(eventQuery);
        this.additionalOptions = this.additionalOptions || {};
        this.additionalOptions.id = eventQuery.itemId;
        this.data = eventQuery.data;
        this._applyEventQuerySettings(eventQuery);
    };

    DataQuery.prototype._applyCustomHeaders = function _applyCustomHeaders(eventQuery) {
        this.headers = eventQuery.headers;
        this._normalizeHeaders();
    };

    DataQuery.prototype._applyEventQueryHeaders = function _applyEventQueryHeaders(eventQuery) {
        this._applyEventHeader(_constants.Headers.filter, eventQuery.filter);
        this._applyEventHeader(_constants.Headers.select, eventQuery.fields);
        this._applyEventHeader(_constants.Headers.sort, eventQuery.sort);
        this._applyEventHeader(_constants.Headers.skip, eventQuery.skip);
        this._applyEventHeader(_constants.Headers.take, eventQuery.take);
        this._applyEventHeader(_constants.Headers.expand, eventQuery.expand);
        this._applyEventHeader(_constants.Headers.aggregate, eventQuery.aggregate);
        this._applyEventHeader(_constants.Headers.powerFields, eventQuery.powerfields);
    };

    DataQuery.prototype._applyEventQueryParams = function _applyEventQueryParams(eventQuery) {
        if (eventQuery.filter) {
            this.query = this.query || {};
            this.query.filter = eventQuery.filter;
        }

        if (eventQuery.aggregate) {
            this.query = this.query || {};
            this.query.aggregateExpression = eventQuery.aggregate;
        }

        this.fields = eventQuery.select;
        this.sort = eventQuery.sort;
        this.skip = eventQuery.skip;
        this.take = eventQuery.take;
        this.expand = eventQuery.expand;
    };

    DataQuery.prototype._applyEventQuerySettings = function _applyEventQuerySettings(eventQuery) {
        this.useOffline = eventQuery.settings.useOffline;
        this.forceCache = eventQuery.settings.forceCache;
        this.ignoreCache = eventQuery.settings.ignoreCache;
        this.applyOffline = eventQuery.settings.applyOffline;
    };

    DataQuery.prototype._applyEventHeader = function _applyEventHeader(header, value) {
        if (value && typeof value !== 'string') {
            var headerToLower = header.toLowerCase();
            this.headers[headerToLower] = JSON.stringify(value);
        }
    };

    _createClass(DataQuery, [{
        key: 'canUseOffline',
        get: function get() {
            var canUseOffline = null;
            if (_utils2.default.isContentType.files(this.collectionName) && _platform2.default.isDesktop) {
                var op = this.operation;
                canUseOffline = this.useOffline && (op === _constants.DataQueryOperations.Read || op === _constants.DataQueryOperations.ReadById || op === _constants.DataQueryOperations.FilesGetDownloadUrlById || op === _constants.DataQueryOperations.Delete || op === _constants.DataQueryOperations.DeleteById);
            } else {
                canUseOffline = this.useOffline;
            }

            return canUseOffline;
        }
    }]);

    return DataQuery;
}(_DataQuery2.default);

DataQuery.operations = _constants.DataQueryOperations;


module.exports = DataQuery;

},{"../../common/dataQuery/DataQuery":41,"../../common/platform":51,"../../common/query/Query":53,"../../everlive/constants":70,"../../everlive/utils":121,"underscore":36}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DataQueryBuilder = require('../../common/dataQuery/DataQueryBuilder');

var _DataQueryBuilder2 = _interopRequireDefault(_DataQueryBuilder);

var _DataQuery = require('../../everlive/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _Query = require('../../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _constants = require('../../everlive/constants');

var _underscore = require('underscore');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataQueryBuilder = function (_CommonDataQueryBuild) {
    _inherits(DataQueryBuilder, _CommonDataQueryBuild);

    function DataQueryBuilder() {
        _classCallCheck(this, DataQueryBuilder);

        return _possibleConstructorReturn(this, _CommonDataQueryBuild.apply(this, arguments));
    }

    DataQueryBuilder.prototype._getInitialDataQuery = function _getInitialDataQuery(operation, meta) {
        return new _DataQuery2.default({ meta: meta, operation: operation });
    };

    DataQueryBuilder.prototype._isOperationAllowed = function _isOperationAllowed(operations, operation) {
        return (0, _underscore.contains)(operations, operation);
    };

    DataQueryBuilder.prototype._buildQuery = function _buildQuery(filterOrQuery) {
        if (!filterOrQuery) {
            return null;
        }

        if (filterOrQuery instanceof _Query2.default) {
            return filterOrQuery;
        } else {
            return new _Query2.default(filterOrQuery);
        }
    };

    DataQueryBuilder.prototype._tryBuildQuery = function _tryBuildQuery(op, data) {
        var operations = DataQueryBuilder._tryBuildQueryAllowedOperations;
        if (!this._isOperationAllowed(operations, op)) {
            return null;
        }

        var query = (0, _underscore.has)(data, 'query') ? data.query : data;
        return this._buildQuery(query);
    };

    DataQueryBuilder.prototype._tryGetData = function _tryGetData(op, data) {
        var operations = DataQueryBuilder._tryGetDataAllowedOperations;
        if (!this._isOperationAllowed(operations, op)) {
            return null;
        }

        //TODO: this will not quite work if the user wants to create an item with a "data" field for example.
        var fields = DataQueryBuilder._tryGetDataFields;
        var field = (0, _underscore.find)(fields, function (field) {
            return (0, _underscore.has)(data, field);
        });
        if (field) {
            return data[field];
        }

        return data;
    };

    DataQueryBuilder.prototype._isAuthenticationOperation = function _isAuthenticationOperation(op) {
        return op === _constants.DataQueryOperations.UserLogin || op === _constants.DataQueryOperations.UserLogout || op === _constants.DataQueryOperations.UserLoginWithProvider || op === _constants.DataQueryOperations.UserLinkWithProvider || op === _constants.DataQueryOperations.UserUnlinkFromProvider;
    };

    DataQueryBuilder.prototype._isCloudCodeOperation = function _isCloudCodeOperation(op) {
        return op === _constants.DataQueryOperations.InvokeCloudFunction || op === _constants.DataQueryOperations.InvokeStoredProcedure;
    };

    DataQueryBuilder.prototype._applyOperationSpecificProperties = function _applyOperationSpecificProperties(op, query) {
        if (op === _constants.DataQueryOperations.UserLoginWithProvider) {
            query.authHeaders = false;
        } else if (this._isCloudCodeOperation(op)) {
            var _query$additionalOpti = query.additionalOptions;
            var customParameters = _query$additionalOpti.customParameters;
            var authHeaders = _query$additionalOpti.authHeaders;

            query.authHeaders = authHeaders;
            if (customParameters) {
                query.headers = (0, _underscore.extend)(query.headers, _defineProperty({}, _constants.Headers.customParameters, JSON.stringify(customParameters)));
            }
        }

        if (this._isAuthenticationOperation(op)) {
            query.skipAuth = true;
        }

        return query;
    };

    DataQueryBuilder.prototype.buildDataQuery = function buildDataQuery(data, op, meta, success, error) {
        if (!(0, _underscore.chain)(_constants.DataQueryOperations).values().contains(op).value()) {
            throw new Error('Unknown data query operation - ' + op);
        }

        var dataQuery = _CommonDataQueryBuild.prototype.buildDataQuery.call(this, data, op, meta, success, error);

        if (dataQuery.query) {
            return dataQuery;
        }

        //null causes invalid request body
        dataQuery.query = this._tryBuildQuery(op, data) || undefined;
        dataQuery.data = this._tryGetData(op, data) || undefined;
        this._applyOperationSpecificProperties(op, dataQuery);

        return dataQuery;
    };

    return DataQueryBuilder;
}(_DataQueryBuilder2.default);

DataQueryBuilder._tryBuildQueryAllowedOperations = [_constants.DataQueryOperations.Read, _constants.DataQueryOperations.ReadById, _constants.DataQueryOperations.Count, _constants.DataQueryOperations.Aggregate, _constants.DataQueryOperations.SetAcl, _constants.DataQueryOperations.Update, _constants.DataQueryOperations.SetOwner, _constants.DataQueryOperations.Delete, _constants.DataQueryOperations.DeleteById, _constants.DataQueryOperations.RawUpdate];
DataQueryBuilder._tryGetDataAllowedOperations = [_constants.DataQueryOperations.Create, _constants.DataQueryOperations.RawUpdate, _constants.DataQueryOperations.Update, _constants.DataQueryOperations.SetOwner, _constants.DataQueryOperations.UserLogin, _constants.DataQueryOperations.UserLoginWithProvider, _constants.DataQueryOperations.FilesUpdateContent, _constants.DataQueryOperations.UserResetPassword, _constants.DataQueryOperations.UserSetPassword, _constants.DataQueryOperations.UserChangePassword, _constants.DataQueryOperations.UserLinkWithProvider, _constants.DataQueryOperations.UserUnlinkFromProvider];
DataQueryBuilder._tryGetDataFields = ['updateObject', 'data'];
exports.default = DataQueryBuilder;

},{"../../common/dataQuery/DataQueryBuilder":42,"../../everlive/constants":70,"../../everlive/dataQuery/DataQuery":71,"../../everlive/query/Query":96,"underscore":36}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _nodeCryptojsAes = require('node-cryptojs-aes');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AES = _nodeCryptojsAes.CryptoJS.AES;

var CryptographicProvider = function () {
    function CryptographicProvider() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, CryptographicProvider);

        this.options = options;
    }

    CryptographicProvider.prototype._getKey = function _getKey() {
        return this.options.encryption.key;
    };

    CryptographicProvider.prototype._canEncryptDecrypt = function _canEncryptDecrypt(content) {
        return this._getKey() && content !== null && content !== undefined;
    };

    CryptographicProvider.prototype.encrypt = function encrypt(content) {
        if (!this._canEncryptDecrypt(content)) {
            return content;
        }

        return AES.encrypt(content, this._getKey()).toString();
    };

    CryptographicProvider.prototype.decrypt = function decrypt(content) {
        if (!this._canEncryptDecrypt(content)) {
            return content;
        }

        return AES.decrypt(content, this._getKey()).toString(_nodeCryptojsAes.CryptoJS.enc.Utf8);
    };

    return CryptographicProvider;
}();

exports.default = CryptographicProvider;

},{"node-cryptojs-aes":26}],74:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var isNativeScript = Boolean(typeof android !== 'undefined' && android && android.widget && android.widget.Button || typeof UIButton !== 'undefined' && UIButton);

var platform;
var isCordova = false;
var isWindowsPhone = false;
var isAndroid = false;

if (typeof window !== 'undefined' && !isNativeScript) {
    isCordova = /^file:\/{3}[^\/]|x-wmapp/i.test(window.location.href) && /ios|iphone|ipod|ipad|android|iemobile/i.test(navigator.userAgent);
    isWindowsPhone = isCordova && /iemobile/i.test(navigator.userAgent);
    isAndroid = isCordova && cordova.platformId === 'android';
}

var isNodejs = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;
var isDesktop = !isNativeScript && !isCordova && !isNodejs;

if (isNativeScript) {
    platform = 'ns';
} else if (isNodejs) {
    platform = 'nodejs';
} else if (isDesktop) {
    platform = 'desktop';
} else if (isCordova) {
    platform = 'cordova';
}

var isInAppBuilderSimulator = function isInAppBuilderSimulator() {
    return typeof window !== 'undefined' && window.navigator && window.navigator.simulator;
};

module.exports = {
    isCordova: isCordova,
    isNativeScript: isNativeScript,
    isDesktop: isDesktop,
    isWindowsPhone: isWindowsPhone,
    isAndroid: isAndroid,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs,
    platform: platform,
    isInAppBuilderSimulator: isInAppBuilderSimulator
};

},{}],75:[function(require,module,exports){
'use strict';

/**
 * @class Helpers
 * @classdesc Everlive helper classes
 */

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _htmlHelper = require('../../everlive/helpers/html/htmlHelper');

var _htmlHelper2 = _interopRequireDefault(_htmlHelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var helpers = [];
if (_everlive2.default.isCordova || _everlive2.default.isDesktop) {
    helpers.push({
        name: 'html',
        ctor: _htmlHelper2.default
    });
}

module.exports = helpers;

},{"../../everlive/everlive.platform":74,"../../everlive/helpers/html/htmlHelper":76}],76:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _htmlHelperResponsiveModule = require('../../../everlive/helpers/html/htmlHelperResponsiveModule');

var _htmlHelperResponsiveModule2 = _interopRequireDefault(_htmlHelperResponsiveModule);

var _htmlHelperOfflineModule = require('../../../everlive/helpers/html/htmlHelperOfflineModule');

var _htmlHelperOfflineModule2 = _interopRequireDefault(_htmlHelperOfflineModule);

var _constants = require('../../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _EverliveError = require('../../../everlive/EverliveError');

var _EventEmitterProxy = require('../../../everlive/EventEmitterProxy');

var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    var defaults = {
        processOnLoad: false,
        processOnResize: false,
        loadingImageUrl: '',
        errorImageUrl: '',
        attributes: {
            loadingImage: 'data-loading-image',
            errorImage: 'data-error-image',
            dpi: 'data-dpi',
            imageSource: 'data-src',
            fileSource: 'data-href',
            enableOffline: 'data-offline',
            enableResponsive: 'data-responsive'
        },
        responsiveParams: {
            //http://docs.telerik.com/platform/backend-services/javascript/responsive-images/responsive-images-parameters
        }
    };

    /**
     * @typedef Helpers.html
     * @description Everlive helper for html related operations, such as processing html elements with specific tags.
     */

    function HtmlHelper(everlive, config) {
        _EventEmitterProxy2.default.apply(this);

        this._everlive = everlive;
        this._settings = {
            urlTemplate: '[protocol][hostname][appid]/[operations][url]',
            server: 'bs1.cdn.telerik.com/image/v1/'
        };

        config = config || {};

        this.options = _underscore2.default.extend({}, defaults, config);
        this.options.attributes = _underscore2.default.extend({}, defaults.attributes, config.attributes);
        this.options.responsiveParams = _underscore2.default.extend({}, defaults.responsiveParams, config.responsiveParams);

        this._responsive = new _htmlHelperResponsiveModule2.default(this);
        this._offline = new _htmlHelperOfflineModule2.default(this);

        this._init();
    }

    HtmlHelper.prototype = {
        _init: function _init() {
            var self = this;
            if (self.options.processOnLoad) {
                window.addEventListener('load', this.processAll.bind(this), false);
            }

            if (this.options.processOnResize) {
                window.addEventListener('resize', _underscore2.default.debounce(this.processAll.bind(this), 300), false);
            }
        },

        _triggerOnProcessed: function _triggerOnProcessed(args) {
            this._emitter.emit(_constants2.default.Events.Processed, args);
        },

        _defaultProcessSettings: function _defaultProcessSettings(settings) {
            return _underscore2.default.defaults({}, settings, {
                responsive: true,
                offline: true
            });
        },

        _setLoadingUrl: function _setLoadingUrl(element) {
            var loadingImageUri = element.getAttribute(this.options.attributes.loadingImage) || this.options.loadingImageUrl;
            if (!loadingImageUri || _utils2.default.isElement.anchor(element)) {
                return _utils2.default.successfulPromise();
            }

            return this._setUrl(element, loadingImageUri, true);
        },

        _getBackgroundSrc: function _getBackgroundSrc(el) {
            var elStyle = window.getComputedStyle(el, null);
            var backgrImage = elStyle.getPropertyValue('background-image');

            var img = backgrImage !== 'none' ? backgrImage : false;
            if (img) {
                img = img.replace(/url\(('?"?)(.*?)\1\)/gi, '$2');
            }

            return img;
        },

        _setErrorUrl: function _setErrorUrl(element) {
            var errorImageUrl = element.getAttribute(this.options.attributes.errorImage) || this.options.errorImageUrl;
            if (!errorImageUrl || _utils2.default.isElement.anchor(element)) {
                return _utils2.default.successfulPromise();
            }

            return this._setUrl(element, errorImageUrl, true);
        },

        _setUrl: function _setUrl(element, url, apply) {
            var self = this;
            return new _rsvp2.default.Promise(function (resolve, reject) {
                var elAttr = self._getAttr(element);
                if (_utils2.default.isElement.image(element) && elAttr === self.options.attributes.imageSource) {
                    if (apply) {
                        element.src = url;
                        element.style.visibility = 'visible';
                    } else {
                        var img = new Image();

                        img.onerror = function () {
                            img = null;
                            reject(new _EverliveError.EverliveError('Can\'t be loaded: ' + url));
                        };

                        img.onload = function () {
                            img = null;
                            self._setUrl(element, url, true).then(resolve).catch(reject);
                        };

                        img.src = url;
                    }
                } else {
                    apply = true;
                    if (elAttr) {
                        var attr;
                        if (elAttr === self.options.attributes.imageSource) {
                            attr = 'src';
                        } else if (elAttr === self.options.attributes.fileSource) {
                            attr = 'href';
                        } else {
                            attr = _underscore2.default.last(elAttr.split('-'));
                        }

                        element.setAttribute(attr, url);
                    } else {
                        element.style.backgroundImage = 'url(' + url + ')';
                    }
                }

                if (apply) {
                    resolve();
                }
            });
        },

        _getAttr: function _getAttr(element) {
            if (element.getAttribute(this.options.attributes.imageSource)) {
                return this.options.attributes.imageSource;
            }

            if (element.getAttribute(this.options.attributes.fileSource)) {
                return this.options.attributes.fileSource;
            }
        },

        _getUrl: function _getUrl(element) {
            var url = element.getAttribute(this.options.attributes.imageSource) || element.getAttribute(this.options.attributes.fileSource) || this._getBackgroundSrc(element);

            return url;
        },

        _wrapElements: function _wrapElements(elements) {
            var self = this;

            var results = _underscore2.default.map(elements, function (element) {
                var tag = element.tagName.toLowerCase();

                var evaluateDataAttr = function evaluateDataAttr(attr) {
                    // data-a - true
                    // data-a="" - true
                    // data-a="true" - true
                    // data-a="anything" - true
                    // data-a="false" - false
                    // missing - false
                    var val;
                    var dataVal = (element.attributes[attr] || { value: null }).value;
                    if (dataVal === '') {
                        val = true;
                    } else if (!dataVal) {
                        val = false;
                    } else {
                        try {
                            val = JSON.parse(dataVal);
                        } catch (e) {
                            val = true;
                        }
                    }

                    return val;
                };

                var canResponsive = evaluateDataAttr(self.options.attributes.enableResponsive);
                var canOffline = evaluateDataAttr(self.options.attributes.enableOffline);

                return {
                    item: element,
                    tag: tag,
                    operations: {
                        responsive: canResponsive,
                        offline: canOffline
                    }
                };
            });

            return results;
        },

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        process: function process(elements, settings, success, error) {
            var self = this;

            return _utils2.default.buildPromise(function (resolve) {
                settings = self._defaultProcessSettings(settings);
                if (_underscore2.default.isArray(elements) || elements instanceof NodeList || elements.length) {
                    elements = _underscore2.default.flatten(elements);
                } else {
                    elements = [elements];
                }

                var wrappedElements = self._wrapElements(elements);
                var promises = [];
                _underscore2.default.each(wrappedElements, function (element) {
                    var result = {
                        element: element.item,
                        responsive: false,
                        offline: false
                    };

                    var dataUrl = self._getUrl(result.element);

                    if (!dataUrl) {
                        return promises.push(_utils2.default.successfulPromise(result));
                    }

                    var canResponsive = settings.responsive ? element.operations.responsive : false;
                    var canOffline = settings.offline ? element.operations.offline : false;

                    if (!canResponsive && !canOffline) {
                        return promises.push(self._setUrl(result.element, dataUrl, true).then(function () {
                            return result;
                        }));
                    }

                    var promise = self._setLoadingUrl(result.element);
                    var handleOperation = function handleOperation(operation, url) {
                        if (url) {
                            result[operation] = true;
                            return url;
                        }
                    };

                    if (canResponsive) {
                        promise = promise.then(function () {
                            return self._responsive.responsiveImage(element, dataUrl).then(handleOperation.bind(this, 'responsive'));
                        });
                    }

                    if (canOffline) {
                        promise = promise.then(function (responsiveSrc) {
                            return self._offline.processOffline(responsiveSrc || dataUrl).then(handleOperation.bind(this, 'offline'));
                        });
                    }

                    promise = promise.then(function (finalUrl) {
                        return self._setUrl(result.element, finalUrl).then(function () {
                            return result;
                        });
                    }).catch(function (err) {
                        return self._setErrorUrl(result.element).then(function () {
                            throw {
                                element: result.element,
                                error: err
                            };
                        });
                    });

                    promises.push(promise);
                });

                _rsvp2.default.allSettled(promises).then(function (results) {
                    var processed = [];
                    var failed = [];

                    _underscore2.default.each(results, function (result) {
                        if (result.state === 'fulfilled') {
                            processed.push(result.value);
                        } else {
                            failed.push(result.reason);
                        }
                    });

                    var result = {
                        processed: processed,
                        failed: failed
                    };

                    self._triggerOnProcessed(result);
                    resolve(result);
                });
            }, success, error);
        },

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        processAll: function processAll(settings, success, error) {
            settings = this._defaultProcessSettings(settings);
            var responsiveSelector = '[' + this.options.attributes.enableResponsive + ']';
            var offlineSelector = '[' + this.options.attributes.enableOffline + ']';

            var responsiveElements = [];
            if (settings.responsive) {
                responsiveElements = document.querySelectorAll(responsiveSelector);
            }

            var offlineElements = [];
            if (settings.offline) {
                offlineElements = document.querySelectorAll(offlineSelector);
            }

            var slice = [].slice;
            var elements = _underscore2.default.unique(slice.call(responsiveElements).concat(slice.call(offlineElements)));

            return this.process(elements, settings, success, error);
        }
    };

    return HtmlHelper;
}();

},{"../../../everlive/EventEmitterProxy":56,"../../../everlive/EverliveError":58,"../../../everlive/constants":70,"../../../everlive/helpers/html/htmlHelperOfflineModule":77,"../../../everlive/helpers/html/htmlHelperResponsiveModule":78,"../../../everlive/utils":121,"rsvp":35,"underscore":36}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../../../everlive/EverliveError');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HtmlHelperOfflineModule = function () {
    function HtmlHelperOfflineModule(htmlHelper) {
        _classCallCheck(this, HtmlHelperOfflineModule);

        this.htmlHelper = htmlHelper;
    }

    HtmlHelperOfflineModule.prototype.processOffline = function processOffline(url) {
        var self = this;

        if (!self.htmlHelper._everlive.offlineStorage.files) {
            return _utils2.default.rejectedPromise(new _EverliveError.EverliveError('Offline storage must be enabled in order to use the offline features of the images component.'));
        }

        return self.htmlHelper._everlive.offlineStorage.files.downloadOffline(url).then(function (localUrl) {
            return localUrl;
        }).catch(function (err) {
            if (err.code !== _EverliveError.EverliveErrors.cannotDownloadOffline.code) {
                throw err;
            }

            return self.htmlHelper._everlive.offlineStorage._offlineFilesProcessor.getOfflineFilesData().then(function (offlineFilesData) {
                var basename = _path2.default.basename(url);
                var oldFile = _underscore2.default.find(offlineFilesData, function (entry) {
                    if (entry.onlineLocation && entry.offlineLocation) {
                        var onlineLocation = entry.onlineLocation;
                        var basenameIndex = onlineLocation.lastIndexOf(basename);
                        return basenameIndex !== -1;
                    }
                });

                if (oldFile) {
                    return oldFile.offlineLocation;
                }

                throw new _EverliveError.EverliveError('Cannot find offline image ' + url, _EverliveError.EverliveErrors.missingOrInvalidFileContent.code);
            });
        });
    };

    return HtmlHelperOfflineModule;
}();

exports.default = HtmlHelperOfflineModule;

},{"../../../everlive/EverliveError":58,"../../../everlive/utils":121,"path":4,"underscore":36}],78:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _EverliveError = require('../../../everlive/EverliveError');

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_RESPONSIVE_OPERATIONS = {
    params: {
        resize: {}
    },
    isUserResize: false
};

module.exports = function () {
    function HtmlHelperResponsiveModule(htmlHelper) {
        this.htmlHelper = htmlHelper;
    }

    HtmlHelperResponsiveModule.prototype = {
        getBackgroundWidth: function getBackgroundWidth(el) {
            return Math.ceil(el.offsetWidth);
        },

        getBackgroundHeight: function getBackgroundHeight(el) {
            return Math.ceil(el.offsetHeight);
        },

        parseParamsString: function parseParamsString(str) {
            if (!str || typeof str === 'undefined' || str.length <= 1) {
                return DEFAULT_RESPONSIVE_OPERATIONS;
            }

            var params = str.split('/');

            var result = {};
            var isUserResize = false;

            //TODO: Perhaps the conversion from query string to object and vice versa could go in utils, since it may be useful in other places?
            _underscore2.default.chain(params).filter(function (param) {
                return !!param;
            }) //TODO: I think there's a function in lodash called "compact", which does this.
            .each(function (param) {
                var paramPair = param.split('=');
                var paramName = paramPair[0];
                var paramValues = paramPair[1];
                paramValues = unescape(paramValues.replace(/\+/g, ' '));
                result[paramName] = paramValues;

                if (paramName === 'resize') {
                    isUserResize = true;
                }
            });

            return {
                params: result,
                isUserResize: isUserResize
            };
        },

        getImgParams: function getImgParams(src, el) {
            var self = this;

            var operations;
            var imgUrl = src.replace(/.*?resize=[^//]*\//gi, '');
            var protocolRe = new RegExp('https?://', 'gi');
            var serverRe = new RegExp(this.htmlHelper._settings.server, 'gi');
            var apiIdRe = new RegExp(this.htmlHelper._everlive.appId + '/', 'gi');

            var operationsRaw = src.replace(imgUrl, '').replace(protocolRe, '').replace(serverRe, '').replace(apiIdRe, '').toLowerCase();
            if (operationsRaw !== '') {
                var operationsToParse = operationsRaw.indexOf('/') ? operationsRaw.substring(0, operationsRaw.length - 1) : operationsRaw;
                //TODO: I'm hazy on the context, but... If operationsToParse starts with "/", we parse it "as is",
                //if not, I guess it's expected to have it in the end and it's truncated? Is it
                //impossible to not have a "/" at all and cut the last symbol when maybe it shouldn't be cut?
                operations = this.parseParamsString(operationsToParse);
            } else if (el.dataset.responsiveParams) {
                operations = DEFAULT_RESPONSIVE_OPERATIONS;
                _underscore2.default.each(el.dataset.responsiveParams.split(','), function (key) {
                    var pair = key.split(':');
                    var param = pair[0];
                    var value = pair[1];
                    operations.params.resize[param] = value;
                });
            } else {
                operations = DEFAULT_RESPONSIVE_OPERATIONS;
            }

            _underscore2.default.chain(this.htmlHelper.options.responsiveParams).keys().each(function (key) {
                var value = self.htmlHelper.options.responsiveParams[key];
                operations.params.resize[key] = value;
            });

            // If it's a user resize operation, use the passed url in the data-src property
            if (operations.isUserResize) {
                imgUrl = src;
            }

            return {
                imgUrl: imgUrl,
                operations: operations.params,
                isUserResize: operations.isUserResize
            };
        },

        hasClass: function hasClass(el, cl) {
            var regex = new RegExp('(?:\\s|^)' + cl + '(?:\\s|$)');
            return !!el.className.match(regex);
        },

        getImageWidth: function getImageWidth(el) {
            var parentEl = el.parentNode;
            if (parentEl) {
                var parentWidth = parentEl.offsetWidth;
                var itemStyle = window.getComputedStyle(parentEl, null);
                var pl = parseFloat(itemStyle.getPropertyValue('padding-left'));
                var pr = parseFloat(itemStyle.getPropertyValue('padding-right'));
                var bl = parseFloat(itemStyle.getPropertyValue('border-left-width'));
                var br = parseFloat(itemStyle.getPropertyValue('border-right-width'));

                return Math.abs(parentWidth - Math.ceil(pl + pr + bl + br));
            }

            return 0;
        },

        getImageHeight: function getImageHeight(el) {
            var parentEl = el.parentNode;
            if (parentEl) {
                var parentHeight = parentEl.offsetHeight;
                var itemStyle = window.getComputedStyle(parentEl, null);
                var pt = parseFloat(itemStyle.getPropertyValue('padding-top'));
                var pb = parseFloat(itemStyle.getPropertyValue('padding-bottom'));
                var bt = parseFloat(itemStyle.getPropertyValue('border-top-width'));
                var bb = parseFloat(itemStyle.getPropertyValue('border-bottom-width'));

                return Math.abs(parentHeight - Math.ceil(pt + pb + bt + bb));
            }

            return 0;
        },

        getDevicePixelRatio: function getDevicePixelRatio() {
            return window.devicePixelRatio ? window.devicePixelRatio : 1;
        },

        getPixelRatio: function getPixelRatio(el) {
            var pixelDensity = el.getAttribute(this.htmlHelper.options.attributes.dpi) || '';
            return pixelDensity !== '' ? _underscore2.default.isNumber(pixelDensity) ? parseFloat(pixelDensity) : false : this.getDevicePixelRatio();
        },

        getImgParamsString: function getImgParamsString(params) {
            var paramsStr = 'resize=';

            _underscore2.default.chain(params.resize).keys().each(function (paramName, index, arr) {
                paramsStr += paramName + ':' + params.resize[paramName];
                if (index < arr.length - 1) {
                    paramsStr += ',';
                } else {
                    paramsStr += '/';
                }
            });

            return paramsStr;
        },

        responsiveImage: function responsiveImage(item, dataSrc) {
            var self = this;
            var image = _underscore2.default.extend({}, item);
            var element = image.item;
            var tag = image.tag;

            var isImage = _utils2.default.isElement.image(tag);
            var imgWidth;

            image = _underscore2.default.extend({}, image, self.getImgParams(dataSrc, item.item));

            if (!image.isUserResize) {
                imgWidth = isImage ? self.getImageWidth(element) : self.getBackgroundWidth(element);
            }

            imgWidth = imgWidth ? imgWidth : false;
            var src = image.isUserResize ? image.imgUrl : self.getImgSrc(image, imgWidth);

            return new _rsvp2.default.Promise(function (resolve) {
                if (!imgWidth && !image.isUserResize) {
                    // we don't have the width of the user image either.
                    // if this element is not visible, we don't have to process it.

                    return resolve();
                }

                return resolve(src);
            });
        },

        getImgSrc: function getImgSrc(image, imgWidth) {
            var protocol = this.htmlHelper._everlive.setup.scheme + '://';
            var appId = this.htmlHelper._everlive.setup.appId;
            var server = this.htmlHelper._settings.server;
            var url = this.htmlHelper._settings.urlTemplate;
            var pixelDensity = this.getPixelRatio(image.item);

            url = url.replace('[protocol]', protocol);
            url = url.replace('[appid]', appId || '');
            url = url.replace('[hostname]', server);

            var params = image.operations || false;
            var paramsString;
            if (params) {
                var operations = '';
                params.resize = params.resize || {};
                params.resize.w = imgWidth;
                params.resize.pd = pixelDensity;
                var fill = params.resize.fill;
                if (fill === 'cover' || fill === 'contain') {
                    //for fill:cover, we need both the width and height of the image
                    params.resize.h = this.getImageHeight(image.item) || this.getBackgroundHeight(image.item);
                }

                paramsString = this.getImgParamsString(params);
            } else {
                var defaultParams = {
                    resize: {
                        w: imgWidth,
                        pd: pixelDensity
                    }
                };
                paramsString = this.getImgParamsString(defaultParams);
            }

            url = url.replace('[operations]', paramsString);
            url = url.replace('[url]', image.imgUrl);
            return url;
        }
    };

    return HtmlHelperResponsiveModule;
}();

},{"../../../everlive/EverliveError":58,"../../../everlive/utils":121,"rsvp":35,"underscore":36}],79:[function(require,module,exports){
'use strict';

var _Everlive = require('../everlive/Everlive');

var _Everlive2 = _interopRequireDefault(_Everlive);

var _everlive = require('../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _reqwest = require('../everlive/reqwest.everlive');

var _reqwest2 = _interopRequireDefault(_reqwest);

var _Query = require('../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _AggregateQuery = require('../everlive/query/AggregateQuery');

var _AggregateQuery2 = _interopRequireDefault(_AggregateQuery);

var _QueryBuilder = require('../everlive/query/QueryBuilder');

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

var _GeoPoint = require('../everlive/GeoPoint');

var _GeoPoint2 = _interopRequireDefault(_GeoPoint);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _Request = require('../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

var _EverliveError = require('../everlive/EverliveError');

var _utils = require('../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _Data = require('../everlive/types/Data');

var _Data2 = _interopRequireDefault(_Data);

var _offlinePersisters = require('../everlive/offline/offlinePersisters');

var _offlinePersisters2 = _interopRequireDefault(_offlinePersisters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    _Everlive2.default.version = '1.7.0';

    if (!_everlive2.default.isNativeScript && !_everlive2.default.isNodejs) {
        var kendo = require('../everlive/kendo/kendo.everlive');
        _Everlive2.default.createDataSource = kendo.createDataSource;
        _Everlive2.default.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    _Everlive2.default.PushCallbacks = {};
    _Everlive2.default.Offline = {};

    _Everlive2.default.Query = _Query2.default;
    _Everlive2.default.AggregateQuery = _AggregateQuery2.default;
    _Everlive2.default.QueryBuilder = _QueryBuilder2.default;
    _Everlive2.default.GeoPoint = _GeoPoint2.default;
    _Everlive2.default.Constants = _constants2.default;
    _Everlive2.default.Request = _Request2.default;
    _Everlive2.default.EverliveErrors = _EverliveError.EverliveErrors;
    _Everlive2.default.Data = _Data2.default;
    _Everlive2.default._utils = _utils2.default;
    _Everlive2.default._traverseAndRevive = _Everlive2.default._utils.parseUtilities.traverseAndRevive;
    _Everlive2.default._common = { _: _underscore2.default, rsvp: _rsvp2.default, reqwest: _reqwest2.default };

    _Everlive2.default.persister = {
        LocalStorage: _offlinePersisters2.default.LocalStoragePersister,
        FileSystem: _offlinePersisters2.default.FileSystemPersister
    };

    module.exports = _Everlive2.default;
})();

},{"../everlive/Everlive":57,"../everlive/EverliveError":58,"../everlive/GeoPoint":61,"../everlive/Request":63,"../everlive/constants":70,"../everlive/everlive.platform":74,"../everlive/kendo/kendo.everlive":80,"../everlive/offline/offlinePersisters":86,"../everlive/query/AggregateQuery":94,"../everlive/query/Query":96,"../everlive/query/QueryBuilder":97,"../everlive/reqwest.everlive":100,"../everlive/types/Data":110,"../everlive/utils":121,"rsvp":35,"underscore":36}],80:[function(require,module,exports){
'use strict';

var _QueryBuilder = require('../../everlive/query/QueryBuilder');

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

var _Query = require('../../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _AggregateQuery = require('../../everlive/query/AggregateQuery');

var _AggregateQuery2 = _interopRequireDefault(_AggregateQuery);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _Everlive = require('../../everlive/Everlive');

var _Everlive2 = _interopRequireDefault(_Everlive);

var _EverliveError = require('../../everlive/EverliveError');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var operations = {
    read: 'read',
    update: 'update',
    destroy: 'destroy',
    create: 'create'
};

(function () {
    'use strict';

    if (typeof window !== 'undefined' && typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined' || _underscore2.default.isEmpty(window.kendo.data)) {
        return;
    }

    var $ = window.jQuery;
    var kendo = window.kendo;

    var extend = $.extend;
    var aggrSeparator = '_';

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function init(options) {
            this.everlive$ = options.dataProvider || _Everlive2.default.$;

            this._subscribeToSdkEvents(options);
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },
        read: function read(options) {
            var methodOption = this.options['read'];
            var self = this;
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var query = translateKendoQuery(options.data);
            var everliveQuery = new _Query2.default(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;

            if (id) {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery).then(function (getResult) {
                    return self._readServAggregates(getResult, query, options, methodHeaders);
                }).then(options.success).catch(options.error);
            }
        },
        update: function update(options) {
            var methodOption = this.options['update'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _underscore2.default.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate).then(options.success.bind(this, itemForUpdate), options.error).catch(options.error);
            }
        },
        create: function create(options) {
            var methodOption = this.options['create'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _underscore2.default.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData).then(options.success.bind(this, createData), options.error).catch(options.error);
        },
        destroy: function destroy(options) {
            var methodOption = this.options['destroy'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _underscore2.default.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }

            var removeFilter = {
                Id: options.data.Id
            };

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroySingle(removeFilter).then(options.success, options.error).catch(options.error);
        },
        _subscribeToSdkEvents: function _subscribeToSdkEvents(options) {
            var self = this;

            _underscore2.default.map(operations, function (op) {
                if (options && options[op] && typeof options[op].beforeSend === 'function') {
                    var listener = options[op].beforeSend;
                    self.everlive$.on(_Everlive2.default.Constants.Events.BeforeExecute, listener);
                }
            });
        },
        _readServAggregates: function _readServAggregates(result, query, options, methodHeaders) {
            if (options.data.aggregate) {
                if (!options.data.hasOwnProperty('filter') && !query.$where) {
                    throw new Error("The serverFiltering option must be enabled, when using serverAggregates.");
                }
                var aggregateQuery = new _AggregateQuery2.default(query.$where, null, query.$sort, query.$skip, query.$take);
                _transformAggregatesKendoToEverlive(options.data.aggregate, aggregateQuery);
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).aggregate(aggregateQuery).then(function (data) {
                    // merge aggregation into the result
                    var aggrResult = _transformAggregatesEverliveToKendo(options.data.aggregate, data.result[0]); // only 1 result is expected from server for aggregates, as KendoAggregates are actually totals
                    $.extend(true, result, { aggregates: aggrResult });
                    return result;
                }).catch(options.error);
            } else {
                return result;
            }
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: function total(data) {
                    return data.hasOwnProperty('count') ? data.count : data.Count;
                },
                data: function data(_data) {
                    return _data.result || _Everlive2.default._traverseAndRevive(_data.Result) || _data;
                },
                model: {
                    id: _constants2.default.idField
                },
                aggregates: 'aggregates'
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                result.$where = filterBuilder.build(data.filter);
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function build(filter) {
            return filterBuilder._build(filter);
        },
        _build: function _build(filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            } else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            } else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            } else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            } else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function _isRaw(filter) {
            return filter.operator === '_raw';
        },
        _raw: function _raw(filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function _isSimple(filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function _simple(filter) {
            var term = {},
                fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            } else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function _isRegex(filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function _regex(filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function _getRegex(filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith':
                    // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + '$', 'i');
            }
            throw new Error('Unknown operator type.');
        },
        _getRegexValue: function _getRegexValue(regex) {
            return _QueryBuilder2.default.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function _isAnd(filter) {
            return filter.logic === 'and';
        },
        _and: function _and(filter) {
            var i,
                l,
                term,
                result = { $and: [] };
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.$and.push(term);
            }
            return result;
        },
        _isOr: function _isOr(filter) {
            return filter.logic === 'or';
        },
        _or: function _or(filter) {
            var i,
                l,
                term,
                result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return { $or: result };
        },
        _translateoperator: function _translateoperator(operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return '$ne';
                case 'gt':
                    return '$gt';
                case 'lt':
                    return '$lt';
                case 'gte':
                    return '$gte';
                case 'lte':
                    return '$lte';
            }
            throw new Error('Unknown operator type.');
        }
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo UI scripts is required*.
     * @param options data source options. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @param options.transport.typeName The content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
         *   transport: {
         *     typeName: 'Books'
         *   }
         * });
     * ```
     */
    var createDataSource = function createDataSource(options) {
        options = options || {};
        return everlive$.getKendoDataSource(options.typeName, options);
    };

    /**
     * Creates a new Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo UI widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo UI scripts is required*.
     * @param options data source Options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName Name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand An array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - An object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - An object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - A number specifying the skip value.
     * @param {object} ExpandDefinition.take - A number specifying the take value.
     * @param {object} ExpandDefinition.fields - An object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See the Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
     *   'typeName': 'Continents',
     *   'expand': ['Countries', 'Towns']
     * });
     *
     * ...
     * ('#treeview').kendoTreeView({
     *   dataSource: continents,
     *   dataTextField: ['ContinentName', 'CountryName', 'TownName']
     * });
     * ```
     */
    var createHierarchicalDataSource = function createHierarchicalDataSource(options) {
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || _Everlive2.default.$;
        if (!everlive$) {
            throw new Error('You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.');
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }
        return everlive$.getHierarchicalDataSource(typeName, options);
    };

    /**
     * Get a Kendo UI DataSource that is attached to the current instance of the SDK with default options.
     * @method getKendoDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} [options] Additional DataSource options.
     * @returns {DataSource}
     */
    _Everlive2.default.prototype.getKendoDataSource = function (typeName, options) {
        options = options || {};
        var everlive$ = options.dataProvider || _Everlive2.default.$;
        if (!everlive$) {
            throw new Error('You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.');
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }
        if (options.serverGrouping) {
            throw new Error("serverGrouping is not supported.");
        }
        if (options.serverAggregates && !options.serverFiltering) {
            throw new Error("The serverFiltering option must be enabled, when using serverAggregates.");
        }

        var defaultEverliveOptions = {
            type: 'everlive',
            transport: {
                typeName: typeName,
                dataProvider: this
            }
        };

        var options = _underscore2.default.defaults(defaultEverliveOptions, options);
        return new kendo.data.DataSource(options);
    };

    /**
     * Get a Kendo UI HierarchicalDataSource that is attached to the current instance of the SDK with default options.
     * @method getHierarchicalDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} dataSourceOptions Additional DataSource options that describe the hierarchical structure.
     * @returns {HierarchicalDataSource}
     */
    _Everlive2.default.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
        dataSourceOptions = dataSourceOptions || {};
        var expand = dataSourceOptions.expand || dataSourceOptions;
        delete dataSourceOptions.expand;
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI HierarchicalDataSource.");
        }
        if (!$.isArray(expand)) {
            throw new Error("You need to set 'expand' array option in order to create a Kendo UI HierarchicalDataSource");
        }
        var baseUrl = this.buildUrl() + typeName;

        var expandSchema;
        var isOfflineStorageEnabled = this._isOfflineStorageEnabled();
        for (var i = expand.length - 1; i >= 0; i--) {
            //recursively build the hierarchical data source
            var expandNode = expand[i];
            if (isOfflineStorageEnabled) {
                if (!$.isPlainObject(expandNode)) {
                    throw new Error('When offline is enabled, each member of the expand array option must be an object. (Expand node index: ' + i + ')');
                }
                if (!expandNode.relation) {
                    throw new Error('When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: ' + i + ')');
                }
                if (!expandNode.typeName) {
                    throw new Error('When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: ' + i + ')');
                }

                var headers;
                var expandExpression = {};
                expandExpression[expandNode.relation] = {
                    TargetTypeName: expandNode.typeName,
                    Filter: expandNode.filter,
                    Sort: expandNode.sort,
                    Take: expandNode.take,
                    Skip: expandNode.skip,
                    Fields: expandNode.fields,
                    SingleField: expandNode.singleField
                };
                headers = {
                    'X-Everlive-Expand': JSON.stringify(expandExpression),
                    'X-Everlive-Single-Field': expandNode.relation
                };
                var parentType;
                if (i === 0) {
                    parentType = typeName;
                } else {
                    parentType = expand[i - 1].typeName;
                }
                expandSchema = {
                    model: {
                        hasChildren: expandNode.relation,
                        children: {
                            type: 'everlive',
                            transport: {
                                typeName: parentType,
                                read: {
                                    headers: headers
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            } else {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expandNode),
                        children: {
                            type: 'everlive',
                            transport: {
                                read: {
                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
                                    headers: getHeadersForExpandNode(expandNode)
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            }
        }
        var options = {};
        options.type = 'everlive';
        options.transport = {
            typeName: typeName,
            dataProvider: this
        };
        options.schema = expandSchema;
        if ($.isPlainObject(dataSourceOptions)) {
            extend(true, options, dataSourceOptions);
        }
        return new kendo.data.HierarchicalDataSource(options);
    };

    var getUrlGeneratorForNode = function getUrlGeneratorForNode(baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {
                    //if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            };
        }(pathUrl, expandField);
    };

    var getHeadersForExpandNode = function getHeadersForExpandNode(expandNode) {
        if (typeof expandNode === 'string') {
            return {};
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            };
        }
    };

    var getRelationFieldForExpandNode = function getRelationFieldForExpandNode(expandNode) {
        if (typeof expandNode === 'string') {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    /** * passes Kendo-format aggregations to JS SDK */
    var _transformAggregatesKendoToEverlive = function _transformAggregatesKendoToEverlive(kendoAggregates, aggregateQuery) {
        _underscore2.default.each(kendoAggregates, function (element) {
            if (element.aggregate === 'count') {
                aggregateQuery[element.aggregate](element.aggregate + aggrSeparator + element.field);
            } else {
                aggregateQuery[element.aggregate](element.field, element.aggregate + aggrSeparator + element.field);
            }
        });
    };

    /** * reformat server-response aggregations from Everlive API format to Kendo*/
    var _transformAggregatesEverliveToKendo = function _transformAggregatesEverliveToKendo(kendoAggregates, data) {
        var aggrData = {};
        _underscore2.default.each(kendoAggregates, function (element) {
            if (!aggrData[element.field]) {
                aggrData[element.field] = {};
            }
            aggrData[element.field][element.aggregate] = data[element.aggregate + aggrSeparator + element.field];
        });
        return _underscore2.default.isEmpty(aggrData) ? null : aggrData;
    };

    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
})();

},{"../../everlive/Everlive":57,"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/query/AggregateQuery":94,"../../everlive/query/Query":96,"../../everlive/query/QueryBuilder":97,"underscore":36}],81:[function(require,module,exports){
'use strict';

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _reqwest = require('../../everlive/reqwest.everlive');

var _reqwest2 = _interopRequireDefault(_reqwest);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nodeCryptojsAes = require('node-cryptojs-aes');

var _EverliveError = require('../../everlive/EverliveError');

var _AutoQueue = require('../../everlive/AutoQueue');

var _AutoQueue2 = _interopRequireDefault(_AutoQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OfflineFilesModule = function OfflineFilesModule(offlineFilesProcessor, everlive, downloadsConcurrency) {
    this._offlineFilesProcessor = offlineFilesProcessor;
    this._everlive = everlive;
    this._downloadsQueue = new _AutoQueue2.default(downloadsConcurrency);
};

/**
 * @class OfflineFilesModule
 * @classdesc A class that provides the means to operate with files in offline mode.
 * @protected
 */
OfflineFilesModule.prototype = {
    _getFilenameMetadata: function _getFilenameMetadata(location, offlineFileInfo) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            (0, _reqwest2.default)({
                url: location,
                method: 'HEAD',
                async: true,
                crossDomain: true
            }).then(function (xmlResponse) {
                var contentDispositionHeader = xmlResponse.getResponseHeader('Content-Disposition');
                if (contentDispositionHeader) {
                    var matches = /filename="?([^"\\]*(?:\\.[^"\\]*)*)"?/i.exec(contentDispositionHeader);
                    if (_underscore2.default.isArray(matches)) {
                        offlineFileInfo.filename = matches[1];
                    }
                } else {
                    offlineFileInfo.filename = _path2.default.basename(xmlResponse.responseURL);
                }

                resolve(xmlResponse.responseURL);
            }).catch(function (err) {
                return reject(err);
            });
        });
    },

    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @returns {Promise} The promise for the request
     */
    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    downloadOffline: function downloadOffline(location, overwrite, success, error) {
        var self = this;

        return (0, _utils.buildPromise)(function (success, error) {
            self._downloadsQueue.enqueue(function (cb) {
                var offlineFileInfo;
                return self._getOfflineFileInfo(location).then(function (_offlineFileInfo) {
                    offlineFileInfo = _offlineFileInfo;
                    if (overwrite) {
                        return false;
                    }

                    return self.existsOffline(location);
                }).then(function (exists) {
                    if (!exists) {
                        if (self._everlive.isOnline()) {
                            return _utils2.default.successfulPromise().then(function () {
                                if (!offlineFileInfo.filename) {
                                    return self._getFilenameMetadata(location, offlineFileInfo);
                                }
                            }).then(function (locationAfterRedirect) {
                                var location = locationAfterRedirect || offlineFileInfo.location;
                                return self._saveFile(location, offlineFileInfo.filename, null, offlineFileInfo.location);
                            });
                        }

                        error(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.cannotDownloadOffline));
                    } else {
                        return self._getOfflineFileInfo(location).then(function (fileInfo) {
                            return self._getOfflineLocation(fileInfo);
                        });
                    }
                }).then(function (result) {
                    cb(null, result);
                }).catch(cb);
            }, success, error);
        }, success, error);
    },

    _saveFile: function _saveFile(location, filename, id, cacheKey) {
        var self = this;
        var actualLocation;

        return self._downloadFile(location, filename).then(function (_actualLocation) {
            actualLocation = _actualLocation;
            return self._offlineFilesProcessor.getOfflineFilesData();
        }).then(function (offlineFilesData) {
            offlineFilesData.push({
                offlineLocation: actualLocation,
                onlineLocation: cacheKey || location,
                id: id
            });

            return self._offlineFilesProcessor.saveOfflineFilesData();
        }).then(function () {
            return actualLocation;
        });
    },

    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purgeAll: function purgeAll(success, error) {
        var self = this;

        return _utils2.default.buildPromise(function (success, error) {
            self._offlineFilesProcessor.fileStore.removeFilesDirectory().then(function () {
                return self._offlineFilesProcessor.filesMetaStore.removeFilesDirectory();
            }).then(function () {
                self._offlineFilesProcessor._offlineFilesData = null;
            }).then(success).catch(error);
        }, success, error);
    },

    _getOfflineLocation: function _getOfflineLocation(fileInfo) {
        var self = this;
        var url = fileInfo.location;
        var filename = fileInfo.filename;
        var id = fileInfo.Id;

        return self._offlineFilesProcessor.getOfflineLocation(url, id).then(function (offlineUrl) {
            if (offlineUrl) {
                return offlineUrl;
            }

            // if no url is provided this means that the file exists only offline
            // the Uri field has not been populated by the server
            if (id && !url) {
                return self._getFileUrlForId(id, filename);
            }

            return null;
        });
    },

    _downloadFile: function _downloadFile(url, name) {
        var self = this;

        // TODO: [offline] this will not work in NativeScript at the moment
        return new _rsvp2.default.Promise(function (resolve, reject) {
            var fileTransfer = new FileTransfer();
            var sanitizedUrl = self._sanitizeUrl(url);
            var fileId = _path2.default.basename(sanitizedUrl);
            var extension = _path2.default.extname(name);
            var filename = fileId;
            if (_path2.default.extname(sanitizedUrl) !== extension) {
                filename += extension;
            }

            var fileParentDirectory = '';
            if (!_utils2.default.isGuid(url)) {
                var fileIdIndex = url.lastIndexOf(fileId);
                var baseUrl = url.substr(0, fileIdIndex);
                fileParentDirectory = _nodeCryptojsAes.CryptoJS.MD5(baseUrl).toString();
            }

            return self._offlineFilesProcessor.fileStore.getDataDirectory().then(function (dataDir) {
                return _utils2.default.joinPath(dataDir.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileParentDirectory, filename);
            }).then(function (location) {
                fileTransfer.download(url, location, function () {
                    resolve(location);
                }, reject, true, {
                    headers: self._everlive.buildAuthHeader()
                });
            }).catch(reject);
        });
    },

    _sanitizeUrl: function _sanitizeUrl(url) {
        if (!url) {
            return url;
        }

        var sanitizedUrl = encodeURI(url);
        var questionMarkIndex = sanitizedUrl.lastIndexOf('?');
        if (questionMarkIndex !== -1) {
            sanitizedUrl = sanitizedUrl.substr(0, questionMarkIndex); //linux does not allow question marks in its filenames
        }

        return sanitizedUrl;
    },

    _getFileUrlForId: function _getFileUrlForId(fileId, filename) {
        var self = this;

        return this._offlineFilesProcessor.fileStore.getDataDirectory().then(function (dataDirectory) {
            var fileExtension = _path2.default.extname(filename);
            return _utils2.default.joinPath(dataDirectory.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileId + fileExtension);
        });
    },

    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @returns {Promise} The promise for the request
     */
    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    existsOffline: function existsOffline(location, success, error) {
        var self = this;

        return (0, _utils.buildPromise)(function (success, error) {
            self._getOfflineFileInfo(location).then(function (fileInfo) {
                return self._getOfflineLocation(fileInfo);
            }).then(function (offlineUrl) {
                if (offlineUrl) {
                    return self._offlineFilesProcessor.fileStore.getFileByAbsolutePath(offlineUrl);
                }
            }).then(function (offlineFile) {
                return !!offlineFile;
            }).then(success).catch(function (err) {
                if (err.code === _EverliveError.EverliveErrors.itemNotFound.code) {
                    return success(false);
                }

                return error.apply(this, arguments);
            });
        }, success, error);
    },

    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to remove.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purge: function purge(location, success, error) {
        var self = this;

        return (0, _utils.buildPromise)(function (success, error) {
            self._getOfflineFileInfo(location).then(function (fileInfo) {
                return self._getOfflineLocation(fileInfo);
            }).then(function (location) {
                if (location) {
                    return self._offlineFilesProcessor.purge(location);
                }
            }).then(success).catch(error);
        }, success, error);
    },

    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @returns {Promise} The promise for the request
     */
    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    getOfflineLocation: function getOfflineLocation(location, success, error) {
        var self = this;

        return (0, _utils.buildPromise)(function (success, error) {
            self._getOfflineFileInfo(location).then(self._getOfflineLocation.bind(self)).then(function (offlineLocation) {
                if (offlineLocation) {
                    return self.existsOffline(offlineLocation).then(function (exists) {
                        if (exists) {
                            return offlineLocation;
                        }

                        return null;
                    });
                }

                return null;
            }).then(success).catch(error);
        }, success, error);
    },

    _getOfflineFileInfo: function _getOfflineFileInfo(location) {
        var self = this;
        var sanitizedUrl = this._sanitizeUrl(location);

        return new _rsvp2.default.Promise(function (resolve, reject) {
            self._everlive.Files.isSync(true).useOffline(true).getById(sanitizedUrl).then(function (response) {
                var file = response.result;
                resolve({
                    location: file.Uri,
                    filename: file.Filename,
                    Id: sanitizedUrl
                });
            }).catch(function (err) {
                if (err && err.code === _EverliveError.EverliveErrors.itemNotFound.code) {
                    resolve({
                        location: location
                    });
                } else {
                    reject(err);
                }
            });
        });
    },

    changeFileExtensionById: function changeFileExtensionById(id, extension) {
        var self = this;

        if (typeof extension !== 'string') {
            return new _rsvp2.default.Promise(function (resolve) {
                resolve();
            });
        }

        return self._changeExtension(id, extension);
    },

    _changeExtension: function _changeExtension(id, newExtension) {
        var self = this;

        var dataDir;

        var fileStore = self._offlineFilesProcessor.fileStore;
        var fileName = id + newExtension;
        return fileStore.getFilesDirectory().then(function (directoryEntry) {
            dataDir = directoryEntry;
            return self.getOfflineLocation(id);
        }).then(function (localPath) {

            var existingFileName = _path2.default.basename(localPath);
            if (existingFileName !== fileName) {
                return fileStore.getFileByAbsolutePath(localPath).then(function (fileEntry) {
                    return fileStore.renameFile(dataDir, fileEntry, fileName);
                }).then(function () {
                    return self._offlineFilesProcessor.getOfflineFilesData();
                }).then(function (offlineFilesData) {
                    var mappedEntry = _underscore2.default.findWhere(offlineFilesData, { offlineLocation: localPath });
                    if (!mappedEntry) {
                        throw new _EverliveError.EverliveError('Could not find a cached location for the specified file.');
                    }

                    var previousLocation = mappedEntry.offlineLocation;
                    var previousExtension = _path2.default.extname(previousLocation);
                    var actualLocation = previousLocation.slice(0, previousLocation.length - previousExtension.length) + newExtension;
                    mappedEntry.offlineLocation = actualLocation;

                    return self._offlineFilesProcessor.saveOfflineFilesData();
                });
            }
        });
    }
};

module.exports = OfflineFilesModule;

},{"../../everlive/AutoQueue":55,"../../everlive/EverliveError":58,"../../everlive/reqwest.everlive":100,"../../everlive/utils":121,"node-cryptojs-aes":26,"path":4,"rsvp":35,"underscore":36}],82:[function(require,module,exports){
'use strict';

var _EverliveError = require('../../everlive/EverliveError');

var _FileStore = require('../../everlive/storages/FileStore');

var _FileStore2 = _interopRequireDefault(_FileStore);

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FILES_METADATA_FILE_NAME = 'filesMetadataMap';

var OfflineFilesProcessor = function OfflineFilesProcessor(setup, everlive) {
    this.fileStore = new _FileStore2.default(setup.files.storagePath, setup);
    this.filesMetaStore = new _FileStore2.default(setup.files.metaPath, setup);
    this._everlive = everlive;
};

OfflineFilesProcessor.prototype = {
    validateFileCreateObject: function validateFileCreateObject(obj, isSync) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            if (!obj.base64 && !isSync) {
                return reject(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.missingOrInvalidFileContent));
            } else if (!obj.ContentType) {
                return reject(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.missingContentType));
            } else if (!obj.Filename) {
                //TODO: [offline] add an appropriate error
                return reject(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.invalidRequest));
            }

            resolve();
        });
    },

    getOfflineFilesData: function getOfflineFilesData() {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            if (!self._offlineFilesData) {
                return self.filesMetaStore.getFile(FILES_METADATA_FILE_NAME).then(function (metadataFileHandle) {
                    return self.filesMetaStore.readFileAsText(metadataFileHandle);
                }).then(function (metadataText) {
                    if (!metadataText) {
                        metadataText = '[]';
                    }

                    self._offlineFilesData = JSON.parse(metadataText);
                    resolve(self._offlineFilesData);
                }).catch(reject);
            } else {
                resolve(self._offlineFilesData);
            }
        });
    },

    saveOfflineFilesData: function saveOfflineFilesData() {
        var self = this;

        return self.getOfflineFilesData().then(function (offlineFilesData) {
            return self.filesMetaStore.writeText(FILES_METADATA_FILE_NAME, JSON.stringify(offlineFilesData));
        });
    },

    upsertFileFromObject: function upsertFileFromObject(obj, isCreate, isSync) {
        //TODO: make separate offline files processors when we start supporting nativescript
        if (_everlive2.default.isDesktop || _everlive2.default.isNativeScript) {
            //we will not support files in desktop and nativescript, only their metadata
            return _utils2.default.successfulPromise();
        }

        var self = this;

        if (!isSync) {
            if (isCreate) {
                if (!obj.base64) {
                    return _utils2.default.rejectedPromise(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.missingOrInvalidFileContent));
                }

                if (!obj.ContentType) {
                    return _utils2.default.rejectedPromise(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.missingContentType));
                }
            } else {
                if (!obj.base64) {
                    return _utils2.default.successfulPromise();
                }
            }
        }

        if (!obj.base64) {
            var id = _utils2.default.getId(obj);
            var uri;
            var downloadFilePromise = obj.Uri ? _utils2.default.successfulPromise(obj.Uri) : self._everlive.files.isSync(isSync).applyOffline(false).getDownloadUrlById(id);

            return downloadFilePromise.then(function (_uri) {
                uri = _uri;
                return self._everlive.offlineStorage.files.existsOffline(id);
            }).then(function (exists) {
                if (!exists) {
                    return self._everlive.offlineStorage.files._saveFile(uri, obj.Filename);
                }
            });
        }

        obj.Storage = 'internal';
        return _utils2.default.successfulPromise().then(function () {
            if (!isSync) {
                return self.validateFileCreateObject(obj, isSync);
            }
        }).then(function () {
            var onlineLocation = obj.Uri;
            var filename = self.getFilenameForObject(obj);

            var offlineFileInfo;
            var base64Contents = obj.base64;
            delete obj.base64;

            var contents = _utils2.default.b64toBlob(base64Contents, obj.ContentType);

            return self.writeFile(filename, contents).then(function (fileInfo) {
                offlineFileInfo = fileInfo;
                return self.getOfflineFilesData();
            }).then(function (offlineFilesData) {
                offlineFilesData.push({
                    offlineLocation: offlineFileInfo.offlineLocation,
                    onlineLocation: onlineLocation,
                    id: obj._id
                });

                obj.Length = offlineFileInfo.size;
                return self.saveOfflineFilesData();
            });
        });
    },

    purge: function purge(localLocation) {
        var self = this;

        return this.getOfflineFilesData().then(function (offlineFilesData) {
            var offlineFile = _underscore2.default.where(offlineFilesData, { offlineLocation: localLocation });

            // TODO: [offline] check if the length of offlineFile === 0
            var offlineInfoIndex = offlineFilesData.indexOf(offlineFile[0]);
            if (offlineInfoIndex !== -1) {
                offlineFilesData.splice(offlineInfoIndex, 1);
            }

            return self.saveOfflineFilesData();
        }).then(function () {
            return self.fileStore.getFileByAbsolutePath(localLocation);
        }).then(function (file) {
            if (file) {
                return self.fileStore.removeFile(file);
            }
        });
    },

    writeFile: function writeFile(filename, contents, folder) {
        var self = this;
        var offlineLocation;

        return self.fileStore.writeText(filename, contents, folder).then(function (locationOnDisk) {
            offlineLocation = locationOnDisk;
            return self.saveOfflineFilesData();
        }).then(function () {
            return self.fileStore.getFileSize(filename, folder);
        }).then(function (size) {
            return {
                size: size,
                offlineLocation: offlineLocation
            };
        });
    },

    getFilenameForObject: function getFilenameForObject(obj) {
        var extension = _path2.default.extname(obj.Filename);
        return obj._id + extension;
    },

    getOfflineLocation: function getOfflineLocation(url, id) {
        return this.getOfflineFilesData().then(function (offlineFilesData) {
            if (!url && !id) {
                return;
            }

            for (var i = 0; i < offlineFilesData.length; i++) {
                var fileEntry = offlineFilesData[i];
                var urlMatches = url && (fileEntry.offlineLocation === url || fileEntry.onlineLocation === url);
                var idMatches = id && fileEntry.id === id;
                if (urlMatches || idMatches) {
                    return fileEntry.offlineLocation;
                }
            }
        });
    }
};

module.exports = OfflineFilesProcessor;

},{"../../everlive/EverliveError":58,"../../everlive/everlive.platform":74,"../../everlive/storages/FileStore":106,"../../everlive/utils":121,"path":4,"rsvp":35,"underscore":36}],83:[function(require,module,exports){
'use strict';

var _unsupportedUsersOper;

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _offlineTransformations = require('../../everlive/offline/offlineTransformations');

var _offlineTransformations2 = _interopRequireDefault(_offlineTransformations);

var _ExpandProcessor = require('../../everlive/ExpandProcessor');

var _ExpandProcessor2 = _interopRequireDefault(_ExpandProcessor);

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _EverliveError = require('../../everlive/EverliveError');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _mingo = require('mingo');

var _mingo2 = _interopRequireDefault(_mingo);

var _mongoQuery = require('mongo-query');

var _mongoQuery2 = _interopRequireDefault(_mongoQuery);

var _bsAggregationTranslator = require('../../scripts/bs-aggregation-translator');

var _bsAggregationTranslator2 = _interopRequireDefault(_bsAggregationTranslator);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var unsupportedOfflineHeaders = [_constants.Headers.powerFields];

var unsupportedUsersOperations = (_unsupportedUsersOper = {}, _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.Create, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.Update, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.Delete, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.DeleteById, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.RawUpdate, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.SetAcl, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.SetOwner, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserLoginWithProvider, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserLinkWithProvider, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserUnlinkFromProvider, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserLogin, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserLogout, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserChangePassword, true), _defineProperty(_unsupportedUsersOper, _constants.DataQueryOperations.UserResetPassword, true), _unsupportedUsersOper);

function buildUsersErrorMessage(dataQuery) {
    var unsupportedUserSocialProviderOperations = [_constants.DataQueryOperations.UserLoginWithProvider, _constants.DataQueryOperations.UserLinkWithProvider, _constants.DataQueryOperations.UserUnlinkFromProvider];

    var operation = dataQuery.operation;
    if (unsupportedUserSocialProviderOperations.indexOf(operation) !== -1) {
        operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
    }

    return 'The Users operation ' + operation + ' is not supported in offline mode';
}

function buildFilesErrorMessage(dataQuery) {
    return 'The Files operation ' + dataQuery.operation + ' is not supported in offline mode';
}

function OfflineQueryProcessor(persister, encryptionProvider, offlineFilesProcessor, everlive, setup) {
    this._collectionCache = {};
    this.offlineFilesProcessor = offlineFilesProcessor;
    this._persister = persister;
    this._encryptionProvider = encryptionProvider;
    this.everlive = everlive;
    this.setup = setup;
}

OfflineQueryProcessor.prototype = {
    processQuery: function processQuery(dataQuery) {
        var collectionName = dataQuery.collectionName;
        if (_utils2.default.isContentType.pushDevices(collectionName) || _utils2.default.isContentType.pushNotifications(collectionName)) {
            if (this.everlive.isOnline()) {
                return _utils2.default.successfulPromise();
            } else {
                return _utils2.default.rejectedPromise(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.pushNotSupportedOffline));
            }
        }

        var queryNotSupportedError = this.checkSupportedQuery(dataQuery);
        if (queryNotSupportedError && !dataQuery.isSync) {
            return new _rsvp2.default.Promise(function (resolve, reject) {
                reject(new _EverliveError.EverliveError(queryNotSupportedError));
            });
        }

        var queryParams = dataQuery.getQueryParameters();
        var unsupportedOperators = _utils2.default.getUnsupportedOperators(queryParams.filter);
        var unsupportedOperatorCount = unsupportedOperators.length;
        if (unsupportedOperatorCount) {
            return new _rsvp2.default.Promise(function (resolve, reject) {
                var errorMessage;
                if (unsupportedOperatorCount === 1) {
                    errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                } else {
                    errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                }

                reject(new _EverliveError.EverliveError(errorMessage, _EverliveError.EverliveErrors.operationNotSupportedOffline.code));
            });
        }

        _offlineTransformations2.default.traverseAndTransformFilterId(queryParams.filter);

        switch (dataQuery.operation) {
            case _constants.DataQueryOperations.Read:
                return this.read(dataQuery, queryParams.filter, queryParams.sort, queryParams.skip, queryParams.limit, queryParams.select, queryParams.expand);
            case _constants.DataQueryOperations.ReadById:
                return this.readById(dataQuery, queryParams.expand);
            case _constants.DataQueryOperations.FilesGetDownloadUrlById:
                return this.getDownloadUrlById(dataQuery);
            case _constants.DataQueryOperations.Count:
                return this.count(dataQuery, queryParams.filter);
            case _constants.DataQueryOperations.Create:
                return this.create(dataQuery);
            case _constants.DataQueryOperations.RawUpdate:
            case _constants.DataQueryOperations.Update:
                return this.update(dataQuery, queryParams.filter);
            case _constants.DataQueryOperations.FilesUpdateContent:
                return this.updateFileContent(dataQuery, queryParams.filter);
            case _constants.DataQueryOperations.Delete:
                return this.remove(dataQuery, queryParams.filter);
            case _constants.DataQueryOperations.DeleteById:
                return this.remove(dataQuery, {
                    _id: dataQuery.additionalOptions.id
                });
            case _constants.DataQueryOperations.Aggregate:
                return this.aggregate(dataQuery, queryParams);
            default:
                return new _rsvp2.default.Promise(function (resolve, reject) {
                    if (dataQuery.isSync) {
                        resolve();
                    } else {
                        reject(new _EverliveError.EverliveError(dataQuery.operation + ' is not supported in offline mode.'));
                    }
                });
        }
    },

    getDownloadUrlById: function getDownloadUrlById(dataQuery) {
        var self = this;
        var id = dataQuery.additionalOptions.id;
        var offlineFilePath;
        var fileDirectUri;

        return self.everlive.files.useOffline(true).isSync(dataQuery.isSync).getById(id).then(function (res) {
            var file = res.result;
            fileDirectUri = file.Uri;
            return self.everlive.offlineStorage.files._getFileUrlForId(file.Id, file.Filename);
        }).then(function (filePath) {
            offlineFilePath = filePath;
            return self.everlive.offlineStorage._offlineFilesProcessor.fileStore.getFileByAbsolutePath(filePath);
        }).then(function (fileEntry) {
            return {
                result: {
                    Uri: fileEntry ? offlineFilePath : fileDirectUri
                }
            };
        });
    },

    checkSupportedQuery: function checkSupportedQuery(dataQuery) {
        for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
            var header = unsupportedOfflineHeaders[i];
            if (dataQuery.getHeader(header)) {
                return 'The header ' + header + ' is not supported in offline mode';
            }
        }

        if (_utils2.default.isContentType.users(dataQuery.collectionName) && unsupportedUsersOperations[dataQuery.operation]) {
            return buildUsersErrorMessage(dataQuery);
        }

        if (_utils2.default.isContentType.files(dataQuery.collectionName)) {
            if (dataQuery.operation === _constants.DataQueryOperations.create && Array.isArray(dataQuery.data) || dataQuery.operation === _constants.DataQueryOperations.rawUpdate || dataQuery.operation === _constants.DataQueryOperations.update) {
                return _EverliveError.EverliveErrors.invalidRequest;
            }
        }

        var isSingle = dataQuery.additionalOptions && dataQuery.additionalOptions.id;
        var isUpdateByFilter = dataQuery.operation === _constants.DataQueryOperations.Update && !isSingle;
        var isRawUpdate = dataQuery.operation === _constants.DataQueryOperations.RawUpdate;
        if (_utils2.default.isContentType.files(dataQuery.collectionName) && (isRawUpdate || isUpdateByFilter)) {
            return buildFilesErrorMessage(dataQuery);
        }
    },

    _getCreateResult: function _getCreateResult(createdItems, returnFullItem) {
        if (createdItems.length === 1) {
            var result;
            if (returnFullItem) {
                var item = _underscore2.default.extend({}, createdItems[0]);
                result = _offlineTransformations2.default.idTransform(item);
            } else {
                result = {
                    CreatedAt: _utils2.default.cloneDate(createdItems[0].CreatedAt),
                    Id: createdItems[0]._id
                };
            }

            return {
                result: result
            };
        } else {
            var multipleCreateResult = [];
            _underscore2.default.each(createdItems, function (createdItem) {
                var item;
                if (returnFullItem) {
                    var itemCopy = _underscore2.default.extend({}, createdItem);
                    item = _offlineTransformations2.default.idTransform(itemCopy);
                } else {
                    item = {
                        CreatedAt: _utils2.default.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    };
                }
                multipleCreateResult.push(item);
            });

            return {
                result: multipleCreateResult
            };
        }
    },

    create: function create(dataQuery) {
        var self = this;

        return self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState).then(function (createdItems) {
            var isFilesQuery = _utils2.default.isContentType.files(dataQuery.collectionName);
            return self._getCreateResult(createdItems, isFilesQuery);
        });
    },

    read: function read(dataQuery, filter, sort, skip, limit, select, expand) {
        var self = this;
        var expandResult;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var collectionLength;

            self._prepareExpand(expand, dataQuery, true).then(function (prepareExpandResult) {
                expandResult = prepareExpandResult;
                if (prepareExpandResult) {
                    select = prepareExpandResult.mainQueryFieldsExpression;
                }

                return self._getCollection(dataQuery.collectionName);
            }).then(function (collection) {
                var result = self._readInternal(collection, filter, sort, skip, limit, select);

                if (skip || limit) {
                    var all = self._readInternal(collection);
                    collectionLength = all.length;
                }

                if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
                    result = _offlineTransformations2.default.removeIdTransform(result, true);
                } else {
                    result = _offlineTransformations2.default.idTransform(result);
                }

                return self._expandResult(expandResult, result);
            }).then(function (result) {
                var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                resolve(response);
            }).catch(reject);
        });
    },

    _readInternal: function _readInternal(collection, filter, sort, skip, limit, select) {
        var filterCopy = _underscore2.default.extend({}, filter);
        var actualFilter = this._getWithoutDeletedFilter(filterCopy);
        _offlineTransformations2.default.traverseAndTransformFilterId(actualFilter);
        var query = _mingo2.default.Query(actualFilter);
        var cursor = _mingo2.default.Cursor(collection, query, select);
        if (sort) {
            cursor = cursor.sort(sort);
        }

        if (skip) {
            cursor.skip(skip);
        }

        if (limit) {
            cursor.limit(limit);
        }

        return _underscore2.default.map(cursor.all(), function (item) {
            return _underscore2.default.extend({}, item);
        });
    },

    readById: function readById(dataQuery, expand) {
        var self = this;
        var expandResult;
        return self._prepareExpand(expand, dataQuery, false).then(function (prepareExpandResult) {
            expandResult = prepareExpandResult;
            return self._getCollection(dataQuery.collectionName);
        }).then(function (collection) {
            return new _rsvp2.default.Promise(function (resolve, reject) {
                var item = self._getById(collection, dataQuery.additionalOptions.id);

                if (!item) {
                    return reject(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.itemNotFound));
                }

                item = _offlineTransformations2.default.idTransform(item);
                return self._expandResult(expandResult, item).then(resolve).catch(reject);
            });
        }).then(function (result) {
            return self._transformOfflineResult(result, null, dataQuery);
        });
    },

    _getById: function _getById(collection, id) {
        if (!id) {
            throw new _EverliveError.EverliveError('Id field is mandatory when using offline storage');
        }

        if (collection[id]) {
            var item = _underscore2.default.extend({}, collection[id]);
            var isDeleted = item && item[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.deleted;

            return isDeleted ? undefined : item;
        }
    },

    _prepareExpand: function _prepareExpand(expand, dataQuery, isArray) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            if (expand) {
                _ExpandProcessor2.default.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = _EverliveError.EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(prepareResult);
                });
            } else {
                resolve();
            }
        });
    },

    _expandResult: function _expandResult(prepareExpandResult, result) {
        var self = this;
        return new _rsvp2.default.Promise(function (resolve, reject) {
            if (prepareExpandResult) {
                _ExpandProcessor2.default.expand(prepareExpandResult.relationsTree, result, {
                    offlineModule: self
                }, function (err, result) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = _EverliveError.EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(result);
                });
            } else {
                resolve(result);
            }
        });
    },

    _getWithoutDeletedFilter: function _getWithoutDeletedFilter(filter) {
        var withoutDeletedFilter = {
            $and: []
        };
        withoutDeletedFilter.$and.push(filter);
        var deleteOfflineFilter = {};
        deleteOfflineFilter[_constants2.default.offlineItemsStateMarker] = { $ne: _constants.offlineItemStates.deleted };
        withoutDeletedFilter.$and.push(deleteOfflineFilter);
        return withoutDeletedFilter;
    },

    _getUpdateItemsResult: function _getUpdateItemsResult(updateItems) {
        var updatedItemCount = updateItems.length;
        var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();

        return {
            ModifiedAt: modifiedAtResult,
            result: updatedItemCount
        };
    },

    update: function update(dataQuery, filter) {
        var self = this;

        return this._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync).then(function (updateItems) {
            return self._getUpdateItemsResult(updateItems);
        });
    },

    remove: function remove(dataQuery, filter) {
        return this._removeItems(dataQuery, filter, dataQuery.isSync);
    },

    count: function count(dataQuery, filter) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            self._getCollection(dataQuery.collectionName).then(function (collection) {
                var filterResult = self._readInternal(collection, filter);
                resolve({ result: filterResult.length });
            }).catch(reject);
        });
    },

    _setItemDates: function _setItemDates(currentItem, itemToCreate, contentType) {
        // we need to manually clone the dates in order to dereference them from the original object as
        // _.extends will pass a reference to the original date instead of creating a new instance
        if (_utils2.default.isDate(currentItem.CreatedAt)) {
            itemToCreate.CreatedAt = _utils2.default.cloneDate(currentItem.CreatedAt);
        } else {
            itemToCreate.CreatedAt = new Date();
        }

        if (_utils2.default.isDate(currentItem.ModifiedAt)) {
            itemToCreate.ModifiedAt = _utils2.default.cloneDate(currentItem.ModifiedAt);
        } else {
            itemToCreate.ModifiedAt = _utils2.default.cloneDate(itemToCreate.CreatedAt);
        }

        itemToCreate.CreatedBy = itemToCreate.CreatedBy || this.everlive.setup.principalId || _constants2.default.guidEmpty;
        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
        if (contentType === 'Users') {
            itemToCreate.Owner = itemToCreate._id;
        } else {
            itemToCreate.Owner = itemToCreate.CreatedBy || _constants2.default.guidEmpty;
        }
    },

    _mapCreateItem: function _mapCreateItem(currentItem, collection, isSync, preserveState, contentType) {
        var self = this;

        var itemToCreate = _underscore2.default.extend({}, currentItem);
        itemToCreate._id = itemToCreate.Id || _utils2.default.uuid();
        delete itemToCreate.Id;

        var existingItem = self._getById(collection, itemToCreate._id);
        var itemExists = !!existingItem;
        var state;
        if (itemExists && !isSync && !preserveState) {
            // TODO: [offline] return the same error as the server does
            throw new _EverliveError.EverliveError('An item with the specified id already exists');
        } else {
            if (isSync && preserveState && itemExists) {
                state = existingItem[_constants2.default.offlineItemsStateMarker];
            } else {
                state = isSync ? undefined : _constants.offlineItemStates.created; // set the state to created only if not syncing
            }
        }

        function processItemResult() {
            self._setItemDates(currentItem, itemToCreate, contentType);
            self._setItem(collection, _underscore2.default.extend({}, itemToCreate), state);
            return itemToCreate;
        }

        if (_utils2.default.isContentType.files(contentType)) {
            return self.offlineFilesProcessor.upsertFileFromObject(itemToCreate, true, isSync).then(processItemResult);
        } else {
            return processItemResult();
        }
    },

    _createItems: function _createItems(contentType, items, isSync, preserveState) {
        var self = this;
        return this._getCollection(contentType).then(function (collection) {
            var itemsForCreate = _underscore2.default.isArray(items) ? items : [items];
            var createdItems = _underscore2.default.map(itemsForCreate, function (currentItem) {
                return self._mapCreateItem(currentItem, collection, isSync, preserveState, contentType);
            });

            return _rsvp2.default.all(createdItems).then(function (items) {
                return self._persistData(contentType).then(function () {
                    // Ids are generated regardless of the autoGenerateId option. However the Id's are omitted when returning
                    // the items to the client if autoGenerateId is false
                    if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
                        createdItems = _offlineTransformations2.default.removeIdTransform(items);
                    }

                    return items;
                });
            });
        });
    },

    _applyUpdateOperation: function _applyUpdateOperation(originalUpdateExpression, itemToUpdate, collection, isSync, modifiedAt) {
        var dbOperators = _utils2.default.getDbOperators(originalUpdateExpression, true);
        var hasDbOperator = dbOperators.length !== 0;

        var updateExpression;
        if (hasDbOperator) {
            updateExpression = originalUpdateExpression;
        } else {
            updateExpression = {
                $set: originalUpdateExpression
            };
        }
        var updateExpressionForUser = {
            ModifiedBy: this.everlive.setup.principalId || _constants2.default.guidEmpty
        };
        updateExpression.$set = _underscore2.default.extend(updateExpressionForUser, updateExpression.$set);

        if (isSync) {
            updateExpression.$set.ModifiedAt = _utils2.default.cloneDate(originalUpdateExpression.ModifiedAt || modifiedAt);
        }

        (0, _mongoQuery2.default)(itemToUpdate, {}, updateExpression, { strict: true }); // Setting strict to true so only exact matches would be updated

        itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
        delete itemToUpdate.Id;

        var newState;
        if (isSync) {
            newState = undefined;
        } else if (itemToUpdate[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.created) {
            newState = _constants.offlineItemStates.created;
        } else {
            newState = _constants.offlineItemStates.modified;
        }

        this._setItem(collection, itemToUpdate, newState);
    },

    updateFileContent: function updateFileContent(dataQuery) {
        if (_everlive2.default.isDesktop) {
            return _utils2.default.successfulPromise();
        }

        var isSync = dataQuery.isSync;
        var updateExpression = dataQuery.data;
        var self = this;
        var itemId = dataQuery.additionalOptions.id;
        var updateItems;
        var typeName = dataQuery.collectionName;
        return this._getCollection(typeName).then(function (collection) {
            var singleItemForUpdate = self._getById(collection, itemId);
            updateItems = [singleItemForUpdate];
            singleItemForUpdate.base64 = updateExpression.base64;
            singleItemForUpdate.Filename = updateExpression.Filename;
            singleItemForUpdate.ContentType = updateExpression.ContentType;
            delete singleItemForUpdate.Uri;

            return self._overwriteFile(itemId, singleItemForUpdate, isSync).then(function () {
                self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection);
                self._setItem(collection, singleItemForUpdate, _constants2.default.offlineItemStates.modified);
                return self._persistData(typeName);
            }).then(function () {
                return self._getUpdateItemsResult(updateItems);
            });
        });
    },

    _overwriteFile: function _overwriteFile(itemId, itemForUpdate, isSync) {
        var self = this;

        return self.everlive.offlineStorage.files.purge(itemId).then(function () {
            return self.offlineFilesProcessor.upsertFileFromObject(itemForUpdate, true, isSync);
        });
    },

    _updateItems: function _updateItems(dataQuery, updateExpression, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName).then(function (collection) {
            var updateItems;

            if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                var itemId = dataQuery.additionalOptions.id;
                var singleItemForUpdate = self._getById(collection, itemId);
                if (!singleItemForUpdate) {
                    throw new _EverliveError.EverliveError(_EverliveError.EverliveErrors.itemNotFound, 'Item with id :' + itemId + ' does not exist offline in the collection :' + collectionName);
                }

                updateItems = [singleItemForUpdate];

                if (_utils2.default.isContentType.files(collectionName) && updateExpression.$set && updateExpression.$set.Filename || updateExpression.Filename) {
                    var filename = updateExpression.Filename || updateExpression.$set.Filename;
                    var extension = _path2.default.extname(filename);
                    return self.everlive.offlineStorage.files.changeFileExtensionById(itemId, extension).then(function () {
                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                        return self._persistData(collectionName);
                    }).then(function () {
                        return updateItems;
                    });
                } else {
                    self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                }
            } else {
                updateItems = self._readInternal(collection, filter);
                for (var i = 0; i < updateItems.length; i++) {
                    var itemToUpdate = updateItems[i];
                    var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                    if (!itemExists && !isSync) {
                        // TODO: [offline] return the correct error
                        throw new _EverliveError.EverliveError(_EverliveError.EverliveErrors.itemNotFound);
                    }

                    self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync, dataQuery.ModifiedAt);
                }
            }

            return self._persistData(collectionName).then(function () {
                return updateItems;
            });
        });
    },

    _getAllCollections: function _getAllCollections() {
        var self = this;
        return new _rsvp2.default.Promise(function (resolve, reject) {
            self._persister.getAllData(function (allData) {
                _underscore2.default.each(allData, function (value, key) {
                    var decryptedData = self._encryptionProvider.decrypt(value);
                    allData[key] = JSON.parse(decryptedData || '{}', _utils2.default.parseUtilities.getReviver());
                });

                resolve(allData);
            }, reject);
        });
    },

    _getCollection: function _getCollection(contentType) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            // check the persister if there is no data in the collection cache for this content type
            if (!self._collectionCache[contentType]) {
                self._persister.getData(contentType, function (data) {
                    var decryptedDataRaw = self._encryptionProvider.decrypt(data);
                    var decryptedData = JSON.parse(decryptedDataRaw || '{}', _utils2.default.parseUtilities.getReviver());
                    self._collectionCache[contentType] = decryptedData;

                    resolve(self._collectionCache[contentType]);
                }, reject);
            } else {
                resolve(self._collectionCache[contentType]);
            }
        });
    },

    _setItem: function _setItem(collection, item, state) {
        if (!state) {
            delete item[_constants2.default.offlineItemsStateMarker];
        } else {
            item[_constants2.default.offlineItemsStateMarker] = state;
        }

        collection[item._id] = item;
    },

    _getDirtyItems: function _getDirtyItems(collection) {
        var filter = {};
        filter[_constants2.default.offlineItemsStateMarker] = { $exists: true };
        var query = _mingo2.default.Query(filter);
        var cursor = _mingo2.default.Cursor(collection, query);
        return cursor.all();
    },

    _persistData: function _persistData(contentType) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var contentTypeData = self._collectionCache[contentType] || {};
            self._transformPersistedData(contentType, contentTypeData);
            var contentTypeDataRaw = JSON.stringify(contentTypeData);
            var contentTypeDataRawEncrypted = self._encryptionProvider.encrypt(contentTypeDataRaw);
            self._persister.saveData(contentType, contentTypeDataRawEncrypted, resolve, reject);
        });
    },

    _shouldAutogenerateIdForContentType: function _shouldAutogenerateIdForContentType(contentType) {
        return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
    },

    _clearItem: function _clearItem(collection, item) {
        delete collection[item._id];
    },

    _mapRemoveItem: function _mapRemoveItem(itemToRemove, collection, isSync, collectionName) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            //we cannot remove files while in desktop mode
            if (_utils2.default.isContentType.files(collectionName) && !_everlive2.default.isDesktop) {
                return self.everlive.offlineStorage.files.purge(itemToRemove._id).then(resolve, reject);
            } else {
                return resolve();
            }
        }).then(function () {
            itemToRemove._id = itemToRemove._id || itemToRemove.Id;

            var itemExists = !!self._getById(collection, itemToRemove._id.toString());
            if (!itemExists && !isSync) {
                throw new _EverliveError.EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.');
            }

            // if the item has existed only offline or the data is syncing
            // and the item was deleted by the conflict resolution strategy
            var removeFromMemory = itemToRemove[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.created || isSync;
            if (removeFromMemory) {
                self._clearItem(collection, itemToRemove);
            } else {
                self._setItem(collection, itemToRemove, _constants.offlineItemStates.deleted);
            }
        });
    },

    _removeItems: function _removeItems(dataQuery, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName).then(function (collection) {
            var itemsToRemove = self._readInternal(collection, filter);

            var removedItemsPromises = _underscore2.default.map(itemsToRemove, function (itemToRemove) {
                return self._mapRemoveItem(itemToRemove, collection, isSync, collectionName);
            });

            return _rsvp2.default.all(removedItemsPromises);
        }).then(function (itemsToRemove) {
            return self._persistData(collectionName).then(function () {
                return itemsToRemove;
            });
        }).then(function (itemsToRemove) {
            return self._transformOfflineResult(itemsToRemove.length);
        });
    },

    _applyTransformations: function _applyTransformations(transformedResult, transformations) {
        if (Array.isArray(transformedResult.result)) {
            _underscore2.default.each(transformations, function (transformation) {
                transformedResult.result.map(function (value, key) {
                    transformedResult.result[key] = transformation(value);
                });
            });
        } else {
            _underscore2.default.each(transformations, function (transformation) {
                transformedResult.result = transformation(transformedResult.result);
            });
        }
    },

    _transformOfflineResult: function _transformOfflineResult(resultSet, count, dataQuery, additionalTransformations) {
        var transformedResult = {
            result: resultSet,
            count: count || (resultSet || []).length
        };

        if (count !== undefined && count !== null || Array.isArray(resultSet)) {
            transformedResult.count = count || resultSet.length;
        }

        var transformations = [];

        transformations.push(_offlineTransformations2.default.idTransform);
        transformations.push(_offlineTransformations2.default.removeMarkersTransform);

        if (dataQuery) {
            var includeCount = dataQuery.getHeader(_constants.Headers.includeCount);
            if (includeCount === false) {
                delete transformedResult.count;
            }

            var singleFieldExpression = dataQuery.getHeader(_constants.Headers.singleField);
            if (typeof singleFieldExpression === 'string') {
                transformations.push(_offlineTransformations2.default.singleFieldTransform.bind(this, singleFieldExpression));
            }
        }

        if (additionalTransformations) {
            transformations = transformations.concat(additionalTransformations);
        }

        this._applyTransformations(transformedResult, transformations);

        if (transformedResult.count === undefined) {
            delete transformedResult.count;
        }

        return transformedResult;
    },

    _transformPersistedData: function _transformPersistedData(contentType, contentTypeData) {
        var transformFields = [];

        if (contentType === 'Users') {
            transformFields = transformFields.concat(['Password', 'SecretQuestionId', 'SecretAnswer']);
        }

        if (transformFields.length) {
            _underscore2.default.each(contentTypeData, function (contentTypeObject) {
                _offlineTransformations2.default.removeFieldsTransform(contentTypeObject, transformFields);
            });
        }
    },

    aggregate: function aggregate(dataQuery, queryParams) {
        var self = this;

        return this._getCollection(dataQuery.collectionName).then(function (collection) {
            if (!queryParams || !queryParams.aggregate || _underscore2.default.isEmpty(queryParams.aggregate)) {
                throw new _EverliveError.EverliveError('You must specify a valid aggregation definition. Either GroupBy or Aggregate is required.');
            }

            var aggregationQuery = _underscore2.default.extend({}, queryParams.aggregate);
            aggregationQuery.Filter = queryParams.filter;

            var translatedPipeline = _bsAggregationTranslator2.default.translate(aggregationQuery, {
                maxDocumentsCount: _constants2.default.Aggregation.MaxDocumentsCount
            });

            var collectionWithoutDeleted = _underscore2.default.filter(collection, function (item) {
                return item[_constants2.default.offlineItemsStateMarker] !== _constants2.default.offlineItemStates.deleted;
            });

            var result = _mingo2.default.aggregate(collectionWithoutDeleted, translatedPipeline);
            return self._transformOfflineResult(result, null, dataQuery);
        });
    },

    purgeAll: function purgeAll(success, error) {
        var self = this;
        this._collectionCache = {};
        return (0, _utils.buildPromise)(function (success, error) {
            self._collectionCache = {};

            self._persister.purgeAll(function () {
                if (self.everlive.setup.caching) {
                    self.everlive.cache.clearAll(success, error);
                } else {
                    success();
                }
            }, error);
        }, success, error);
    },

    purge: function purge(contentType, success, error) {
        var self = this;
        return (0, _utils.buildPromise)(function (success, error) {
            delete self._collectionCache[contentType];

            self._persister.purge(contentType, function () {
                if (self.everlive.setup.caching) {
                    self.everlive.cache.clear(contentType, success, error);
                } else {
                    success();
                }
            }, error);
        }, success, error);
    }
};

module.exports = OfflineQueryProcessor;

},{"../../everlive/EverliveError":58,"../../everlive/ExpandProcessor":59,"../../everlive/constants":70,"../../everlive/everlive.platform":74,"../../everlive/offline/offlineTransformations":87,"../../everlive/utils":121,"../../scripts/bs-aggregation-translator":123,"mingo":13,"mongo-query":15,"path":4,"rsvp":35,"underscore":36}],84:[function(require,module,exports){
'use strict';

var _DataQuery = require('../../everlive/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _EverliveError = require('../../everlive/EverliveError');

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _RequestOptionsBuilder = require('../../everlive/query/RequestOptionsBuilder');

var _RequestOptionsBuilder2 = _interopRequireDefault(_RequestOptionsBuilder);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _Request = require('../../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

var _offlineTransformations = require('../../everlive/offline/offlineTransformations');

var _offlineTransformations2 = _interopRequireDefault(_offlineTransformations);

var _OfflineQueryProcessor = require('../../everlive/offline/OfflineQueryProcessor');

var _OfflineQueryProcessor2 = _interopRequireDefault(_OfflineQueryProcessor);

var _OfflineFilesProcessor = require('../../everlive/offline/OfflineFilesProcessor');

var _OfflineFilesProcessor2 = _interopRequireDefault(_OfflineFilesProcessor);

var _OfflineFilesModule = require('../../everlive/offline/OfflineFilesModule');

var _OfflineFilesModule2 = _interopRequireDefault(_OfflineFilesModule);

var _Query = require('../../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _RequestService = require('../../everlive/services/RequestService');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var syncLocation = {
    server: 'server',
    client: 'client'
};

/**
 * @class OfflineModule
 * @classDesc A class providing access to the various offline storage features.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} offlineStorage
 */

module.exports = function () {
    function OfflineModule(everlive, options, persister, encryptionProvider) {
        this._everlive = everlive;
        this.setup = options;
        this._isSynchronizing = false;
        this._encryptionProvider = encryptionProvider;

        this._offlineFilesProcessor = new _OfflineFilesProcessor2.default(this.setup, this._everlive);
        this._queryProcessor = new _OfflineQueryProcessor2.default(persister, encryptionProvider, this._offlineFilesProcessor, this._everlive, this.setup);

        /**
         * @memberOf OfflineModule.prototype
         * @instance
         * @description An instance of the [OfflineFilesModule]{@link OfflineFilesModule} class for working with files in offline mode.
         * @member {OfflineFilesModule} files
         */
        this.files = new _OfflineFilesModule2.default(this._offlineFilesProcessor, this._everlive, this.setup.files.maxConcurrentDownloads);
    }

    var getSyncFilterForItem = function getSyncFilterForItem(item) {
        var filter = getSyncFilterNoModifiedAt(item);
        filter.ModifiedAt = item.ModifiedAt;
        return filter;
    };

    var getSyncFilterNoModifiedAt = function getSyncFilterNoModifiedAt(item) {
        return {
            Id: item.Id
        };
    };

    OfflineModule.prototype = {
        /**
         * Removes all data from the offline storage. If caching is enabled clears the entire cache as well.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data from the offline storage. If caching is enabled clears the entire cache as well.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @returns {Promise}
         */
        purgeAll: function purgeAll(success, error) {
            return this._queryProcessor.purgeAll(success, error);
        },

        /**
         * Removes all data for a specific content type from the offline storage. If caching is enabled clears the cache
         * for the specified content type as well.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data for a specific content type from the offline storage. If caching is enabled clears the cache
         * for the specified content type as well.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @returns {Promise}
         */
        purge: function purge(contentType, success, error) {
            return this._queryProcessor.purge(contentType, success, error);
        },

        processQuery: function processQuery(query) {
            return this._queryProcessor.processQuery(query);
        },

        _setOffline: function _setOffline(offline) {
            this.setup.offline = offline;
        },

        isOnline: function isOnline() {
            return !this.setup.offline;
        },

        _prepareSyncData: function _prepareSyncData(contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _underscore2.default.each(contentTypesForSync, function (contentType, typeName) {
                var syncItems = _offlineTransformations2.default.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function _resolveConflicts(syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts).then(function () {
                return self._mergeResolvedConflicts(syncData.conflicts, syncData.contentTypesSyncData);
            }).then(function () {
                return syncData.contentTypesSyncData;
            });
        },

        isSynchronizing: function isSynchronizing() {
            return this._isSynchronizing;
        },

        _fireSyncStart: function _fireSyncStart() {
            var self = this;

            return new _rsvp2.default.Promise(function (resolve) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self._everlive._emitter.emit(_constants2.default.Events.SyncStart);
                    resolve();
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function _fireSyncEnd() {
            this._isSynchronizing = false;
            this._everlive._emitter.emit(_constants2.default.Events.SyncEnd, this._syncResultInfo);
            delete this._syncResultInfo;
        },

        _eachSyncItem: function _eachSyncItem(items, getFilterFunction, contentTypeName, operation) {
            var self = this;

            _underscore2.default.each(items, function (item) {
                var itemFilter = getFilterFunction(item.remoteItem);
                // if we already have an error for this item we do not want to try and sync it again
                var resultItem = item.resultingItem;
                var isCustom = item.isCustom;
                var resolutionType = item.resolutionType;
                if (_underscore2.default.some(self._syncResultInfo.failedItems[contentTypeName], {
                    itemId: resultItem.Id
                })) {
                    return;
                }

                operation(resultItem, itemFilter, isCustom, resolutionType);
            });
        },

        _shouldAutogenerateIdForContentType: function _shouldAutogenerateIdForContentType(collectionName) {
            return this._queryProcessor._shouldAutogenerateIdForContentType(collectionName);
        },

        _addCreatedFileToSyncPromises: function _addCreatedFileToSyncPromises(resultingItemsForCreate, syncPromises, collectionName) {
            var self = this;

            _underscore2.default.each(resultingItemsForCreate, function (item) {
                var filesCollection = self._everlive.files;
                syncPromises[item.Id] = new _rsvp2.default.Promise(function (resolve, reject) {
                    self.files.getOfflineLocation(item.Id).then(function (location) {
                        if (location) {
                            return self._transferFile(false, item, location);
                        }
                    }, function (err) {
                        reject({
                            type: _constants.offlineItemStates.created,
                            items: item,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        });
                    }).then(function (res) {
                        var mergedWithServerResponseItem = _underscore2.default.extend({}, item, res.result);
                        self._onItemProcessed(mergedWithServerResponseItem, collectionName, syncLocation.server, _constants.offlineItemStates.created);
                        return filesCollection.isSync(true).useOffline(true).updateSingle(mergedWithServerResponseItem);
                    }, function (err) {
                        reject({
                            type: _constants.offlineItemStates.created,
                            items: item,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        });
                    }).then(resolve, function (err) {
                        reject({
                            type: _constants.offlineItemStates.modified,
                            items: item,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.client
                        });
                    });
                });
            });
        },

        _transferFile: function _transferFile(isUpdate, item, location) {
            var sdk = this._everlive;

            return new _rsvp2.default.Promise(function (resolve, reject) {
                var self = this;
                var uploadUrl = sdk.files.getUploadUrl();
                var fileExistsPromise = _utils2.default.successfulPromise();

                if (isUpdate) {
                    fileExistsPromise = new _rsvp2.default.Promise(function (resolve) {
                        sdk.files.isSync(true).applyOffline(false).getById(item.Id).then(function () {
                            resolve(true);
                        }).catch(function () {
                            resolve(false);
                        });
                    });
                }

                fileExistsPromise.then(function (fileExistsOnServer) {
                    var canUpdate = isUpdate && fileExistsOnServer;
                    if (canUpdate) {
                        uploadUrl += '/' + item.Id + '/Content';
                    }

                    var fileTransfer = new FileTransfer();
                    var fileKey = _constants2.default.fileUploadKey;
                    var options = {
                        fileKey: fileKey,
                        httpMethod: canUpdate ? 'PUT' : 'POST',
                        mimeType: item.ContentType,
                        fileName: item.Filename,
                        headers: sdk.buildAuthHeader()
                    };

                    options.params = {};

                    _underscore2.default.each(item, function (value, key) {
                        if (key.toLowerCase() !== 'base64') {
                            var prefixedKey = _constants2.default.fileUploadKey + _constants2.default.fileUploadDelimiter + key;
                            options.params[prefixedKey] = value;
                        }
                    });

                    fileTransfer.upload(location, uploadUrl, function (result) {
                        var parsedResult = _utils2.default.parseUtilities.parseJSON(result.response);
                        if (parsedResult.Result === false) {
                            reject.apply(self, arguments);
                        } else if (_underscore2.default.isArray(parsedResult.Result)) {
                            resolve({
                                result: parsedResult.Result[0]
                            });
                        } else {
                            resolve(parsedResult);
                        }
                    }, reject, options, true);
                });
            });
        },

        _addCreatedObjectToSyncPromises: function _addCreatedObjectToSyncPromises(syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids) {
            var self = this;

            var promise = new _rsvp2.default.Promise(function (resolve, reject) {
                dataCollection.isSync(true).applyOffline(false).create(resultingItemsForCreate).then(function (res) {
                    resultingItemsForCreate = _underscore2.default.map(resultingItemsForCreate, function (item, index) {
                        item.Id = res.result[index].Id;
                        item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
                        var resultingItem = _underscore2.default.find(contentTypeData.createdItems, function (createdItem) {
                            return createdItem.resultingItem.Id === item.Id;
                        });

                        if (resultingItem.isCustom) {
                            self._onItemProcessed(item, collectionName, syncLocation.client, _constants.offlineItemStates.modified);
                        }

                        return item;
                    });
                }, function (err) {
                    throw {
                        type: _constants.offlineItemStates.created,
                        items: resultingItemsForCreate,
                        contentType: collectionName,
                        error: err,
                        storage: syncLocation.server
                    };
                }).then(function () {
                    return dataCollection.isSync(true).useOffline(true).create(resultingItemsForCreate).then(function () {
                        _underscore2.default.each(resultingItemsForCreate, function (createdItem) {
                            self._onItemProcessed(createdItem, collectionName, syncLocation.server, _constants.offlineItemStates.created);
                        });
                    }, function (err) {
                        throw {
                            type: _constants.offlineItemStates.created,
                            items: resultingItemsForCreate,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.client
                        };
                    });
                }).then(function () {
                    if (ids && ids.length) {
                        var filter = {
                            Id: {
                                $in: ids
                            }
                        };
                        return dataCollection.isSync(true).useOffline(true).destroy(filter).catch(function (err) {
                            throw {
                                type: _constants.offlineItemStates.created,
                                items: resultingItemsForCreate,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.client
                            };
                        });
                    }
                }).then(resolve).catch(function (err) {
                    reject(err);
                });
            });

            _underscore2.default.each(resultingItemsForCreate, function (item) {
                syncPromises[item.Id] = promise;
            });

            return resultingItemsForCreate;
        },

        _addCreatedItemsForSync: function _addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection) {
            var collectionName = dataCollection.collectionName;

            var resultingItemsForCreate = _underscore2.default.pluck(contentTypeData.createdItems, 'resultingItem');
            var ids;
            if (!this._shouldAutogenerateIdForContentType(collectionName)) {
                ids = _underscore2.default.pluck(resultingItemsForCreate, 'Id');
                resultingItemsForCreate = _offlineTransformations2.default.removeIdTransform(resultingItemsForCreate);
            }

            if (_utils2.default.isContentType.files(collectionName)) {
                return this._addCreatedFileToSyncPromises(resultingItemsForCreate, syncPromises, collectionName);
            } else {
                return this._addCreatedObjectToSyncPromises(syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids);
            }
        },

        _addUpdatedItemsForSync: function _addUpdatedItemsForSync(contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
            var self = this;
            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
        },

        _addDeletedItemsForSync: function _addDeletedItemsForSync(contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
            var self = this;

            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
        },

        _onSyncResponse: function _onSyncResponse(res, item, collectionName, operation, isCustomItem) {
            var self = this;

            if (res.result !== 1) {
                return new _rsvp2.default.Promise(function (resolve, reject) {
                    reject(_underscore2.default.extend({}, _EverliveError.EverliveErrors.syncConflict, {
                        contentType: collectionName
                    }));
                });
            } else {
                if (operation === _DataQuery2.default.operations.Update) {
                    self._onItemProcessed(item, collectionName, syncLocation.server, _constants.offlineItemStates.modified);
                    var updatedItem = _underscore2.default.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    //TODO: use the new way of building DataQueries

                    var updateQuery = new _DataQuery2.default({
                        operation: operation,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        meta: {
                            collectionName: collectionName
                        },
                        isSync: true
                    });

                    return this.processQuery(updateQuery).then(function () {
                        if (isCustomItem) {
                            var existingItem = _underscore2.default.find(self._syncResultInfo.syncedItems[collectionName], function (syncedItem) {
                                return syncedItem.itemId === item.Id;
                            });

                            if (!existingItem) {
                                self._onItemProcessed(item, collectionName, syncLocation.client, _constants.offlineItemStates.modified);
                            }
                        }
                    });
                } else if (operation === _DataQuery2.default.operations.Delete) {
                    self._onItemProcessed(item, collectionName, syncLocation.server, _constants.offlineItemStates.deleted);
                    return this._purgeById(collectionName, item.Id).then(function () {
                        if (isCustomItem) {
                            self._onItemProcessed(item, collectionName, syncLocation.client, _constants.offlineItemStates.deleted);
                        }
                    });
                }
            }
        },

        _purgeById: function _purgeById(contentType, itemId) {
            var self = this;

            return this._queryProcessor._getCollection(contentType).then(function (collection) {
                delete collection[itemId];
                return self._queryProcessor._persistData(contentType);
            });
        },

        sync: function sync() {
            var self = this;
            self._syncResultInfo = self._syncResultInfo || {
                syncedItems: {},
                syncedToServer: 0,
                syncedToClient: 0,
                failedItems: {},
                error: undefined // added for visibility
            };

            if (!this.isOnline()) {
                throw new _EverliveError.EverliveError('Cannot synchronize while offline');
            }

            self._fireSyncStart().then(function () {
                return self._applySync();
            }).then(function (syncResults) {
                var conflictsWhileSync = [];
                _underscore2.default.each(syncResults, function (syncResult, itemId) {
                    if (syncResult && syncResult.state === 'rejected') {
                        if (syncResult.reason && syncResult.reason.code === _EverliveError.EverliveErrors.syncConflict.code) {
                            conflictsWhileSync.push(syncResult);
                        } else {
                            // to save time and traffic we are using a single create request for all items
                            // this is why if there is an error we need to split the items we tried to create
                            // and set the same error for all items.
                            self._onItemFailed(syncResult, itemId);
                        }
                    }
                });

                if (conflictsWhileSync.length) {
                    return self.sync();
                } else {
                    self._fireSyncEnd();
                }
            }).catch(function (err) {
                if (!err) {
                    err = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncErrorUnknown);
                }
                self._syncResultInfo.error = err;
                self._fireSyncEnd();
            });
        },

        _handleKeepServer: function _handleKeepServer(typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData) {
            var self = this;

            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new _DataQuery2.default({
                    meta: {
                        collectionName: typeName
                    },
                    operation: _DataQuery2.default.operations.Update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new _DataQuery2.default({
                    meta: {
                        collectionName: typeName
                    },
                    operation: _DataQuery2.default.operations.Create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new _DataQuery2.default({
                    meta: {
                        collectionName: typeName
                    },
                    operation: _DataQuery2.default.operations.DeleteById,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new _EverliveError.EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(new _rsvp2.default.Promise(function (resolve, reject) {
                self.processQuery(syncQuery).then(function () {
                    switch (syncQuery.operation) {
                        case _DataQuery2.default.operations.Update:
                            self._onItemProcessed(serverItem, typeName, syncLocation.client, _constants.offlineItemStates.modified);
                            // the files content type is special and needs to enable the file contents offline, so we cannot only
                            // update the data
                            if (_utils2.default.isContentType.files(typeName)) {
                                contentTypeSyncData.modifiedItems.push({
                                    remoteItem: conflictingItem.serverItem,
                                    resultingItem: serverItem,
                                    resolutionType: _constants2.default.ConflictResolution.KeepServer
                                });
                            }
                            break;
                        case _DataQuery2.default.operations.Create:
                            self._onItemProcessed(serverItem, typeName, syncLocation.client, _constants.offlineItemStates.created);
                            break;
                        case _DataQuery2.default.operations.DeleteById:
                            self._onItemProcessed(clientItem, typeName, syncLocation.client, _constants.offlineItemStates.deleted);
                            break;
                    }
                    resolve();
                }, function (err) {
                    var itemId;
                    var operation;
                    switch (syncQuery.operation) {
                        case _DataQuery2.default.operations.Update:
                            itemId = serverItem.Id;
                            operation = _constants.offlineItemStates.modified;
                            break;
                        case _DataQuery2.default.operations.Create:
                            itemId = serverItem.Id;
                            operation = _constants.offlineItemStates.created;
                            break;
                        case _DataQuery2.default.operations.DeleteById:
                            itemId = clientItem.Id;
                            operation = _constants.offlineItemStates.deleted;
                            break;
                    }

                    reject({
                        itemId: itemId,
                        type: operation,
                        contentType: syncQuery.collectionName,
                        error: err,
                        storage: syncLocation.client
                    });
                });
            }));
        },

        _handleKeepClient: function _handleKeepClient(conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var resultingItem;
            var collection;

            if (serverItem && clientItem) {
                resultingItem = _underscore2.default.extend(clientItem, {
                    ModifiedAt: new Date(serverItem.ModifiedAt)
                });
                collection = contentTypeSyncData.modifiedItems;
            } else if (serverItem && !clientItem) {
                resultingItem = serverItem;
                collection = contentTypeSyncData.deletedItems;
            } else if (!serverItem && clientItem) {
                resultingItem = clientItem;
                collection = contentTypeSyncData.createdItems;
            } else {
                throw new _EverliveError.EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }

            collection.push({
                remoteItem: conflictingItem.serverItem,
                resultingItem: resultingItem,
                resolutionType: _constants2.default.ConflictResolution.KeepClient
            });
        },

        _handleCustom: function _handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = _underscore2.default.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
            if (serverItem && customItem) {
                var createItemOfflineQuery = new _DataQuery2.default({
                    meta: {
                        collectionName: typeName
                    },
                    operation: _DataQuery2.default.operations.Create,
                    data: serverItem // create the server item offline and it will be updated when sync finishes
                });

                createItemOfflineQuery.preserveState = true;
                createItemOfflineQuery.isSync = true;

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));

                this._onItemProcessed(serverItem, typeName, syncLocation.client, _constants.offlineItemStates.created);
            }

            if (serverItem && customItem && !clientItem) {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem,
                    isCustom: true
                });
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new _DataQuery2.default({
                    meta: {
                        collectionName: typeName
                    },
                    operation: _DataQuery2.default.operations.Update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
                customItem.Id = clientItem.Id;

                contentTypeSyncData.createdItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            }
        },

        _mergeResolvedConflicts: function _mergeResolvedConflicts(conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _underscore2.default.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _underscore2.default.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case _constants2.default.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData);
                            break;
                        case _constants2.default.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case _constants2.default.ConflictResolution.Custom:
                            if (_utils2.default.isContentType.files(typeName)) {
                                var err = _EverliveError.EverliveErrors.customFileSyncNotSupported;
                                throw new _EverliveError.EverliveError(err.message, err.code);
                            }

                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                        case _constants2.default.ConflictResolution.Skip:
                            break;
                    }
                });
            });

            return _rsvp2.default.all(offlineSyncOperations);
        },

        _getSyncItemStates: function _getSyncItemStates(contentType, offlineItems, serverItems) {
            var self = this;

            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    modifiedItemsOnServer: [],
                    deletedItems: [],
                    deletedItemsOnServer: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _underscore2.default.each(offlineItems, function (offlineItem) {
                var serverItem = _underscore2.default.findWhere(serverItems, {
                    Id: offlineItem.Id
                });
                if (serverItem) {
                    if (serverItem.Id === offlineItem.Id && offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.created) {
                        if (self.setup.conflicts.strategy === _constants2.default.ConflictResolutionStrategy.Custom) {
                            self._onItemFailed({
                                type: _constants.offlineItemStates.modified,
                                storage: syncLocation.client,
                                error: new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncError),
                                contentType: contentType
                            }, offlineItem.Id);

                            return self._onItemFailed({
                                type: _constants.offlineItemStates.modified,
                                storage: syncLocation.server,
                                error: new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncError),
                                contentType: contentType
                            }, serverItem.Id);
                        } else {
                            return self._onItemFailed({
                                type: _constants.offlineItemStates.created,
                                storage: syncLocation.client,
                                error: new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncError),
                                contentType: contentType
                            }, serverItem.Id);
                        }
                    }

                    var clientItemChanged = !!offlineItem[_constants2.default.offlineItemsStateMarker];
                    var hasUpdateConflict = false;

                    if (clientItemChanged) {
                        hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime() || offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.deleted;
                        //TODO: when an item is removed offline its ModifiedAt field is not set, check if it needs to be set or we can use this
                    }

                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else if (offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.modified) {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else if (offlineItem[_constants2.default.offlineItemsStateMarker] === undefined) {
                            contentTypeSyncData.itemsForSync.modifiedItemsOnServer.push(serverItem);
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: serverItem
                            });
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else if (offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.created) {
                        contentTypeSyncData.itemsForSync.createdItems.push({
                            remoteItem: serverItem,
                            resultingItem: offlineItem
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.deletedItemsOnServer.push(offlineItem);
                    }
                }

                delete offlineItem[_constants2.default.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function _setResolutionTypeForItem(resolutionType, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType
            };
        },

        _applyResolutionStrategy: function _applyResolutionStrategy(conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.setup.conflicts.strategy;
            return new _rsvp2.default.Promise(function (resolve, reject) {
                var conflictResolutionPromises = [];

                for (var i = 0; i < conflicts.length; i++) {
                    var conflict = conflicts[i];
                    if (conflict.conflictingItems.length) {
                        switch (conflictResolutionStrategy) {
                            case _constants2.default.ConflictResolutionStrategy.ServerWins:
                                _underscore2.default.each(conflict.conflictingItems, self._setResolutionTypeForItem.bind(self, _constants2.default.ConflictResolution.KeepServer));
                                break;
                            case _constants2.default.ConflictResolutionStrategy.Custom:
                                var customStrategy = self.setup.conflicts.implementation;
                                if (!customStrategy) {
                                    return reject(new _EverliveError.EverliveError('Implementation of the conflict resolution strategy ' + 'must be provided when set to Custom'));
                                }

                                conflictResolutionPromises.push(new _rsvp2.default.Promise(function (resolve) {
                                    customStrategy(conflicts, resolve);
                                }));
                                break;
                            default:
                                return reject(new _EverliveError.EverliveError('Invalid resolution strategy provided'));
                        }
                    }
                }

                _rsvp2.default.all(conflictResolutionPromises).then(function () {
                    resolve();
                });
            });
        },

        _getSyncPromiseBatch: function _getSyncPromiseBatch(contentType, batchIds) {
            var self = this;

            var dataQuery = new _DataQuery2.default({
                meta: {
                    collectionName: contentType
                },
                query: new _Query2.default({
                    'Id': {
                        '$in': batchIds
                    }
                }),
                operation: _DataQuery2.default.operations.Read,
                applyOffline: false
            });

            var getRequestOptionsFromQuery = _RequestOptionsBuilder2.default[dataQuery.operation];
            var requestOptions = getRequestOptionsFromQuery(dataQuery);
            var request = new _Request2.default(self._everlive.setup, requestOptions);

            return _RequestService.RequestService.sendRequest(request);
        },

        _getPlainItemsForSync: function _getPlainItemsForSync(collection, forceDirty) {
            if (this.setup.syncUnmodified && !forceDirty) {
                return _underscore2.default.values(collection);
            } else {
                return this._queryProcessor._getDirtyItems(collection);
            }
        },

        _getIdsForSync: function _getIdsForSync(contentType, offlineItemsToSync) {
            if (this._shouldAutogenerateIdForContentType(contentType)) {
                return _underscore2.default.pluck(offlineItemsToSync, '_id');
            } else {
                return _underscore2.default.pluck(_underscore2.default.reject(offlineItemsToSync, function (offlineItem) {
                    return offlineItem[_constants2.default.offlineItemsStateMarker] === _constants.offlineItemStates.created;
                }), '_id');
            }
        },

        _getSyncPromiseForCollection: function _getSyncPromiseForCollection(collection, contentType) {
            var batches = [];
            var batchSize = _constants2.default.syncBatchSize;

            var offlineItemsToSync = this._getPlainItemsForSync(collection);
            var allIdsForSync = this._getIdsForSync(contentType, offlineItemsToSync);

            var batchCount = Math.ceil(allIdsForSync.length / batchSize);

            for (var i = 0; i < batchCount; i++) {
                var batchSkipSize = i * batchSize;
                var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
                var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
                batches.push(syncGetServerItemsPromise);
            }

            return _rsvp2.default.all(batches).then(function (serverItemsSyncResponses) {
                var result = {
                    serverItems: []
                };

                _underscore2.default.each(serverItemsSyncResponses, function (serverItems) {
                    result.serverItems = _underscore2.default.union(result.serverItems, serverItems);
                });

                result.offlineItemsToSync = offlineItemsToSync;
                return result;
            });
        },

        _onItemFailed: function _onItemFailed(syncResult, itemId) {
            var self = this;

            var results = syncResult.reason ? syncResult.reason : syncResult;
            var targetType = results.contentType;

            var getFailedItem = function getFailedItem(id) {
                var pickedObject = _underscore2.default.pick(results, 'storage', 'type', 'error');
                if (!pickedObject.error) {
                    pickedObject.error = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncErrorUnknown);
                }
                return _underscore2.default.extend({
                    itemId: id,
                    contentType: targetType
                }, pickedObject);
            };

            var failedItems = [];
            if (results.type === _constants.offlineItemStates.created && results.items) {
                failedItems = _underscore2.default.map(results.items, function (item) {
                    return getFailedItem(item.Id);
                });
            } else {
                failedItems.push(getFailedItem(itemId));
            }

            self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
            _underscore2.default.each(failedItems, function (failedItem) {
                self._syncResultInfo.failedItems[targetType].push(failedItem);
                self._fireItemProcessed(failedItem);
            });
        },

        _onItemProcessed: function _onItemProcessed(item, contentType, syncStorage, syncType) {
            var syncInfo = {
                itemId: item.Id,
                type: syncType,
                storage: syncStorage,
                contentType: contentType
            };

            this._syncResultInfo.syncedItems[contentType] = this._syncResultInfo.syncedItems[contentType] || [];
            this._syncResultInfo.syncedItems[contentType].push(syncInfo);

            if (syncInfo.storage == syncLocation.server) {
                this._syncResultInfo.syncedToServer++;
            } else {
                this._syncResultInfo.syncedToClient++;
            }

            this._fireItemProcessed(syncInfo);
        },

        _fireItemProcessed: function _fireItemProcessed(syncInfo) {
            this._everlive._emitter.emit(_constants2.default.Events.ItemProcessed, syncInfo);
        },

        _getClientWinsSyncData: function _getClientWinsSyncData(collections, forceDirty) {
            var self = this;
            var syncData = {};
            _underscore2.default.each(collections, function (collection, typeName) {
                if (!syncData[typeName]) {
                    syncData[typeName] = {
                        createdItems: [],
                        modifiedItems: [],
                        deletedItems: [],
                        deletedItemsOnServer: [],
                        modifiedItemsOnServer: []
                    };
                }

                var plainItems = self._getPlainItemsForSync(collection, forceDirty);
                var itemsForSync = _offlineTransformations2.default.idTransform(plainItems);

                _underscore2.default.each(itemsForSync, function (itemForSync) {
                    switch (itemForSync[_constants2.default.offlineItemsStateMarker]) {
                        case _constants.offlineItemStates.created:
                            syncData[typeName].createdItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case _constants.offlineItemStates.modified:
                            syncData[typeName].modifiedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case _constants.offlineItemStates.deleted:
                            syncData[typeName].deletedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                    }

                    delete itemForSync[_constants2.default.offlineItemsStateMarker];
                });
            });

            return syncData;
        },

        _getModifiedFilesForSyncClientWins: function _getModifiedFilesForSyncClientWins(itemId, item, collectionName) {
            var self = this;
            var sdk = self._everlive;

            return new _rsvp2.default.Promise(function (resolve, reject) {
                var offlineFiles = self.files;
                offlineFiles.getOfflineLocation(itemId).then(function (location) {
                    if (location) {
                        return self._transferFile(true, item, location).then(function (result) {
                            if (result.Result === false) {
                                reject({
                                    type: _constants.offlineItemStates.modified,
                                    itemId: item.Id,
                                    contentType: collectionName,
                                    error: result,
                                    storage: syncLocation.server
                                });
                            } else {
                                return {
                                    result: result
                                };
                            }
                        }, function (err) {
                            reject({
                                type: _constants.offlineItemStates.modified,
                                itemId: item.Id,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        });
                    } else {
                        return sdk.files.isSync(true).applyOffline(false).updateSingle(item).then(function (response) {
                            return response;
                        }, function (err) {
                            reject({
                                type: _constants.offlineItemStates.modified,
                                itemId: item.Id,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        });
                    }
                }).then(function (onlineResponse) {
                    var onlineResult = onlineResponse.result;
                    item.ModifiedAt = onlineResult.ModifiedAt;
                    self._onItemProcessed(item, collectionName, syncLocation.server, _constants.offlineItemStates.modified);
                    return sdk.files.isSync(true).useOffline(true).updateSingle(item);
                }).then(resolve).catch(function (err) {
                    reject({
                        type: _constants.offlineItemStates.modified,
                        itemId: item.Id,
                        contentType: collectionName,
                        error: err,
                        storage: syncLocation.server
                    });
                });
            });
        },

        _getModifiedItemForSyncClientWins: function _getModifiedItemForSyncClientWins(dataCollection, item, collectionName) {
            var self = this;

            return new _rsvp2.default.Promise(function (resolve, reject) {
                return dataCollection.isSync(true).applyOffline(false).updateSingle(item).then(function (res) {
                    self._onItemProcessed(item, collectionName, syncLocation.server, _constants.offlineItemStates.modified);
                    var updatedItem = _underscore2.default.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    var updateQuery = new _DataQuery2.default({
                        operation: _DataQuery2.default.operations.Update,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        meta: {
                            collectionName: collectionName
                        },
                        isSync: true
                    });

                    return self.processQuery(updateQuery);
                }, function (res) {
                    reject({
                        storage: syncLocation.server,
                        type: _constants.offlineItemStates.modified,
                        itemId: item.Id,
                        contentType: collectionName,
                        error: res
                    });
                }).then(resolve, function (err) {
                    reject({
                        storage: syncLocation.client,
                        type: _constants.offlineItemStates.modified,
                        itemId: item.Id,
                        contentType: collectionName,
                        error: err
                    });
                });
            });
        },

        _addModifiedItemsForSyncClientWins: function _addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
                var itemId = item.Id;
                if (!itemId) {
                    throw new _EverliveError.EverliveError('When updating an item it must have an Id field.');
                }
                var collectionName = dataCollection.collectionName;

                if (_utils2.default.isContentType.files(collectionName)) {
                    syncPromises[itemId] = self._getModifiedFilesForSyncClientWins(itemId, item, collectionName);
                } else {
                    syncPromises[itemId] = self._getModifiedItemForSyncClientWins(dataCollection, item, collectionName);
                }
            });
        },

        _addDeletedItemsForSyncClientWins: function _addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item, itemFilter) {
                var collectionName = dataCollection.collectionName;
                syncPromises[item.Id] = new _rsvp2.default.Promise(function (resolve, reject) {
                    var itemId = item.Id;
                    if (!itemId) {
                        throw new _EverliveError.EverliveError('When deleting an item it must have an Id field.');
                    }

                    return dataCollection.isSync(true).applyOffline(false).destroySingle(itemFilter).then(function () {
                        self._onItemProcessed(item, collectionName, syncLocation.server, _constants.offlineItemStates.deleted);
                        return self._purgeById(collectionName, item.Id).then(function () {
                            resolve();
                        }, function (err) {
                            reject(_underscore2.default.extend({}, {
                                storage: syncLocation.client,
                                type: _constants.offlineItemStates.deleted,
                                contentType: collectionName,
                                itemId: itemId,
                                error: err
                            }));
                        });
                    }, function (err) {
                        reject(_underscore2.default.extend({}, {
                            storage: syncLocation.server,
                            type: _constants.offlineItemStates.deleted,
                            contentType: collectionName,
                            error: err,
                            itemId: itemId
                        }));
                    });
                });
            });
        },

        _applyClientWins: function _applyClientWins(collections) {
            var self = this;
            var syncData = this._getClientWinsSyncData(collections, true);
            var syncPromises = {};

            _underscore2.default.each(syncData, function (contentTypeData, typeName) {
                var dataCollection = self._everlive.data(typeName);
                if (contentTypeData.createdItems.length) {
                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.modifiedItems.length) {
                    self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.deletedItems.length) {
                    self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }
            });

            var syncResult;

            return _rsvp2.default.hashSettled(syncPromises).then(function (result) {
                syncResult = result;
                if (self.setup.syncUnmodified) {
                    var promises = [];
                    _underscore2.default.each(collections, function (collection, collectionName) {
                        var allOfflineItems = self._getPlainItemsForSync(collection);
                        var itemsToDownload = _underscore2.default.where(allOfflineItems, function (offlineItem) {
                            return offlineItem[_constants2.default.offlineItemsStateMarker] !== undefined;
                        });

                        var DataCollection = self._everlive.data(collectionName);

                        var itemIdsForSync = _underscore2.default.pluck(itemsToDownload, '_id');
                        var downloadPromise = DataCollection.isSync(true).useOffline(false).get({
                            Id: {
                                $in: itemIdsForSync
                            }
                        }).then(function (res) {
                            var serverItems = res.result;
                            var serverItemIds = _underscore2.default.pluck(serverItems, 'Id');
                            return self._unmodifiedClientWinsItemsDeletedOnServer(collectionName, serverItemIds, itemsToDownload).then(function () {
                                return self._unmodifiedClientWinsItemsUpdatedOnServer(collectionName, serverItems, itemsToDownload);
                            });
                        });

                        promises.push(downloadPromise);
                    });

                    return _rsvp2.default.all(promises);
                }
            }).then(function () {
                return syncResult;
            });
        },

        _unmodifiedClientWinsItemsDeletedOnServer: function _unmodifiedClientWinsItemsDeletedOnServer(collectionName, serverItemIds, clientItems) {
            var self = this;
            var itemsForDeleteIds = [];
            var itemIdsForSync = _underscore2.default.pluck(clientItems, '_id');
            _underscore2.default.each(itemIdsForSync, function (itemId) {
                if (serverItemIds.indexOf(itemId) === -1) {
                    itemsForDeleteIds.push(itemId);
                }
            });

            return _utils2.default.successfulPromise().then(function () {
                if (itemsForDeleteIds.length !== 0) {
                    var deleteQuery = new _DataQuery2.default({
                        operation: _DataQuery2.default.operations.Delete,
                        filter: {
                            Id: {
                                $in: itemsForDeleteIds
                            }
                        },
                        meta: {
                            collectionName: collectionName
                        },
                        isSync: true
                    });

                    return self.processQuery(deleteQuery).then(function () {
                        _underscore2.default.each(itemsForDeleteIds, function (itemsForDeleteId) {
                            self._onItemProcessed({ Id: itemsForDeleteId }, collectionName, syncLocation.client, _constants.offlineItemStates.deleted);
                        });
                    });
                }
            });
        },

        _unmodifiedClientWinsItemsUpdatedOnServer: function _unmodifiedClientWinsItemsUpdatedOnServer(collectionName, serverItems, clientItems) {
            var self = this;
            var updatePromises = [];

            _underscore2.default.each(serverItems, function (serverItem) {
                var item = _underscore2.default.find(clientItems, function (clientItem) {
                    return clientItem._id === serverItem.Id;
                });

                if (item) {
                    var updateQuery = new _DataQuery2.default({
                        operation: _DataQuery2.default.operations.Update,
                        data: serverItem,
                        additionalOptions: {
                            id: item._id
                        },
                        meta: {
                            collectionName: collectionName
                        },
                        isSync: true
                    });

                    var itemUpdatedPromise = self.processQuery(updateQuery).then(function (res) {
                        self._onItemProcessed(serverItem, collectionName, syncLocation.client, _constants.offlineItemStates.modified);
                    });

                    updatePromises.push(itemUpdatedPromise);
                }
            });

            return _rsvp2.default.all(updatePromises);
        },

        _modifyFileStandardSync: function _modifyFileStandardSync(syncPromises, itemId, item, collectionName, resolutionType) {
            var self = this;

            var filesCollection = self._everlive.files;
            syncPromises[itemId] = new _rsvp2.default.Promise(function (resolve, reject) {
                var offlineLocation;
                self.files.getOfflineLocation(itemId).then(function (locationOnDisk) {
                    offlineLocation = locationOnDisk;
                }).then(function () {
                    return filesCollection.isSync(true).applyOffline(false).getById(itemId);
                }).then(function (response) {
                    var file = response.result;
                    if (file.ModifiedAt.getTime() !== item.ModifiedAt.getTime()) {
                        reject(_underscore2.default.extend({}, new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncConflict), {
                            contentType: collectionName
                        }));
                    } else {
                        if (offlineLocation) {
                            if (resolutionType === _constants2.default.ConflictResolution.KeepServer) {
                                return self.files._saveFile(item.Uri, item.Filename, item.Id).then(function () {
                                    return self._offlineFilesProcessor.purge(offlineLocation);
                                }).then(function () {
                                    return response;
                                });
                            } else if (resolutionType === _constants2.default.ConflictResolution.KeepClient) {
                                return self._transferFile(true, item, offlineLocation);
                            }
                        }
                    }
                }).then(function () {
                    return self._everlive.files.isSync(true).useOffline(true).updateSingle(item);
                }).then(resolve).catch(reject);
            });
        },

        _modifyContentTypeStandardSync: function _modifyContentTypeStandardSync(syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom) {
            var self = this;

            syncPromises[itemId] = dataCollection.isSync(true).applyOffline(false).update(item, itemFilter).then(function (res) {
                return self._onSyncResponse(res, item, collectionName, _DataQuery2.default.operations.Update, isCustom);
            }, function (err) {
                return new _rsvp2.default.Promise(function (resolve, reject) {
                    reject({
                        type: _constants.offlineItemStates.modified,
                        itemId: item.Id,
                        contentType: collectionName,
                        error: err,
                        storage: syncLocation.server
                    });
                });
            });
        },

        _applyStandardSync: function _applyStandardSync(collections) {
            var self = this;

            var promises = {};
            _underscore2.default.each(collections, function (collection, contentType) {
                promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
            });

            return _rsvp2.default.hash(promises).then(function (contentTypes) {
                return self._prepareSyncData(contentTypes);
            }).then(function (syncData) {
                return self._resolveConflicts(syncData);
            }).then(function (contentTypeSyncData) {
                var syncPromises = {};
                _underscore2.default.each(contentTypeSyncData, function (contentTypeData, collectionName) {
                    var dataCollection = self._everlive.data(collectionName);
                    if (contentTypeData.createdItems.length) {
                        self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                    }

                    if (contentTypeData.modifiedItems.length) {
                        self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom, resolutionType) {
                            var itemId = item.Id;

                            if (_utils2.default.isContentType.files(collectionName)) {
                                self._modifyFileStandardSync(syncPromises, itemId, item, collectionName, resolutionType, isCustom);
                            } else {
                                self._modifyContentTypeStandardSync(syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom);
                            }
                        });
                    }

                    if (contentTypeData.deletedItems.length) {
                        self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom) {
                            syncPromises[item.Id] = dataCollection.isSync(true).applyOffline(false).destroy(itemFilter).then(function (res) {
                                return self._onSyncResponse(res, item, collectionName, _DataQuery2.default.operations.Delete, isCustom);
                            }, function (err) {
                                return new _rsvp2.default.Promise(function (resolve, reject) {
                                    reject({
                                        type: _constants.offlineItemStates.deleted,
                                        itemId: item.Id,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.server
                                    });
                                });
                            });
                        });
                    }

                    _underscore2.default.each(contentTypeData.deletedItemsOnServer, function (item) {
                        syncPromises[item.Id] = dataCollection.isSync(true).useOffline(true).destroySingle({
                            Id: item.Id
                        }).then(function (res) {
                            return self._onItemProcessed(item, collectionName, syncLocation.client, _constants.offlineItemStates.deleted);
                        }, function (err) {
                            return new _rsvp2.default.Promise(function (resolve, reject) {
                                reject({
                                    type: _constants.offlineItemStates.deleted,
                                    itemId: item.Id,
                                    contentType: collectionName,
                                    error: err,
                                    storage: syncLocation.client
                                });
                            });
                        });
                    });

                    _underscore2.default.each(contentTypeData.modifiedItemsOnServer, function (item) {
                        syncPromises[item.Id] = dataCollection.isSync(true).useOffline(true).update(item, {
                            Id: item.Id
                        }).then(function (res) {
                            return self._onItemProcessed(item, collectionName, syncLocation.client, _constants.offlineItemStates.modified);
                        }, function (err) {
                            return _utils2.default.rejectedPromise({
                                type: _constants.offlineItemStates.modified,
                                itemId: item.Id,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.client
                            });
                        });
                    });
                });

                return _rsvp2.default.hashSettled(syncPromises);
            });
        },

        _applySync: function _applySync() {
            var self = this;

            return this._queryProcessor._getAllCollections().then(function (collections) {
                if (self.setup.conflicts.strategy === _constants2.default.ConflictResolutionStrategy.ClientWins) {
                    return self._applyClientWins(collections);
                } else {
                    return self._applyStandardSync(collections);
                }
            });
        },

        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @returns {Promise}
         */
        getItemsForSync: function getItemsForSync(success, error) {
            var self = this;
            var plainItemsForSync = {};
            return (0, _utils.buildPromise)(function (successCb, errorCb) {
                self._queryProcessor._getAllCollections().then(function (collections) {
                    _underscore2.default.each(collections, function (collection, collectionName) {
                        var plainItems = self._getPlainItemsForSync(collection);
                        plainItemsForSync[collectionName] = _underscore2.default.map(plainItems, function (item) {
                            var itemForSync = {
                                item: _underscore2.default.extend({}, item),
                                action: item[_constants2.default.offlineItemsStateMarker]
                            };

                            delete itemForSync.item[_constants2.default.offlineItemsStateMarker];
                            return itemForSync;
                        });
                    });

                    successCb(plainItemsForSync);
                }).catch(errorCb);
            }, success, error);
        }
    };

    return OfflineModule;
}();

},{"../../everlive/EverliveError":58,"../../everlive/Request":63,"../../everlive/constants":70,"../../everlive/dataQuery/DataQuery":71,"../../everlive/offline/OfflineFilesModule":81,"../../everlive/offline/OfflineFilesProcessor":82,"../../everlive/offline/OfflineQueryProcessor":83,"../../everlive/offline/offlineTransformations":87,"../../everlive/query/Query":96,"../../everlive/query/RequestOptionsBuilder":98,"../../everlive/services/RequestService":105,"../../everlive/utils":121,"rsvp":35,"underscore":36}],85:[function(require,module,exports){
'use strict';

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _offlinePersisters = require('../../everlive/offline/offlinePersisters');

var _offlinePersisters2 = _interopRequireDefault(_offlinePersisters);

var _OfflineStorageModule = require('../../everlive/offline/OfflineStorageModule');

var _OfflineStorageModule2 = _interopRequireDefault(_OfflineStorageModule);

var _EverliveError = require('../../everlive/EverliveError');

var _everlive = require('../../everlive/everlive.platform');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _CryptographicProvider = require('../../everlive/encryption/CryptographicProvider');

var _CryptographicProvider2 = _interopRequireDefault(_CryptographicProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultOfflineStorageOptions = {
    autoSync: true,
    enabled: true,
    conflicts: {
        strategy: _constants2.default.ConflictResolutionStrategy.ClientWins,
        implementation: null
    },
    offline: false,
    storage: {
        name: '',
        provider: _everlive.isNativeScript ? _constants2.default.StorageProvider.FileSystem : _constants2.default.StorageProvider.LocalStorage,
        implementation: null,
        storagePath: _constants2.default.DefaultStoragePath,
        requestedQuota: _constants2.default.DefaultFilesystemStorageQuota
    },
    typeSettings: {},
    encryption: {
        provider: _constants2.default.EncryptionProvider.Default,
        implementation: null,
        key: ''
    },
    files: {
        storagePath: _constants2.default.DefaultFilesStoragePath,
        metaPath: _constants2.default.DefaultFilesMetadataPath,
        maxConcurrentDownloads: _constants2.default.MaxConcurrentDownloadTasks
    }
};

module.exports = function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[_constants2.default.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new _rsvp2.default.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[_constants2.default.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new _rsvp2.default.Promise(function (resolve) {
            resolve(server);
        });
    };

    var initStoragePersister = function initStoragePersister(options) {
        var storageKey = options.storage.name || 'everliveOfflineStorage_' + this.setup.appId;
        var persister = _offlinePersisters2.default.getPersister(storageKey, options);
        options.storage.implementation = persister;
        return persister;
    };

    var initEncryptionProvider = function initEncryptionProvider(options) {
        var encryptor;
        var encryptionProvider = options.encryption.provider;
        var encryptionImplementation = options.encryption.implementation;
        if (_underscore2.default.isObject(encryptionImplementation) && encryptionProvider === _constants2.default.EncryptionProvider.Custom) {
            encryptor = encryptionImplementation;
        } else {
            switch (encryptionProvider) {
                case _constants2.default.EncryptionProvider.Default:
                    encryptor = new _CryptographicProvider2.default(options);
                    break;
                case _constants2.default.EncryptionProvider.Custom:
                    throw new _EverliveError.EverliveError('Custom encryption provider requires an implementation object');
                default:
                    throw new _EverliveError.EverliveError('Unsupported encryption provider ' + encryptionProvider);
            }
        }

        options.encryption.implementation = encryptor;
        return encryptor;
    };

    function buildOfflineStorageOptions(sdkOptions) {
        var storageOptions = sdkOptions.offline || sdkOptions.offlineStorage;
        var options;
        if (storageOptions === true) {
            // explicit check for shorthand initialization
            options = _underscore2.default.defaults({}, defaultOfflineStorageOptions);
        } else if (_underscore2.default.isObject(storageOptions)) {
            options = _underscore2.default.defaults(storageOptions, defaultOfflineStorageOptions);
            options.storage = _underscore2.default.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
            options.encryption = _underscore2.default.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
            options.conflicts = _underscore2.default.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
            options.files = _underscore2.default.defaults(storageOptions.files, defaultOfflineStorageOptions.files);
        } else {
            options = _underscore2.default.defaults({}, defaultOfflineStorageOptions);
            options.enabled = false;
            if (!storageOptions) {
                sdkOptions.offlineStorage = options;
            }
        }

        options.cacheEnabled = sdkOptions.caching && sdkOptions.caching.enabled;
        return options;
    }

    var buildOfflineStorageModule = function buildOfflineStorageModule(sdkOptions) {
        var options = buildOfflineStorageOptions(sdkOptions);
        var persister = initStoragePersister.call(this, options);
        var encryptionProvider = initEncryptionProvider.call(this, options);

        return new _OfflineStorageModule2.default(this, options, persister, encryptionProvider);
    };

    var initOfflineStorage = function initOfflineStorage(options) {
        this.offlineStorage = buildOfflineStorageModule.call(this, options);
    };

    return {
        initOfflineStorage: initOfflineStorage,
        buildOfflineStorageOptions: buildOfflineStorageOptions
    };
}();

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/encryption/CryptographicProvider":73,"../../everlive/everlive.platform":74,"../../everlive/offline/OfflineStorageModule":84,"../../everlive/offline/offlinePersisters":86,"rsvp":35,"underscore":36}],86:[function(require,module,exports){
'use strict';

var _BasePersister = require('../../everlive/offline/persisters/BasePersister');

var _BasePersister2 = _interopRequireDefault(_BasePersister);

var _LocalStoragePersister = require('../../everlive/offline/persisters/LocalStoragePersister');

var _LocalStoragePersister2 = _interopRequireDefault(_LocalStoragePersister);

var _FileSystemPersister = require('../../everlive/offline/persisters/FileSystemPersister');

var _FileSystemPersister2 = _interopRequireDefault(_FileSystemPersister);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _EverliveError = require('../../everlive/EverliveError');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
    BasePersister: _BasePersister2.default,
    LocalStoragePersister: _LocalStoragePersister2.default,
    FileSystemPersister: _FileSystemPersister2.default,
    getPersister: function getPersister(storageKey, options) {
        var persister;

        var storageProvider = options.storage.provider;
        var storageProviderImplementation = options.storage.implementation;
        if (_underscore2.default.isObject(storageProviderImplementation) && storageProvider === _constants2.default.StorageProvider.Custom) {
            persister = storageProviderImplementation;
        } else {
            switch (storageProvider) {
                case _constants2.default.StorageProvider.LocalStorage:
                    persister = new _LocalStoragePersister2.default(storageKey, options);
                    break;
                case _constants2.default.StorageProvider.FileSystem:
                    persister = new _FileSystemPersister2.default(storageKey, options);
                    break;
                case _constants2.default.StorageProvider.Custom:
                    throw new _EverliveError.EverliveError('Custom storage provider requires an implementation object');
                default:
                    throw new _EverliveError.EverliveError('Unsupported storage type ' + storageProvider);
            }
        }

        return persister;
    }
};

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/offline/persisters/BasePersister":88,"../../everlive/offline/persisters/FileSystemPersister":89,"../../everlive/offline/persisters/LocalStoragePersister":90,"underscore":36}],87:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var traverseAndApply = function traverseAndApply(value, operation, additionalOptions) {
    if (_underscore2.default.isArray(value)) {
        return _underscore2.default.map(value, function (item) {
            return operation(item, additionalOptions);
        });
    } else {
        return operation(value, additionalOptions);
    }
};

var idTransformation = function idTransformation(value) {
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value._id && !value.Id) {
        value.Id = value._id;
        delete value._id;
    }

    return value;
};

var _removeIdTransform = function _removeIdTransform(value, opts) {
    var verifyStateCreated = opts.verifyStateCreated;
    var shouldModifyObject = verifyStateCreated ? value[_constants2.default.offlineItemsStateMarker] === _constants2.default.offlineItemStates.created : true;
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && (value._id || value.Id) && shouldModifyObject) {
        delete value._id;
        delete value.Id;
    }

    return value;
};

var removeMarkerTransform = function removeMarkerTransform(value) {
    delete value[_constants.offlineItemsStateMarker];
    return value;
};

var offlineTransformations = {
    removeIdTransform: function removeIdTransform(value, verifyStateCreated) {
        return traverseAndApply(value, _removeIdTransform, { verifyStateCreated: verifyStateCreated });
    },
    idTransform: function idTransform(value) {
        return traverseAndApply(value, idTransformation);
    },
    singleFieldTransform: function singleFieldTransform(singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function traverseAndTransformFilterId(filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if ((typeof objectMember === 'undefined' ? 'undefined' : _typeof(objectMember)) === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function removeMarkersTransform(value) {
        return traverseAndApply(value, removeMarkerTransform);
    },
    removeFieldsTransform: function removeFieldsTransform(value, fields) {
        _underscore2.default.each(fields, function (field) {
            delete value[field];
        });

        return value;
    }
};

module.exports = offlineTransformations;

},{"../../everlive/constants":70,"underscore":36}],88:[function(require,module,exports){
'use strict';

var _EverliveError = require('../../../everlive/EverliveError');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BasePersister = function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data to/from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister(key, options) {
        this.key = key;
        this.options = options;
        this.contentTypesStoreKey = this.key + '@ContentTypes';
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @returns {Object} The keys are the content types and the values are the corresponding data items.
         */
        getAllData: function getAllData(success, error) {
            var self = this;
            var promises = {};
            this._getContentTypes(function (contentTypes) {
                _underscore2.default.each(contentTypes, function (contentType) {
                    promises[contentType] = new _rsvp2.default.Promise(function (resolve, reject) {
                        self.getData(contentType, resolve, reject);
                    });
                });

                _rsvp2.default.hash(promises).then(success).catch(error);
            }, error);
        },

        /**
         * Returns the saved data for a specific content type.
         * @method getData
         * @param {string} contentType The content type for which to retrieve the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         * @returns {string} The retrieved data.
         */
        getData: function getData(contentType, success, error) {
            throw new _EverliveError.EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type.
         * @method saveData
         * @param {string} contentType The content for which to save the data.
         * @param {string} data The data corresponding to the specified content type.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        saveData: function saveData(contentType, data, success, error) {
            throw new _EverliveError.EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type.
         * @method purge
         * @param {string} contentType The content type for which to clear the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        purge: function purge(contentType, success, error) {
            throw new _EverliveError.EverliveError('The method clear is not implemented');
        },

        /**
         * Clears all persisted data in the offline store.
         * @method purgeAll
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         */
        purgeAll: function purgeAll(success, error) {
            throw new _EverliveError.EverliveError('The method clearAll is not implemented');
        },

        _getKey: function _getKey(contentType) {
            return this.key + '_' + contentType;
        },

        _getContentTypes: function _getContentTypes(success, error) {
            throw new _EverliveError.EverliveError('The method _getContentTypes is not implemented');
        }
    };

    return BasePersister;
}();

module.exports = BasePersister;

},{"../../../everlive/EverliveError":58,"rsvp":35,"underscore":36}],89:[function(require,module,exports){
'use strict';

var _FileStore = require('../../../everlive/storages/FileStore');

var _FileStore2 = _interopRequireDefault(_FileStore);

var _BasePersister = require('../../../everlive/offline/persisters/BasePersister');

var _BasePersister2 = _interopRequireDefault(_BasePersister);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FileSystemPersister = function () {
    /**
     * @class FileSystemPersister
     * @protected
     * @extends BasePersister
     */
    function FileSystemPersister(key, options) {
        _BasePersister2.default.apply(this, arguments);
        this.fileStore = new _FileStore2.default(options.storage.storagePath, options);
    }

    _util2.default.inherits(FileSystemPersister, _BasePersister2.default);

    FileSystemPersister.prototype.getAllData = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        FileSystemPersister.super_.prototype.getAllData.call(this, success, errorHandler);
    };

    FileSystemPersister.prototype.getData = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._readFileContent(fileEntry, success, errorHandler);
        }, error);
    };

    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._writeFileContent(fileEntry, data, function () {
                self._saveContentTypes(contentType, success, errorHandler);
            }, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purge = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self.fileStore.removeFile(fileEntry).then(function () {
                success();
            }).catch(error);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purgeAll = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        this.fileStore.removeFilesDirectory().then(function () {
            success();
        }).catch(errorHandler);
    };

    FileSystemPersister.prototype._getContentTypes = function (success, error) {
        this.getData(this.contentTypesStoreKey, function (savedContentTypesRaw) {
            var savedContentTypes = JSON.parse(savedContentTypesRaw || '[]');
            success(savedContentTypes);
        }, error);
    };

    FileSystemPersister.prototype._saveContentTypes = function (contentType, success, error) {
        var self = this;
        this._getContentTypes(function (savedContentTypes) {
            if (!_underscore2.default.contains(savedContentTypes, contentType)) {
                savedContentTypes.push(contentType);
            }

            self.getFileHandle(self.contentTypesStoreKey, function (contentTypesFile) {
                self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
            }, error);
        });
    };

    FileSystemPersister.prototype.getFileHandle = function (contentType, success, error) {
        var self = this;
        var path = self._getFilePath(contentType);
        this.fileStore.getFilesDirectory().then(function () {
            return self.fileStore.getFile(path);
        }).then(function (fileHandle) {
            success(fileHandle);
        }).catch(error);
    };

    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
        this.fileStore.readFileAsText(fileEntry).then(function (content) {
            success(content);
        }).catch(error);
    };

    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
        this.fileStore.writeTextToFile(fileEntry, content).then(success).catch(error);
    };

    FileSystemPersister.prototype._getFilePath = function (contentType) {
        return this._getKey(contentType);
        //return utils.joinPath(this.fileStore.filesDirectoryPath, this._getKey(contentType));
    };

    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
        return this.fileStore.getErrorHandler(callback);
    };

    return FileSystemPersister;
}();

module.exports = FileSystemPersister;

},{"../../../everlive/offline/persisters/BasePersister":88,"../../../everlive/storages/FileStore":106,"underscore":36,"util":7}],90:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _LocalStore = require('../../../everlive/storages/LocalStore');

var _LocalStore2 = _interopRequireDefault(_LocalStore);

var _BasePersister = require('../../../everlive/offline/persisters/BasePersister');

var _BasePersister2 = _interopRequireDefault(_BasePersister);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LocalStoragePersister = function () {

    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key, options) {
        _BasePersister2.default.apply(this, arguments);
        this._localStore = new _LocalStore2.default(options);
    }

    _util2.default.inherits(LocalStoragePersister, _BasePersister2.default);

    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key);
            success(storedItem);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
        try {
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, data);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
        var self = this;

        try {
            var key = this._getKey(contentType);
            this._removeItem(key);
            this._getContentTypes(function (contentTypes) {
                contentTypes = _underscore2.default.without(contentTypes, contentType);
                self._setContentTypesCollection(contentTypes);
                success();
            }, error);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purgeAll = function (success, error) {
        try {
            var self = this;

            this._getContentTypes(function (contentTypes) {
                _underscore2.default.each(contentTypes, function (contentType) {
                    var contentTypeKey = self._getKey(contentType);
                    self._removeItem(contentTypeKey);
                });

                self._removeItem(self.contentTypesStoreKey);
                success();
            }, error);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._getItem = function (key) {
        return this._localStore.getItem(key);
    };

    LocalStoragePersister.prototype._setItem = function (key, value) {
        return this._localStore.setItem(key, value);
    };

    LocalStoragePersister.prototype._removeItem = function (key) {
        return this._localStore.removeItem(key);
    };

    LocalStoragePersister.prototype._getKey = function (contentType) {
        this._addTypeToCollectionsCache(contentType);
        return LocalStoragePersister.super_.prototype._getKey.apply(this, arguments);
    };

    LocalStoragePersister.prototype._getContentTypes = function (success, error) {
        try {
            var localStorageString = this._getItem(this.contentTypesStoreKey);

            var data = [];
            if (localStorageString) {
                data = JSON.parse(localStorageString);
            }

            success(data);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
        this._setItem(this.contentTypesStoreKey, JSON.stringify(collection));
    };

    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
        var self = this;
        this._getContentTypes(function (contentTypes) {
            if (!_underscore2.default.contains(contentTypes, typeName)) {
                contentTypes.push(typeName);
                self._setContentTypesCollection(contentTypes);
            }
        });
    };

    return LocalStoragePersister;
}();

module.exports = LocalStoragePersister;

},{"../../../everlive/offline/persisters/BasePersister":88,"../../../everlive/storages/LocalStore":107,"underscore":36,"util":7}],91:[function(require,module,exports){
'use strict';

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../../everlive/EverliveError');

var _constants = require('../../everlive/constants');

var _jstimezonedetect = require('jstimezonedetect');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function CurrentDevice(pushHandler) {

        if (!window.cordova) {
            throw new _EverliveError.EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
        }

        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.ensurePushIsAvailable = function () {
        var isPushNotificationPluginAvailable = typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification;

        if (!isPushNotificationPluginAvailable && !_utils2.default._inAppBuilderSimulator()) {
            throw new _EverliveError.EverliveError('The push notification plugin is not available. Ensure that the pushNotification plugin is included ' + 'and use after `deviceready` event has been fired.');
        }
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function enableNotifications(pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return (0, _utils.buildPromise)(_underscore2.default.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function disableNotifications(success, error) {
            var self = this;

            return this.unregister().then(function () {
                return (0, _utils.buildPromise)(function (success, error) {
                    if (self.emulatorMode) {
                        success();
                    } else {
                        var pushNotification = window.plugins.pushNotification;
                        var unregisterOptions;
                        var platformType = self._getPlatformType();
                        if (platformType === _constants.Platform.WindowsPhone) {
                            unregisterOptions = { 'channelName': self.pushSettings.wp8.channelName };
                        }
                        pushNotification.unregister(function () {
                            self.isInitialized = false;
                            success();
                        }, error, unregisterOptions);
                    }
                }, success, error);
            }, error);
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function getRegistration(success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function register(customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(function () {
                return self._pushHandler.devices.create(deviceRegistration, success, error);
            }, error);
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function unregister(success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({ Id: 'HardwareId/' + deviceId }, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function updateRegistration(customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(function () {
                deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
            }, error);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function areNotificationsEnabled(options, onSuccess, onError) {
            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return (0, _utils.buildPromise)(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        },

        /**
         * Currently available only for iOS
         * Use this method in case you are working with iOS interactive push notifications in background mode, including TextInput, or iOS silent push notifications
         * Call it once you are done with processing your push notification in notificationCallbackIOS.
         * @method notificationProcessed
         * @name notificationProcessed
         * @memberOf Push.prototype
         */
        /**
         * Currently available only for iOS
         * Use this method in case you are working with iOS interactive push notifications in background mode, including TextInput, or iOS silent push notifications
         * Call it once you are done with processing your push notification in notificationCallbackIOS.
         * @method notificationProcessed
         * @name notificationProcessed
         * @memberOf Push.prototype
         */
        notificationProcessed: function notificationProcessed() {
            var pushPlugin = window.plugins.pushNotification;
            pushPlugin.notificationProcessed();
        },

        _initializeInteractivePush: function _initializeInteractivePush(iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function getAction(actionIdentifier) {
                var action = _underscore2.default.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _underscore2.default.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _underscore2.default.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _underscore2.default.map(category.actionsForMinimalContext, getAction)
                };
            });

            pushPlugin.registerUserNotificationSettings(
            // the success callback which will immediately return (APNs is not contacted for this)
            success,
            // called in case the configuration is incorrect
            error, {
                // asking permission for these features
                types: notificationTypes,
                // register these categories
                categories: categories
            });
        },

        //Initializes the push functionality on the device.
        _initialize: function _initialize(success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new _EverliveError.EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new _EverliveError.EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new _EverliveError.EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(function () {
                    self._deviceRegistrationSuccess('fake_push_token');
                }, 1000);
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType();
            if (platformType === _constants.Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _underscore2.default.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(_underscore2.default.bind(this._successfulRegistrationAPN, this), _underscore2.default.bind(this._failedRegistrationAPN, this), apnRegistrationOptions);
            } else if (platformType === _constants.Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _underscore2.default.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(_underscore2.default.bind(this._successSentRegistrationGCM, this), _underscore2.default.bind(this._errorSentRegistrationGCM, this), gcmRegistrationOptions);
            } else if (platformType === _constants.Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _underscore2.default.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _underscore2.default.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _underscore2.default.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;

                pushNotification.register(_underscore2.default.bind(this._successSentRegistrationWP8, this), _underscore2.default.bind(this._errorSentRegistrationWP8, this), wp8RegistrationOptions);
            } else {
                throw new _EverliveError.EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function _deviceRegistrationSuccessWP(result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function _validateAndroidSettings(androidSettings) {
            if (!androidSettings.senderID) {
                throw new _EverliveError.EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },

        _validateWP8Settings: function _validateWP8Settings(settings) {
            if (!settings.channelName) {
                throw new _EverliveError.EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _cleanPlatformsPushSettings: function _cleanPlatformsPushSettings(pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _underscore2.default.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _underscore2.default.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new _EverliveError.EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function _populateRegistrationObject(deviceRegistration, success, error) {
            var self = this;

            return (0, _utils.buildPromise)(function (success, error) {
                if (!self.pushToken) {
                    throw new _EverliveError.EverliveError('Push token is not available.');
                }

                self._getLocaleName(function (locale) {
                    var deviceId = self._getDeviceId();
                    var hardwareModel = device.model;
                    var platformType = self._getPlatformType();
                    var timeZone = _jstimezonedetect.jstz.determine().name();
                    var pushToken = self.pushToken;
                    var language = locale.value;
                    var platformVersion = device.version;

                    deviceRegistration.HardwareId = deviceId;
                    deviceRegistration.HardwareModel = hardwareModel;
                    deviceRegistration.PlatformType = platformType;
                    deviceRegistration.PlatformVersion = platformVersion;
                    deviceRegistration.TimeZone = timeZone;
                    deviceRegistration.PushToken = pushToken;
                    deviceRegistration.Locale = language;

                    success();
                }, error);
            }, success, error);
        },

        _getLocaleName: function _getLocaleName(success, error) {
            if (this.emulatorMode) {
                success({ value: 'en_US' });
            } else {
                navigator.globalization.getLocaleName(function (locale) {
                    success(locale);
                }, error);
                navigator.globalization.getLocaleName(function (locale) {}, error);
            }
        },

        _getDeviceId: function _getDeviceId() {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function _getPlatformType() {
            var psLower = device.platform.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return _constants.Platform.iOS;
                case 'android':
                    return _constants.Platform.Android;
                case 'wince':
                    return _constants.Platform.WindowsPhone;
                case 'win32nt':
                    // real wp8 devices return this string as platform identifier.
                    return _constants.Platform.WindowsPhone;
                default:
                    return _constants.Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function _deviceRegistrationFailed(error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({ error: error });
            }
        },

        _deviceRegistrationSuccess: function _deviceRegistrationSuccess(token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({ token: token });
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function _successfulRegistrationAPN(token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(this.pushSettings.iOS, function () {
                    self._deviceRegistrationSuccess(token);
                }, function (err) {
                    throw new _EverliveError.EverliveError('The interactive push configuration is incorrect: ' + err);
                });
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function _failedRegistrationAPN(error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function _successSentRegistrationGCM(id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function _successSentRegistrationWP8(id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function _errorSentRegistrationWP8(error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function _errorSentRegistrationGCM(error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function _onNotificationAPN(e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function _onNotificationWP8(e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function _raiseNotificationEventAndroid(e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function _raiseNotificationEventIOS(e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function _raiseNotificationEventWP8(e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}();

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/utils":121,"jstimezonedetect":12,"underscore":36}],92:[function(require,module,exports){
'use strict';

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

'use strict';

if (_everlive2.default.isNativeScript) {
  var NativeScriptCurrentDevice = require('../../everlive/push/NativeScriptCurrentDevice');
  module.exports = NativeScriptCurrentDevice;
} else if (_everlive2.default.isCordova || _everlive2.default.isDesktop) {
  var CordovaCurrentDevice = require('../../everlive/push/CordovaCurrentDevice');
  module.exports = CordovaCurrentDevice;
} else {
  module.exports = _underscore2.default.noop;
}

},{"../../everlive/everlive.platform":74,"../../everlive/push/CordovaCurrentDevice":91,"../../everlive/push/NativeScriptCurrentDevice":93,"underscore":36}],93:[function(require,module,exports){
'use strict';

var _utils = require('../../everlive/utils');

var _EverliveError = require('../../everlive/EverliveError');

var _constants = require('../../everlive/constants');

var _jstimezonedetect = require('jstimezonedetect');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _platform = require('platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tnsPushPluginLazy = (0, _utils.lazyRequire)('nativescript-push-notifications', 'tnsPushPlugin');

module.exports = function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function CurrentDevice(pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.ensurePushIsAvailable = function () {
        // NativeScript will throw an error when the TNS Push Plugin cannot be required. So this is actually unreachable.
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function enableNotifications(pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return (0, _utils.buildPromise)(_underscore2.default.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function disableNotifications(successCb, errorCb) {
            var self = this;

            return this.unregister().then(function () {
                return (0, _utils.buildPromise)(function (success, error) {
                    var successCallback = function successCallback() {
                        self.isInitialized = false;
                        success();
                    };

                    var platformType = self._getPlatformType();
                    if (platformType === _constants.Platform.Android) {
                        return tnsPushPluginLazy.tnsPushPlugin.unregister(successCallback, error, self.pushSettings.android);
                    }

                    tnsPushPluginLazy.tnsPushPlugin.unregister(successCallback, error);
                }, successCb, errorCb);
            }, errorCb);
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function getRegistration(success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function register(customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(function () {
                return self._pushHandler.devices.create(deviceRegistration, success, error);
            }, error);
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function unregister(success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.destroySingle({ Id: 'HardwareId/' + deviceId }, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function updateRegistration(customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(function () {
                deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
            }, error);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function areNotificationsEnabled(options, onSuccess, onError) {
            options = options || {};

            return (0, _utils.buildPromise)(function (successCb, errorCb) {
                tnsPushPluginLazy.tnsPushPlugin.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        },

        _initializeInteractivePush: function _initializeInteractivePush(iOSSettings, success, error) {
            tnsPushPluginLazy.tnsPushPlugin.registerUserNotificationSettings(
            // the success callback which will immediately return (APNs is not contacted for this)
            success,
            // called in case the configuration is incorrect
            error);
        },

        //Initializes the push functionality on the device.
        _initialize: function _initialize(success, error) {
            if (this.isInitializing) {
                error(new _EverliveError.EverliveError('Push notifications are currently initializing.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var platformType = this._getPlatformType();
            if (platformType === _constants.Platform.iOS) {
                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;

                apnRegistrationOptions.notificationCallbackIOS = this.pushSettings.notificationCallbackIOS;
                //Register for APN
                tnsPushPluginLazy.tnsPushPlugin.register(apnRegistrationOptions, _underscore2.default.bind(this._successfulRegistrationAPN, this), _underscore2.default.bind(this._failedRegistrationAPN, this));
            } else if (platformType === _constants.Platform.Android) {
                // Ensure the required fields are present in the Android Settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);

                gcmRegistrationOptions.notificationCallbackAndroid = this.pushSettings.notificationCallbackAndroid;

                //Register for GCM
                tnsPushPluginLazy.tnsPushPlugin.register(gcmRegistrationOptions, _underscore2.default.bind(this._successSentRegistrationGCM, this), _underscore2.default.bind(this._errorSentRegistrationGCM, this));
            } else {
                throw new _EverliveError.EverliveError('The current platform is not supported: ' + _platform2.default.device.os);
            }
        },

        _validateAndroidSettings: function _validateAndroidSettings(androidSettings) {
            if (!androidSettings.senderID) {
                throw new _EverliveError.EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _cleanPlatformsPushSettings: function _cleanPlatformsPushSettings(pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _underscore2.default.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS'];
            _underscore2.default.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new _EverliveError.EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function _populateRegistrationObject(deviceRegistration, success, error) {
            var self = this;

            return (0, _utils.buildPromise)(function (success, error) {
                if (!self.pushToken) {
                    throw new _EverliveError.EverliveError('Push token is not available.');
                }

                self._getLocaleName(function (locale) {
                    var deviceId = self._getDeviceId();
                    var hardwareModel = _platform2.default.device.model;
                    var platformType = self._getPlatformType();
                    var timeZone = _jstimezonedetect.jstz.determine().name();
                    var pushToken = self.pushToken;
                    var language = 'en_US'; //TODO
                    var platformVersion = _platform2.default.device.osVersion;

                    deviceRegistration.HardwareId = deviceId;
                    deviceRegistration.HardwareModel = hardwareModel;
                    deviceRegistration.PlatformType = platformType;
                    deviceRegistration.PlatformVersion = platformVersion;
                    deviceRegistration.TimeZone = timeZone;
                    deviceRegistration.PushToken = pushToken;
                    deviceRegistration.Locale = language;

                    success();
                }, error);
            }, success, error);
        },

        _getLocaleName: function _getLocaleName(success, error) {
            return success(); // TODO            
            /* TODO: Must translate somehow to NativeScript to get the current locale
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }*/
        },

        _getDeviceId: function _getDeviceId() {
            return _platform2.default.device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function _getPlatformType() {
            var psLower = _platform2.default.device.os.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return _constants.Platform.iOS;
                case 'android':
                    return _constants.Platform.Android;
                default:
                    return _constants.Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function _deviceRegistrationFailed(error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({ error: error });
            }
        },

        _deviceRegistrationSuccess: function _deviceRegistrationSuccess(token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({ token: token });
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function _successfulRegistrationAPN(token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(this.pushSettings.iOS, function () {
                    self._deviceRegistrationSuccess(token);
                }, function (err) {
                    throw new _EverliveError.EverliveError('The interactive push configuration is incorrect: ' + err);
                });
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function _failedRegistrationAPN(error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function _successSentRegistrationGCM(token) {
            //console.log("Successfully sent request for registering with GCM.");

            // set on message received.
            tnsPushPluginLazy.tnsPushPlugin.onMessageReceived(this.pushSettings.notificationCallbackAndroid);

            this._deviceRegistrationSuccess(token);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function _errorSentRegistrationGCM(error) {
            this._deviceRegistrationFailed(error);
        },

        notificationProcessed: function notificationProcessed() {
            throw new Error('Not implemented');
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function _onNotificationAPN(e) {
            this._raiseNotificationEventIOS(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function _raiseNotificationEventAndroid(e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function _raiseNotificationEventIOS(e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        }
    };

    return CurrentDevice;
}();

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/utils":121,"jstimezonedetect":12,"platform":"platform","underscore":36}],94:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _Query = require('../../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _EverliveError = require('../../everlive/EverliveError');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class AggregateQuery
 * @classdesc A query class used to describe a aggregation request that will be made to the {{site.TelerikBackendServices}} JavaScript API. Inherits from Query.
 */
var AggregateQuery = function AggregateQuery() {
    _Query2.default.apply(this, arguments);
    this.aggregateExpression = { 'GroupBy': [], 'Aggregate': {} };

    // the aggregate expression will be the last argument when initializing the query
    var aggregateExpression = arguments[6];
    var groupBy;
    var aggregate;
    if (aggregateExpression) {
        groupBy = aggregateExpression.GroupBy;
        aggregate = aggregateExpression.Aggregate;
    }

    this.aggregateExpression = { 'GroupBy': groupBy || [], 'Aggregate': aggregate || {} };
};

_util2.default.inherits(AggregateQuery, _Query2.default);

// wrapper formatter to all aggregate functions, like min/max/sum/average/count
AggregateQuery.prototype._aggregateFunc = function _aggregateFunc(funcName, fieldName, destName) {
    if (typeof fieldName !== 'string' && funcName !== 'count') {
        throw new _EverliveError.EverliveError(funcName + '() accepts only string as parameter.');
    }
    var aggregationObj = {};
    aggregationObj[funcName] = fieldName;
    this.aggregateExpression.Aggregate[destName || fieldName] = aggregationObj;
    return this;
};

/** Applies a groupBy to the current query. This allows you to group results by
 * @memberOf AggregateQuery.prototype
 * @method groupBy
 * @name groupBy
 * @param {String} field to group by
 * @param {Array} array of strings with fields to group by
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.groupBy = function (data) {
    if (_underscore2.default.isArray(data)) {
        Array.prototype.push.apply(this.aggregateExpression.GroupBy, data);
    } else {
        if (typeof data === 'string') {
            this.aggregateExpression.GroupBy.push(data);
        } else {
            throw new _EverliveError.EverliveError('groupBy() accepts only array or string as parameter.');
        }
    }
    return this;
};
/** Adds aggregation function 'avg' (average) to the current query. Could set [resultFieldName]
 * @memberOf AggregateQuery.prototype
 * @method avg
 * @name avg
 * @param {String} field to apply aggregate function on
 * @param {String} [resultFieldName] (Optional) Name of resulting field
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.avg = function () {
    Array.prototype.unshift.call(arguments, 'avg');
    return this._aggregateFunc.apply(this, arguments);
};

/** Adds aggregation function 'count' to the current query. Could set [resultFieldName]
 * @memberOf AggregateQuery.prototype
 * @method count
 * @name count
 * @param {String} field to apply aggregate function on
 * @param {String} [resultFieldName] (Optional) Name of resulting field
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.count = function (resultFieldName) {
    return this._aggregateFunc('count', null, resultFieldName || 'Count');
};

/** Adds aggregation function 'max' to the current query. Could set [resultFieldName]
 * @memberOf AggregateQuery.prototype
 * @method max
 * @name max
 * @param {String} field to apply aggregate function on
 * @param {String} [resultFieldName] (Optional) Name of resulting field
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.max = function () {
    Array.prototype.unshift.call(arguments, 'max');
    return this._aggregateFunc.apply(this, arguments);
};

/** Adds aggregation function 'min' to the current query. Could set [resultFieldName]
 * @memberOf AggregateQuery.prototype
 * @method min
 * @name min
 * @param {String} field to apply aggregate function on
 * @param {String} [resultFieldName] (Optional) Name of resulting field
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.min = function () {
    Array.prototype.unshift.call(arguments, 'min');
    return this._aggregateFunc.apply(this, arguments);
};

/** Adds aggregation function 'sum' to the current query. Could set [resultFieldName]
 * @memberOf AggregateQuery.prototype
 * @method sum
 * @name sum
 * @param {String} field to apply aggregate function on
 * @param {String} [resultFieldName] (Optional) Name of resulting field
 * @returns {AggregateQuery}
 */
AggregateQuery.prototype.sum = function () {
    Array.prototype.unshift.call(arguments, 'sum');
    return this._aggregateFunc.apply(this, arguments);
};

AggregateQuery.prototype.select = undefined;
AggregateQuery.prototype.skip = undefined;
AggregateQuery.prototype.take = undefined;
AggregateQuery.prototype.order = undefined;

AggregateQuery.prototype.average = AggregateQuery.prototype.avg;

module.exports = AggregateQuery;

},{"../../everlive/EverliveError":58,"../../everlive/query/Query":96,"underscore":36,"util":7}],95:[function(require,module,exports){
'use strict';

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class EventQuery
 * @classdesc A query which is passed in the 'beforeExecute' event of [Everlive]{@link Everlive}. Allows changing the parameters of
 * a query before executing it.
 */
var EventQuery = function EventQuery() {};

/** The name of the content type, e.g. EmailSubcrbers.
 * @memberOf EventQuery.prototype
 * @member {string} contentTypeName
 */

/** The query data which will be send to the server.
 * @memberOf EventQuery.prototype
 * @member {Object} data
 */

/** The query headers which will be send with the HTTP request.
 * @memberOf EventQuery.prototype
 * @member {Object} headers
 */

/** The Id of the item.
 * @memberOf EventQuery.prototype
 * @member {string} itemId
 */

/** The type of the operation--read, write, update, delete.
 * @memberOf EventQuery.prototype
 * @member {string} operation
 */

/** A power fields expression.
 * @memberOf EventQuery.prototype
 * @member {string} powerfields
 * @deprecated
 */

/** A custom settings object.
 * @memberOf EventQuery.prototype
 * @member {string} settings
 */

/** A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
 * @memberOf EventQuery.prototype
 * @member {Object} filter
 */

/** A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
 * @memberOf EventQuery.prototype
 * @member {Object} fields
 */

/** A [sort expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-sorting) definition.
 * @memberOf EventQuery.prototype
 * @member {Object} sort
 */

/** The number of result items to skip. Used for paging.
 * @memberOf EventQuery.prototype
 * @member {Number} skip
 */

/** The number of result items to take. Used for paging.
 * @memberOf EventQuery.prototype
 * @member {Number} take
 */

/** An [expand expression](http://docs.telerik.com/platform/backend-services/javascript/data/relations/relations-defining) definition.
 * @memberOf EventQuery.prototype
 * @member {Object} expand
 */

/** Indicates whether the query is a synchronization query. Used with Offline Support.
 * @memberOf EventQuery.prototype
 * @member {boolean} isSync
 * @readonly
 */

function applyDataQueryParameters(eventQuery, dataQuery) {
  var queryParameters = dataQuery.getQueryParameters();
  eventQuery.filter = queryParameters.filter;
  eventQuery.fields = queryParameters.select;
  eventQuery.sort = queryParameters.sort;
  eventQuery.skip = queryParameters.skip;
  eventQuery.take = queryParameters.limit || queryParameters.take;
  eventQuery.expand = queryParameters.expand;
  eventQuery.aggregate = queryParameters.aggregate;
  return queryParameters;
}

/** An object allowing to modify the settings of the EventQuery.
 * @memberOf EventQuery.prototype
 * @member {Object} settings
 * @property {boolean} useOffline - Modifies whether the query should be invoked on the offline storage.
 * @property {boolean} applyOffline - Modifies whether the query should be applied offline if the SDK is currently working online. Default is true. Only valid when offlineStorage is enabled.
 * @property {boolean} ignoreCache - Does not use the cache when retrieving the data. Only valid when caching is enabled.
 * @property {boolean} forceCache - Forces the request to get the data from the cache even if the data is already expired. Only valid when caching is enabled.
 */

function applyDataQuerySettings(eventQuery, dataQuery) {
  eventQuery.settings = {
    useOffline: dataQuery.useOffline,
    applyOffline: dataQuery.applyOffline,
    ignoreCache: dataQuery.ignoreCache,
    forceCache: dataQuery.forceCache
  };
}

EventQuery.fromDataQuery = function (dataQuery) {
  var eventQuery = new EventQuery();
  eventQuery.contentTypeName = dataQuery.collectionName;
  if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
    switch (dataQuery.operation) {
      case _constants2.default.DataQueryOperations.Update:
        eventQuery.operation = _constants2.default.DataQueryOperations.UpdateById;
        break;
      case _constants2.default.DataQueryOperations.Delete:
        eventQuery.operation = _constants2.default.DataQueryOperations.DeleteById;
        break;
      default:
        eventQuery.operation = dataQuery.operation;
    }
  } else {
    eventQuery.operation = dataQuery.operation;
  }

  eventQuery.itemId = dataQuery.additionalOptions ? dataQuery.additionalOptions.id : undefined;
  eventQuery.data = dataQuery.data;

  applyDataQuerySettings(eventQuery, dataQuery);
  applyDataQueryParameters(eventQuery, dataQuery);
  eventQuery.headers = dataQuery.getHeaders();
  var powerFieldsHeader = eventQuery.headers[_constants2.default.Headers.powerFields];
  if (typeof powerFieldsHeader === 'string') {
    eventQuery.powerfields = JSON.parse(powerFieldsHeader);
  }
  eventQuery.isSync = dataQuery.isSync; // readonly

  return eventQuery;
};

/**
 * Cancels the query.
 * @memberOf EventQuery.prototype
 * @method cancel
 */

/**
 * Indicates whether the query has been canceled.
 * @memberOf EventQuery.prototype
 * @method isCanceled
 * @returns {boolean}
 */

EventQuery.prototype = {
  cancel: function cancel() {
    this._cancelled = true;
  },
  isCancelled: function isCancelled() {
    return this._cancelled;
  }
};

module.exports = EventQuery;

},{"../../everlive/constants":70}],96:[function(require,module,exports){
'use strict';

var _Expression = require('../../everlive/Expression');

var _Expression2 = _interopRequireDefault(_Expression);

var _constants = require('../../everlive/constants');

var _WhereQuery = require('../../everlive/query/WhereQuery');

var _WhereQuery2 = _interopRequireDefault(_WhereQuery);

var _QueryBuilder = require('../../everlive/query/QueryBuilder');

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

var _Query = require('../../common/query/Query');

var _Query2 = _interopRequireDefault(_Query);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Query = function (_CommonQuery) {
    _inherits(Query, _CommonQuery);

    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
     * @param {object} [fields] A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
     * @param {object} [sort] A [sort expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-sorting) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        _classCallCheck(this, Query);

        var _this = _possibleConstructorReturn(this, _CommonQuery.call(this));

        _this.filter = filter;
        _this.fields = fields;
        _this.sort = sort;
        _this.toskip = skip;
        _this.totake = take;
        _this.expandExpression = expand;
        _this.expr = new _Expression2.default(_constants.OperatorType.query);
        return _this;
    }

    /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
     * @memberOf Query.prototype
     * @method where
     * @name where
     * @param {object} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
     * @returns {Query}
     */
    /** Defines a filter definition for the current query.
     * @memberOf Query.prototype
     * @method where
     * @name where
     * @returns {WhereQuery}
     */
    /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
     * @memberOf Query.prototype
     * @method select
     * @param {object} fieldsExpression A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
     * @returns {Query}
     */


    Query.prototype.where = function where(filter) {
        if (filter) {
            return this._simple(_constants.OperatorType.filter, [filter]);
        } else {
            return new _WhereQuery2.default(this);
        }
    };

    // TODO
    //exclude: function () {
    //    return this._simple(OperatorType.exclude, arguments);
    //},
    /** Sorts the items in the current query in ascending order by the specified field.
     * @memberOf Query.prototype
     * @method order
     * @param {string} field The field name to order by in ascending order.
     * @returns {Query}
     */


    Query.prototype.select = function select() {
        return this._simple(_constants.OperatorType.select, arguments);
    };

    /** Sorts the items in the current query in descending order by the specified field.
     * @memberOf Query.prototype
     * @method orderDesc
     * @param {string} field The field name to order by in descending order.
     * @returns {Query}
     */


    Query.prototype.order = function order(field) {
        return this._simple(_constants.OperatorType.order, [field]);
    };

    /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
     * @memberOf Query.prototype
     * @method skip
     * @see [query.take]{@link query.take}
     * @param {number} value The number of items to skip.
     * @returns {Query}
     */


    Query.prototype.orderDesc = function orderDesc(field) {
        return this._simple(_constants.OperatorType.order_desc, [field]);
    };

    /** Takes a specified number of items from the query result. Used for paging.
     * @memberOf Query.prototype
     * @method take
     * @see [query.skip]{@link query.skip}
     * @param {number} value The number of items to take.
     * @returns {Query}
     */


    Query.prototype.skip = function skip(value) {
        return this._simple(_constants.OperatorType.skip, [value]);
    };

    /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
     * @memberOf Query.prototype
     * @method expand
     * @param {object} expandExpression An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
     * @returns {Query}
     */


    Query.prototype.take = function take(value) {
        return this._simple(_constants.OperatorType.take, [value]);
    };

    /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
     * @memberOf Query.prototype
     * @method build
     * @returns {{$where,$select,$sort,$skip,$take,$expand}}
     */


    Query.prototype.expand = function expand(expandExpression) {
        return this._simple(_constants.OperatorType.expand, [expandExpression]);
    };

    Query.prototype.build = function build() {
        return new _QueryBuilder2.default(this).build();
    };

    Query.prototype._simple = function _simple(op, oprs) {
        var args = [].slice.call(oprs);
        this.expr.addOperand(new _Expression2.default(op, args));
        return this;
    };

    return Query;
}(_Query2.default);

module.exports = Query;

},{"../../common/query/Query":53,"../../everlive/Expression":60,"../../everlive/constants":70,"../../everlive/query/QueryBuilder":97,"../../everlive/query/WhereQuery":99}],97:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _constants = require('../../everlive/constants');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _GeoPoint = require('../../everlive/GeoPoint');

var _GeoPoint2 = _interopRequireDefault(_GeoPoint);

var _EverliveError = require('../../everlive/EverliveError');

var _Expression = require('../../everlive/Expression');

var _Expression2 = _interopRequireDefault(_Expression);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function build() {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
                // || query.aggregateExpression) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expandExpression || null,
                    $aggregate: query.aggregateExpression || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand(),
                $aggregate: this._getAggregate()
            };
        },
        _getSkip: function _getSkip() {
            var skipExpression = _underscore2.default.find(this.expr.operands, function (value, index, list) {
                return value.operator === _constants.OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function _getTake() {
            var takeExpression = _underscore2.default.find(this.expr.operands, function (value, index, list) {
                return value.operator === _constants.OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function _getExpand() {
            var expandExpression = _underscore2.default.chain(this.expr.operands).filter(function (value) {
                return value.operator === _constants.OperatorType.expand;
            }).reduce(function (result, expression) {
                //expression contains operands and has operator type expand
                return _underscore2.default.extend(result, expression.operands[0]);
            }, {}).value();
            return _underscore2.default.isEmpty(expandExpression) ? null : expandExpression;
        },
        _getAggregate: function _getAggregate() {
            if (!this.query.aggregateExpression) {
                return null;
            }

            // build $aggregate, delete empty aggregates, fail no aggregates at all
            var aggregates = _underscore2.default.extend({}, this.query.aggregateExpression);
            if (_underscore2.default.isEmpty(aggregates.GroupBy)) {
                delete aggregates.GroupBy;
            }
            if (_underscore2.default.isEmpty(aggregates.Aggregate)) {
                delete aggregates.Aggregate;
            }

            return aggregates;
        },
        _buildSelect: function _buildSelect() {
            var selectExpression = _underscore2.default.find(this.expr.operands, function (value, index, list) {
                return value.operator === _constants.OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _underscore2.default.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            } else {
                return null;
            }
        },
        _buildSort: function _buildSort() {
            var sortExpressions = _underscore2.default.filter(this.expr.operands, function (value, index, list) {
                return value.operator === _constants.OperatorType.order || value.operator === _constants.OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _underscore2.default.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === _constants.OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            } else {
                return null;
            }
        },
        _buildWhere: function _buildWhere() {
            var whereExpression = _underscore2.default.find(this.expr.operands, function (value, index, list) {
                return value.operator === _constants.OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new _Expression2.default(_constants.OperatorType.and, whereExpression.operands));
            } else {
                var filterExpression = _underscore2.default.find(this.expr.operands, function (value, index, list) {
                    return value.operator === _constants.OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function _build(expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            } else if (this._isRegex(expr)) {
                return this._regex(expr);
            } else if (this._isGeo(expr)) {
                return this._geo(expr);
            } else if (this._isAnd(expr)) {
                return this._and(expr);
            } else if (this._isOr(expr)) {
                return this._or(expr);
            } else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function _isSimple(expr) {
            return expr.operator >= _constants.OperatorType.equal && expr.operator <= _constants.OperatorType.size;
        },
        _simple: function _simple(expr) {
            var term = {},
                fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            } else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function _isRegex(expr) {
            return expr.operator >= _constants.OperatorType.regex && expr.operator <= _constants.OperatorType.endsWith;
        },
        _regex: function _regex(expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function _getRegex(expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case _constants.OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case _constants.OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case _constants.OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new _EverliveError.EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function _getRegexValue(regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return { $regex: regex.source, $options: options };
        },
        _isGeo: function _isGeo(expr) {
            return expr.operator >= _constants.OperatorType.nearShpere && expr.operator <= _constants.OperatorType.withinShpere;
        },
        _geo: function _geo(expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function _getGeoTerm(expr) {
            switch (expr.operator) {
                case _constants.OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case _constants.OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case _constants.OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case _constants.OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new _EverliveError.EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function _getNearSphereTerm(expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = _constants.maxDistanceConsts[metrics] || _constants.maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function _getWithinBox(expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function _getWithinPolygon(expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function _getWithinCenterSphere(expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = _constants.radiusConsts[metrics] || _constants.radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function _getGeoPoint(point) {
            if (_underscore2.default.isArray(point)) {
                return new _GeoPoint2.default(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function _getGeoPoints(points) {
            var self = this;
            return _underscore2.default.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function _isAnd(expr) {
            return expr.operator === _constants.OperatorType.and;
        },
        _and: function _and(expr) {
            var i,
                l,
                term,
                result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function _andAppend(andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _underscore2.default.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                } else {
                    newValue = newObj[key];
                    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && (typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object') {
                        value = _underscore2.default.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function _isOr(expr) {
            return expr.operator === _constants.OperatorType.or;
        },
        _or: function _or(expr) {
            var i,
                l,
                term,
                result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return { $or: result };
        },
        _isNot: function _isNot(expr) {
            return expr.operator === _constants.OperatorType.not;
        },
        _not: function _not(expr) {
            return { $not: this._build(expr.operands[0]) };
        },
        _translateoperator: function _translateoperator(operator) {
            switch (operator) {
                case _constants.OperatorType.equal:
                    return null;
                case _constants.OperatorType.not_equal:
                    return '$ne';
                case _constants.OperatorType.gt:
                    return '$gt';
                case _constants.OperatorType.lt:
                    return '$lt';
                case _constants.OperatorType.gte:
                    return '$gte';
                case _constants.OperatorType.lte:
                    return '$lte';
                case _constants.OperatorType.isin:
                    return '$in';
                case _constants.OperatorType.notin:
                    return '$nin';
                case _constants.OperatorType.all:
                    return '$all';
                case _constants.OperatorType.size:
                    return '$size';
            }
            throw new _EverliveError.EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}();

},{"../../everlive/EverliveError":58,"../../everlive/Expression":60,"../../everlive/GeoPoint":61,"../../everlive/constants":70,"underscore":36}],98:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _constants = require('../../everlive/constants');

var _Request = require('../../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var isQueryById = dataQuery.additionalOptions && dataQuery.additionalOptions.id !== undefined;
        var queryType = _typeof(dataQuery.query);

        if (isQueryById) {
            endpoint = _path2.default.join(endpoint, dataQuery.additionalOptions.id.toString());
        } else if (queryType === 'string' || queryType === 'number') {
            endpoint = _path2.default.join(endpoint, dataQuery.query);
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            query: dataQuery.query,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        var options = _underscore2.default.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);

        if (additionalOptions.endpointSupplement) {
            options.endpoint = _path2.default.join(options.endpoint, additionalOptions.endpointSupplement);
        }

        return options;
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.ReadById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.RawUpdate] = function (dataQuery) {
        var query = dataQuery.query;
        var ofilter = (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object' ? query : null; // request options filter

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            query: ofilter
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Delete] = function (dataQuery) {
        return _underscore2.default.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.DeleteById] = RequestOptionsBuilder[_constants.DataQueryOperations.Delete];

    RequestOptionsBuilder[_constants.DataQueryOperations.SetAcl] = function (dataQuery) {
        var method = void 0,
            data = void 0;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpointSupplement: '/_acl',
            data: data
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.SetOwner] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpointSupplement: '/_owner'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: _Request2.default.parsers.single
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            parse: _Request2.default.parsers.single
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserResetPassword] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/resetpassword'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.UserSetPassword] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/setpassword'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.FilesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.FilesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[_constants.DataQueryOperations.Aggregate] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_aggregate'
        });
    };

    function businessLogic(dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, dataQuery.additionalOptions);
    }

    RequestOptionsBuilder[_constants.DataQueryOperations.InvokeCloudFunction] = businessLogic;
    RequestOptionsBuilder[_constants.DataQueryOperations.InvokeStoredProcedure] = businessLogic;

    return RequestOptionsBuilder;
}();

},{"../../everlive/Request":63,"../../everlive/constants":70,"path":4,"underscore":36}],99:[function(require,module,exports){
'use strict';

var _Expression = require('../../everlive/Expression');

var _Expression2 = _interopRequireDefault(_Expression);

var _constants = require('../../everlive/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new _Expression2.default(exprOp || _constants.OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function and() {
            return new WhereQuery(this, _constants.OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function or() {
            return new WhereQuery(this, _constants.OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function not() {
            return new WhereQuery(this, _constants.OperatorType.not, true);
        },
        _simple: function _simple(operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new _Expression2.default(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function eq(field, value) {
            return this._simple(_constants.OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function ne(field, value) {
            return this._simple(_constants.OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function gt(field, value) {
            return this._simple(_constants.OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function gte(field, value) {
            return this._simple(_constants.OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function lt(field, value) {
            return this._simple(_constants.OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function lte(field, value) {
            return this._simple(_constants.OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function isin(field, value) {
            return this._simple(_constants.OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function notin(field, value) {
            return this._simple(_constants.OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function all(field, value) {
            return this._simple(_constants.OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function size(field, value) {
            return this._simple(_constants.OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function regex(field, value, flags) {
            return this._simple(_constants.OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function startsWith(field, value, flags) {
            return this._simple(_constants.OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function endsWith(field, value, flags) {
            return this._simple(_constants.OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function nearSphere(field, point, distance, metrics) {
            return this._simple(_constants.OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function withinBox(field, pointBottomLeft, pointUpperRight) {
            return this._simple(_constants.OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);
           var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function withinPolygon(field, points) {
            return this._simple(_constants.OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function withinCenterSphere(field, center, radius, metrics) {
            return this._simple(_constants.OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function done() {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function _done() {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}();

},{"../../everlive/Expression":60,"../../everlive/constants":70}],100:[function(require,module,exports){
'use strict';

var _platform = require('../common/platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
    var isNativeScript = _platform2.default.isNativeScript;
    var isNodejs = _platform2.default.isNodejs;

    var reqwest = void 0;
    if (!isNodejs && !isNativeScript) {
        reqwest = require('reqwest');
    } else if (isNativeScript) {
        reqwest = require('./reqwest.nativescript');
    } else if (isNodejs) {
        reqwest = require('./reqwest.nodejs');
    }

    return reqwest;
}();

},{"../common/platform":51,"./reqwest.nativescript":101,"./reqwest.nodejs":102,"reqwest":34}],101:[function(require,module,exports){
'use strict';

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var http = require('http');


// NodeJS nulls header name casing by lowering all casing,
// we simulate this in NS with this function to avoid header name issues
function getCaseInsensitiveHeaders(headers) {
    var result = {};

    for (var headerName in headers) {
        if (headers.hasOwnProperty(headerName)) {
            result[headerName.toLowerCase()] = headers[headerName];
        }
    }

    return result;
}

module.exports = function () {
    'use strict';

    function reqwest(options) {
        var httpRequestOptions = {
            url: options.url,
            method: options.method,
            headers: options.headers || {}
        };

        if (options.data) {
            httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
        }

        httpRequestOptions.headers[_constants2.default.Headers.ContentType] = httpRequestOptions.contentType || 'application/json';

        return new _rsvp2.default.Promise(function (resolve, reject) {
            return http.request(httpRequestOptions).then(function (response) {
                var contentString = response.content.toString();
                var content = JSON.parse(contentString);
                if (response.statusCode < 400) {
                    resolve(content);
                } else {
                    reject(contentString);
                }
            }, function (error) {
                // possible reasons: no internet connectivity
                // error is an object with message (contains the reason) and stack (null)
                reject(error);
            });
        });
    }

    return reqwest;
}();

},{"../everlive/constants":70,"http":"http","rsvp":35}],102:[function(require,module,exports){
(function (Buffer){
'use strict';

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var url = require('url');
var http = require('http');
var https = require('https');
var zlib = require('zlib');

module.exports = function () {
    'use strict';

    function reqwest(options) {
        var urlParts = url.parse(options.url);
        var request = void 0;
        if (urlParts.protocol === 'https:') {
            request = https.request;
        } else {
            request = http.request;
        }
        var headers = options.headers || {};

        headers[_constants2.default.Headers.ContentType] = options.contentType;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var req = request({
                method: options.method,
                hostname: urlParts.hostname,
                port: urlParts.port,
                path: urlParts.path,
                headers: headers
            }, function (res) {
                var json = '';
                var contentEncoding = res.headers['content-encoding'];
                var responseProxy = void 0;
                switch (contentEncoding) {
                    case 'gzip':
                        responseProxy = zlib.createGunzip();
                        res.pipe(responseProxy);
                        break;
                    default:
                        responseProxy = res;
                        responseProxy.setEncoding('utf8');
                        break;
                }

                responseProxy.on('data', function (data) {
                    json += data.toString();
                });

                responseProxy.on('end', function () {
                    // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
                    if (200 <= res.statusCode && res.statusCode < 400) {
                        var result = JSON.parse(json);
                        resolve(result);
                    } else {
                        if (json) {
                            reject(json);
                        } else {
                            // empty response
                            var error = new Error('Response error.');
                            error.statusCode = res.statusCode;
                            reject(error);
                        }
                    }
                });
            });

            req.on('error', function (e) {
                reject({ responseText: e });
            });

            if (options.data) {
                var contentEncoding = headers['content-encoding'];
                switch (contentEncoding) {
                    case 'gzip':
                        var buf = new Buffer(options.data, 'utf-8');
                        zlib.gzip(buf, function (err, result) {
                            req.end(result);
                        });
                        break;
                    default:
                        req.end(options.data);
                        break;
                }
            } else {
                req.end();
            }
        });
    }

    return reqwest;
}();

}).call(this,require("buffer").Buffer)

},{"../everlive/constants":70,"buffer":"buffer","http":"http","https":"https","rsvp":35,"url":"url","zlib":"zlib"}],103:[function(require,module,exports){
'use strict';

var _constants = require('../../everlive/constants');

var _Request = require('../../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResponseProcessor = function () {
    function ResponseProcessor() {
        _classCallCheck(this, ResponseProcessor);
    }

    ResponseProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (query.operation === _constants.DataQueryOperations.InvokeCloudFunction || query.operation === _constants.DataQueryOperations.InvokeStoredProcedure) {
            return iterator.next(value);
        }

        var parser = null;
        switch (query.operation) {
            case _constants.DataQueryOperations.ReadById:
            case _constants.DataQueryOperations.Aggregate:
            case _constants.DataQueryOperations.Count:
            case _constants.DataQueryOperations.Create:
            case _constants.DataQueryOperations.SetAcl:
            case _constants.DataQueryOperations.FilesGetDownloadUrlById:
            case _constants.DataQueryOperations.UserLinkWithProvider:
            case _constants.DataQueryOperations.UserUnlinkFromProvider:
                parser = _Request2.default.parsers.single;
                break;
            case _constants.DataQueryOperations.RawUpdate:
            case _constants.DataQueryOperations.Update:
                parser = _Request2.default.parsers.update;
                break;
            default:
                if (query.isCustomRequest) {
                    parser = _Request2.default.parsers.customRequest;
                } else {
                    parser = _Request2.default.parsers.simple;
                }
        }

        var parsedResponse = parser.result(value);

        return iterator.next(parsedResponse);
    };

    return ResponseProcessor;
}();

module.exports = ResponseProcessor;

},{"../../everlive/Request":63,"../../everlive/constants":70}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _constants = require('../../everlive/constants');

var _underscore = require('underscore');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//TODO: is this really needed or is obsolete, or at least parts of it
var ResponseDataMergeProcessor = function () {
    function ResponseDataMergeProcessor() {
        _classCallCheck(this, ResponseDataMergeProcessor);
    }

    ResponseDataMergeProcessor.prototype.mergeResultData = function mergeResultData(data, res) {
        var attrs = res.result;
        // support for kendo observable array
        if ((0, _underscore.isArray)(data) || typeof data.length === 'number') {
            (0, _underscore.each)(data, function (item, index) {
                (0, _underscore.extend)(item, attrs[index]);
            });
        } else {
            (0, _underscore.extend)(data, attrs);
        }

        return res;
    };

    ResponseDataMergeProcessor.prototype.mergeUpdateResultData = function mergeUpdateResultData(data, res) {
        var modifiedAt = res.ModifiedAt;
        data.ModifiedAt = modifiedAt;
        return res;
    };

    ResponseDataMergeProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        var result = null;
        switch (query.operation) {
            case _constants.DataQueryOperations.Update:
                result = this.mergeUpdateResultData(query.data, value);
                break;
            case _constants.DataQueryOperations.Create:
                result = this.mergeResultData(query.data, value);
                break;
            case _constants.DataQueryOperations.FilesGetDownloadUrlById:
                result = value.result.Uri;
                break;
            default:
                result = value;
                break;
        }

        return iterator.next(result);
    };

    return ResponseDataMergeProcessor;
}();

exports.default = ResponseDataMergeProcessor;

},{"../../everlive/constants":70,"underscore":36}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RequestService = undefined;

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _Request = require('../../everlive/Request');

var _Request2 = _interopRequireDefault(_Request);

var _utils = require('../../everlive/utils');

var _RequestOptionsBuilder = require('../../everlive/query/RequestOptionsBuilder');

var _RequestOptionsBuilder2 = _interopRequireDefault(_RequestOptionsBuilder);

var _EverliveError = require('../../everlive/EverliveError');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RequestService = exports.RequestService = {
    buildRequest: function buildRequest(query, data) {
        var getRequestOptionsFromQuery = _RequestOptionsBuilder2.default[query.operation];
        var requestOptions = getRequestOptionsFromQuery(query);
        data._setAdditionalHeaders(query, requestOptions);
        return new _Request2.default(data.sdk.setup, requestOptions);
    },


    /**
     * Sends a request and if it must applies the result offline.
     * @param query
     * @param data
     * @param [request]
     * @returns {Promise} Resolves with the response.
     */
    handleRequestProcessing: function handleRequestProcessing(query, data) {
        var request = arguments.length <= 2 || arguments[2] === undefined ? this.buildRequest(query, data) : arguments[2];

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var successData = void 0;

            request.send().then(function (res) {
                successData = res;
                if (query.applyOffline) {
                    return data._applyOffline(query, successData);
                } else {
                    return successData;
                }
            }, function (err) {
                reject(err);
            }).then(function () {
                resolve(successData);
            }, function (err) {
                var notSupported = _EverliveError.EverliveErrors.operationNotSupportedOffline.code;
                var notFound = _EverliveError.EverliveErrors.itemNotFound.code;

                var online = !query.canUseOffline || !query.useCache;
                if (online && (err.code === notSupported || err.code === notFound)) {
                    resolve(successData);
                } else {
                    reject(err);
                }
            });
        });
    },


    /**
     * Sends a request.
     * @param request
     * @returns {Promise} Resolves with the parsed response.
     */
    sendRequest: function sendRequest(request) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            request.send().then(function (res) {
                var result = res.Result || res;
                var reviver = _utils.parseUtilities.getReviver();
                _utils.parseUtilities.parseResult(reviver, result);
                resolve(result);
            }, function (err) {
                reject(err);
            });
        });
    }
};

},{"../../everlive/EverliveError":58,"../../everlive/Request":63,"../../everlive/query/RequestOptionsBuilder":98,"../../everlive/utils":121,"rsvp":35}],106:[function(require,module,exports){
'use strict';

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _WebFileStore = require('../../everlive/storages/WebFileStore');

var _WebFileStore2 = _interopRequireDefault(_WebFileStore);

var _NativeScriptFileStore = require('../../everlive/storages/NativeScriptFileStore');

var _NativeScriptFileStore2 = _interopRequireDefault(_NativeScriptFileStore);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (_everlive2.default.isNativeScript) {
    module.exports = _NativeScriptFileStore2.default;
} else if (_everlive2.default.isCordova || _everlive2.default.isDesktop) {
    module.exports = _WebFileStore2.default;
} else {
    module.exports = _underscore2.default.noop;
}

},{"../../everlive/everlive.platform":74,"../../everlive/storages/NativeScriptFileStore":108,"../../everlive/storages/WebFileStore":109,"underscore":36}],107:[function(require,module,exports){
'use strict';

var _everlive = require('../../everlive/everlive.platform');

module.exports = function () {
    'use strict';

    function initLocalStorage(options) {
        if (_everlive.isNativeScript) {
            var localSettings;

            //workound for older nativescript versions
            try {
                localSettings = require('application-settings');
            } catch (e) {
                localSettings = require('local-settings');
            }

            return {
                getItem: function getItem(key) {
                    return localSettings.getString(key);
                },

                removeItem: function removeItem(key) {
                    return localSettings.remove(key);
                },

                setItem: function setItem(key, value) {
                    return localSettings.setString(key, value);
                }
            };
        } else {
            var localStorage;
            if (_everlive.isNodejs) {
                var LocalStorage = require('node-localstorage').LocalStorage;
                localStorage = new LocalStorage(options.storage.storagePath);
            } else {
                localStorage = window.localStorage;
            }

            return {
                getItem: function getItem(key) {
                    return localStorage.getItem(key);
                },

                removeItem: function removeItem(key) {
                    return localStorage.removeItem(key);
                },

                setItem: function setItem(key, value) {
                    return localStorage.setItem(key, value);
                }
            };
        }
    }

    function LocalStore(options) {
        this.options = options;
        this._localStorage = initLocalStorage(this.options);
    }

    LocalStore.prototype = {
        getItem: function getItem(key) {
            return this._localStorage.getItem(key);
        },

        removeItem: function removeItem(key) {
            return this._localStorage.removeItem(key);
        },

        setItem: function setItem(key, value) {
            return this._localStorage.setItem(key, value);
        }
    };

    return LocalStore;
}();

},{"../../everlive/everlive.platform":74,"application-settings":"application-settings","local-settings":"local-settings","node-localstorage":"node-localstorage"}],108:[function(require,module,exports){
'use strict';

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function NativeScriptFileStore(storagePath, options) {
    this.options = options;
    this.fs = require('file-system');
    this.dataDirectoryPath = this.fs.knownFolders.documents().path;
    this.filesDirectoryPath = this.fs.path.join(this.dataDirectoryPath, storagePath);
}

NativeScriptFileStore.prototype = {
    getErrorHandler: function getErrorHandler(callback) {
        return function (e) {
            callback && callback(e);
        };
    },

    removeFilesDirectory: function removeFilesDirectory() {
        var self = this;

        return self.getFilesDirectory().then(function (filesDirectory) {
            return filesDirectory.remove();
        });
    },

    removeFile: function removeFile(fileEntry) {
        return fileEntry.remove();
    },

    readFileAsText: function readFileAsText(fileEntry) {
        return fileEntry.readText();
    },

    writeTextToFile: function writeTextToFile(fileEntry, content) {
        return fileEntry.writeText(content);
    },

    getFile: function getFile(path) {
        var self = this;
        return new _rsvp2.default.Promise(function (resolve, reject) {
            self.resolveDataDirectory().then(function (directoryEntry) {
                var fullFilePath = self.fs.path.join(directoryEntry.path, path);
                var file = self.fs.File.fromPath(fullFilePath);
                resolve(file);
            }).catch(reject);
        });
    },

    getFilesDirectory: function getFilesDirectory() {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve) {
            var filesDirectory = self.fs.Folder.fromPath(self.filesDirectoryPath);
            resolve(filesDirectory);
        });
    },

    resolveDataDirectory: function resolveDataDirectory() {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve) {
            var dataDirectory = self.fs.Folder.fromPath(self.dataDirectoryPath);
            resolve(dataDirectory);
        });
    },

    ensureFilesDirectory: function ensureFilesDirectory() {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            self.resolveDataDirectory().then(function (directoryEntry) {
                var fileDirectoryPath = self.fs.path.join(directoryEntry.path, self.filesDirectoryPath);
                self.fs.Folder.fromPath(fileDirectoryPath);
                resolve();
            }).catch(reject);
        });
    },

    getFilesDirectoryPath: function getFilesDirectoryPath() {
        return this.filesDirectoryPath;
    },

    // TODO: [offline] Implement
    writeText: function writeText(fileName, text) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    createDirectory: function createDirectory() {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileSize: function getFileSize(file, _getFileSize) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileByAbsolutePath: function getFileByAbsolutePath(path) {
        throw new Error('Not implemented');
    },

    readFileAsBase64: function readFileAsBase64(file) {
        throw new Error('Not implemented');
    },

    renameFile: function renameFile() {
        throw new Error('Not implemented');
    }
};

module.exports = NativeScriptFileStore;

},{"file-system":"file-system","rsvp":35}],109:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _EverliveError = require('../../everlive/EverliveError');

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var deviceReadyPromise = function deviceReadyPromise() {
    return new _rsvp2.default.Promise(function (resolve) {
        document.addEventListener('deviceready', resolve);
    });
};

function WebFileStore(storagePath, options) {
    this.options = options;

    var filesDirectoryPath;

    if (_everlive2.default.isWindowsPhone || _everlive2.default.isInAppBuilderSimulator()) {
        //windows phone does not handle leading or trailing slashes very well :(
        filesDirectoryPath = storagePath.replace(new RegExp('/', 'g'), '');
    } else {
        if (storagePath.lastIndexOf('/') === -1) {
            filesDirectoryPath = storagePath + '/';
        }
    }

    filesDirectoryPath = filesDirectoryPath || storagePath;

    var self = this;

    deviceReadyPromise().then(function () {
        self.filesDirectoryPath = filesDirectoryPath;
        self._requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        self._resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;
        self._PERSISTENT_FILE_SYSTEM = window.LocalFileSystem ? window.LocalFileSystem.PERSISTENT : window.PERSISTENT;
    });
}

WebFileStore.prototype = {
    getErrorHandler: function getErrorHandler(callback) {
        var errorsMap = {
            '1000': 'NOT_FOUND'
        };

        _underscore2.default.each(Object.keys(FileError), function (error) {
            errorsMap[FileError[error]] = error;
        });

        return function (e) {
            if (!e.message) {
                e.message = errorsMap[e.code];
            }

            callback && callback(e);
        };
    },

    getDataDirectory: function () {
        var fileSystemRoot;

        return function getDataDirectory() {
            var self = this;

            return deviceReadyPromise().then(function () {
                var requestFileSystem = function requestFileSystem(bytes, success, error) {
                    self._requestFileSystem.call(window, self._PERSISTENT_FILE_SYSTEM, bytes, function (fileSystem) {
                        fileSystemRoot = fileSystem.root;
                        fileSystemRoot.nativeURL = fileSystemRoot.nativeURL || fileSystemRoot.toURL();
                        success(fileSystemRoot);
                    }, error);
                };

                return new _rsvp2.default.Promise(function (resolve, reject) {
                    if (fileSystemRoot) {
                        return resolve(fileSystemRoot);
                    }

                    if (_everlive2.default.isDesktop) {
                        if (navigator && !navigator.webkitPersistentStorage) {
                            return reject(new _EverliveError.EverliveError('FileSystemStorage can be used only with browsers supporting it. Consider using localStorage.'));
                        }

                        navigator.webkitPersistentStorage.requestQuota(self.options.storage.requestedQuota, function (grantedBytes) {
                            requestFileSystem(grantedBytes, resolve, reject);
                        }, reject);
                    } else {
                        requestFileSystem(0, resolve, reject);
                    }
                });
            });
        };
    }(),

    getFilesDirectory: function getFilesDirectory() {
        var self = this;
        return new _rsvp2.default.Promise(function (resolve, reject) {
            self.getDataDirectory().then(function (dataDirectory) {
                dataDirectory.getDirectory(self.filesDirectoryPath, {
                    create: true,
                    exclusive: false
                }, resolve, reject);
            }).catch(reject);
        });
    },

    removeFilesDirectory: function removeFilesDirectory() {
        var self = this;

        return this.getFilesDirectory().then(function (filesDirectory) {
            return self._removeFolderWrap(filesDirectory);
        });
    },

    removeFile: function removeFile(fileEntry) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            fileEntry.remove(function () {
                resolve();
            }, reject);
        });
    },

    readFileAsText: function readFileAsText(fileEntry) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            self.getFilesDirectory().then(function () {
                fileEntry.file(function (file) {
                    var reader = new FileReader();
                    reader.onloadend = function () {
                        var result = this.result;

                        //windows phone returns an object....
                        if (_typeof(this.result) === 'object') {
                            result = JSON.stringify(this.result);
                        }

                        resolve(result);
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                }, reject);
            }).catch(reject);
        });
    },

    writeTextToFile: function writeTextToFile(fileEntry, content) {
        var self = this;

        return self.getFilesDirectory().then(function () {
            return self._getWriterWrap(fileEntry, content);
        });
    },

    getFileSize: function getFileSize(filename, folder) {
        var self = this;

        return new _rsvp2.default.Promise(function (resolve, reject) {
            var fileLocation = _utils2.default.joinPath(folder, filename);

            return self.getFile(fileLocation).then(function (fileEntry) {
                fileEntry.file(function (file) {
                    resolve(file.size);
                }, reject);
            });
        });
    },

    getFile: function getFile(fileName, dirEntry) {
        return this.getFilesDirectory().then(function (directoryEntry) {
            var fileDirectory;
            if (dirEntry) {
                fileDirectory = dirEntry;
            } else {
                fileDirectory = directoryEntry;
            }

            return new _rsvp2.default.Promise(function (resolve, reject) {
                fileDirectory.getFile(fileName, {
                    create: true,
                    exclusive: false
                }, resolve, reject);
            });
        });
    },

    getFileByAbsolutePath: function getFileByAbsolutePath(path) {
        var self = this;
        path = _utils2.default.transformPlatformPath(path);

        return new _rsvp2.default.Promise(function (resolve, reject) {
            self._resolveLocalFileSystemURL.call(window, path, resolve, function (err) {
                if (err && err.code === FileError.NOT_FOUND_ERR) {
                    return resolve();
                }

                return reject(err);
            });
        });
    },

    createDirectory: function createDirectory(directory) {
        var self = this;

        return this.getFilesDirectory().then(function (directoryEntry) {
            return self._getDirectoryWrap(directory, directoryEntry, {
                create: true,
                exclusive: false
            });
        });
    },

    renameFile: function renameFile(directoryEntry, fileEntry, filename) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            fileEntry.moveTo(directoryEntry, filename, resolve, reject);
        });
    },

    _getDirectoryWrap: function _getDirectoryWrap(directory, directoryEntry, options) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            directoryEntry.getDirectory(directory, options, resolve, reject);
        });
    },

    _removeFolderWrap: function _removeFolderWrap(filesDirEntry) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            filesDirEntry.removeRecursively(function () {
                resolve();
            }, reject);
        });
    },

    _getWriterWrap: function _getWriterWrap(fileEntry, content) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            fileEntry.createWriter(function (fileWriter) {
                fileWriter.onwriteend = function () {
                    resolve();
                };

                fileWriter.onerror = reject;

                var bb = new Blob([content]);
                fileWriter.write(bb);
            }, reject);
        });
    },

    writeText: function writeText(fileName, text, path) {
        var self = this;
        var fileHandle;

        return this.getFilesDirectory().then(function (directoryEntry) {
            if (path) {
                return self.createDirectory(path);
            } else {
                return directoryEntry;
            }
        }).then(function (directoryEntry) {
            return self.getFile(fileName, directoryEntry);
        }).then(function (fileEntry) {
            fileHandle = fileEntry;
            return self.writeTextToFile(fileEntry, text);
        }).then(function () {
            // there  is a difference between the cordova implementation and the standard FileTransfer fileEntry
            return fileHandle.nativeURL || fileHandle.toURL();
        });
    },

    // http://stackoverflow.com/questions/9583363/get-base64-from-imageuri-with-phonegap
    readFileAsBase64: function readFileAsBase64(fileEntry) {
        return new _rsvp2.default.Promise(function (resolve, reject) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function (evt) {
                    resolve(_utils2.default.arrayBufferToBase64(evt.target.result));
                };

                reader.readAsArrayBuffer(file);
            }, reject);
        });
    }
};

module.exports = WebFileStore;

},{"../../everlive/EverliveError":58,"../../everlive/everlive.platform":74,"../../everlive/utils":121,"rsvp":35,"underscore":36}],110:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _constants = require('../../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _DataQuery = require('../../everlive/dataQuery/DataQuery');

var _DataQuery2 = _interopRequireDefault(_DataQuery);

var _rsvp = require('rsvp');

var _rsvp2 = _interopRequireDefault(_rsvp);

var _EverliveError = require('../../everlive/EverliveError');

var _everlive = require('../../everlive/everlive.platform');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _Query = require('../../everlive/query/Query');

var _Query2 = _interopRequireDefault(_Query);

var _Data = require('../../common/Data');

var _Data2 = _interopRequireDefault(_Data);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

module.exports = function () {
    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} collectionName
     * @param {object} sdk
     * @protected
     */
    var Data = function (_CommonData) {
        _inherits(Data, _CommonData);

        function Data(sdk, collectionName) {
            _classCallCheck(this, Data);

            var _this = _possibleConstructorReturn(this, _CommonData.call(this, sdk, collectionName));

            _this.collectionName = collectionName;
            _this.setup = _this.sdk.setup;
            _this.options = null;
            return _this;
        }

        Data.prototype._isOnline = function _isOnline() {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        };

        Data.prototype._getOfflineCreateData = function _getOfflineCreateData(query, requestResponse) {
            var createData;
            if (_underscore2.default.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _underscore2.default.extend(query.data[i], requestResponse.Result[i]);
                    createData.push(objectToCreate);
                }
            } else {
                createData = _underscore2.default.extend(query.data, requestResponse.Result);
            }

            return createData;
        };

        Data.prototype._applyOffline = function _applyOffline(query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.setup.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case _constants.DataQueryOperations.Read:
                    case _constants.DataQueryOperations.ReadById:
                    case _constants.DataQueryOperations.FilesGetDownloadUrlById:
                        var syncReadQuery = new _DataQuery2.default(_underscore2.default.defaults({
                            data: requestResponse.Result,
                            isSync: true,
                            operation: _constants.DataQueryOperations.Create
                        }, query));
                        return this.offlineStorage.processQuery(syncReadQuery);
                    case _constants.DataQueryOperations.Create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new _DataQuery2.default(_underscore2.default.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.processQuery(createQuery);
                    case _constants.DataQueryOperations.Update:
                    case _constants.DataQueryOperations.RawUpdate:
                        query.isSync = true;
                        query.ModifiedAt = requestResponse.ModifiedAt;
                        return this.offlineStorage.processQuery(query);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new _rsvp2.default.Promise(function (resolve) {
                resolve();
            });
        };

        Data.prototype._setOption = function _setOption(key, value) {
            this.options = this.options || {};
            if (_underscore2.default.isObject(value)) {
                this.options[key] = _underscore2.default.extend({}, this.options[key], value);
            } else {
                this.options[key] = value;
            }

            return this;
        };

        Data.prototype._generateQueryFromFilter = function _generateQueryFromFilter(filterOrQuery) {
            if (filterOrQuery instanceof _Query2.default) {
                return filterOrQuery;
            } else {
                return new _Query2.default(filterOrQuery);
            }
        };

        /**
         * Modifies whether the query should be invoked on the offline storage.
         * @memberOf Data.prototype
         * @method useOffline
         * @name useOffline
         * @param {boolean} [useOffline]
         * @returns {Data} Returns the same instance of the Data object.
         */


        Data.prototype.useOffline = function useOffline(_useOffline) {
            if (arguments.length !== 1) {
                var message = _EverliveError.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('useOffline()');
                throw new _EverliveError.EverliveError(message, _EverliveError.EverliveErrors.singleValueExpected.code);
            }
            return this._setOption('useOffline', _useOffline);
        };

        /**
         * Does not use the cache when retrieving the data.
         * Only valid when caching is enabled.
         * @memberOf Data.prototype
         * @method ignoreCache
         * @name ignoreCache
         * @returns {Data}
         * */


        Data.prototype.ignoreCache = function ignoreCache() {
            return this._setOption('ignoreCache', true);
        };

        /**
         * Forces the request to get the data from the cache even if the data is already expired.
         * Only valid when caching is enabled.
         * @memberOf Data.prototype
         * @method forceCache
         * @name forceCache
         * @returns {Data}
         * */


        Data.prototype.forceCache = function forceCache() {
            return this._setOption('forceCache', true);
        };

        /**
         * Sets cache expiration specifically for the current query.
         * Only valid when caching is enabled.
         * @memberOf Data.prototype
         * @method maxAge
         * @name maxAge
         * @param maxAgeInMinutes
         * @returns {Data}
         * */


        Data.prototype.maxAge = function maxAge(maxAgeInMinutes) {
            var maxAge = maxAgeInMinutes * 1000 * 60;
            return this._setOption('maxAge', maxAge);
        };

        Data.prototype.isSync = function isSync(_isSync) {
            if (arguments.length !== 1) {
                var message = _EverliveError.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('isSync()');
                throw new _EverliveError.EverliveError(message, _EverliveError.EverliveErrors.singleValueExpected.code);
            }
            return this._setOption('isSync', _isSync);
        };

        /**
         * Modifies whether the query should try to authenticate if the security token has expired.
         * Default is false.
         * Only valid when the authentication module has an onAuthenticationRequired function.
         * @memberOf Data.prototype
         * @method skipAuth
         * @param skipAuth
         * @returns {Data}
         * */


        Data.prototype.skipAuth = function skipAuth(_skipAuth) {
            if (arguments.length !== 1) {
                var message = _EverliveError.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('skipAuth()');
                throw new _EverliveError.EverliveError(message, _EverliveError.EverliveErrors.singleValueExpected.code);
            }
            return this._setOption('skipAuth', _skipAuth);
        };

        /**
         * Modifies whether the query should be applied offline, if the sdk is currenty working online.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @memberOf Data.prototype
         * @method applyOffline
         * @param applyOffline
         * @returns {Data}
         * */


        Data.prototype.applyOffline = function applyOffline(_applyOffline2) {
            if (arguments.length !== 1) {
                var message = _EverliveError.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('applyOffline()');
                throw new _EverliveError.EverliveError(message, _EverliveError.EverliveErrors.singleValueExpected.code);
            }
            return this._setOption('applyOffline', _applyOffline2);
        };

        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Request Parameters](http://docs.telerik.com/platform/backend-services/rest/apireference/RESTfulAPI/custom_headers) for more information.
         * @memberOf Data.prototype
         * @method withHeaders
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */


        Data.prototype.withHeaders = function withHeaders(headers) {
            return this._setOption('headers', headers);
        };

        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
         * @returns {Data}
         */


        Data.prototype.expand = function expand(expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        };

        Data.prototype._applyQueryOffline = function _applyQueryOffline(query) {};

        Data.prototype._sendRequest = function _sendRequest(query, online) {};

        Data.prototype._applyQueryOnline = function _applyQueryOnline(query) {
            if (query.useCache) {
                this.sdk.cache._cacheDataQuery(query);
            } else {
                this._sendRequest(query, true);
            }
        };

        Data.prototype._setAdditionalHeaders = function _setAdditionalHeaders(query, requestOptions) {
            if (query.isSync) {
                requestOptions.headers[_constants2.default.Headers.sync] = true;
            }

            var sdkHeaderValue = {
                sdk: 'js',
                platform: _everlive.platform
            };

            requestOptions.headers[_constants2.default.Headers.sdk] = JSON.stringify(sdkHeaderValue);
        };

        Data.prototype.buildDataQuery = function buildDataQuery(data, op, success, error) {
            var collectionName = this.collectionName;
            return _CommonData.prototype.buildDataQuery.call(this, data, op, { collectionName: collectionName }, success, error);
        };

        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} query A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.get = function get(query, success, error) {
            var dataQuery = this.buildDataQuery(query, _constants.DataQueryOperations.Read);
            return this.processDataQuery(dataQuery, success, error);
        };

        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */


        Data.prototype.getById = function getById(id, success, error) {
            if (!_utils2.default.modelHasValidId(id)) {
                return this._invalidIdErrorResponse(error);
            }

            var dataQuery = this.buildDataQuery({
                additionalOptions: { id: id }
            }, _constants.DataQueryOperations.ReadById);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         *  A fluent API aggregation / grouping data from server. Can accept aggregationExpression or fluent chaining rules.
         * @memberOf Data.prototype
         * @method aggregate
         * @name aggregate
         * @param {object} aggregateQuery fields / Aggregation functions [aggregationExpression].
         * @returns {Promise} The promise for the request.
         */
        /**
         *  A fluent API aggregation / grouping data from server. Can accept aggregationExpression or fluent chaining rules.
         * @memberOf Data.prototype
         * @method aggregate
         * @name aggregate
         * @param {object} aggregateQuery fields / Aggregation functions [aggregationExpression].
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */


        Data.prototype.aggregate = function aggregate(aggregateQuery, success, error) {
            var dataQuery = this.buildDataQuery(aggregateQuery, _constants.DataQueryOperations.Aggregate);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.count = function count(filter, success, error) {
            var dataQuery = this.buildDataQuery(filter, _constants.DataQueryOperations.Count);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.create = function create(data, success, error) {
            var dataQuery = this.buildDataQuery(data, _constants.DataQueryOperations.Create);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} filterOrId The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} filterOrId The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.rawUpdate = function rawUpdate(updateObject, filterOrId, success, error) {
            var self = this;
            var isSingleUpdate = typeof filterOrId === 'string' || typeof filterOrId === 'number';

            if (isSingleUpdate && !_utils2.default.modelHasValidId(filterOrId)) {
                return self._invalidIdErrorResponse(error);
            }

            var query = isSingleUpdate ? filterOrId : this.sdk.dataQueryBuilder._buildQuery(filterOrId);
            var additionalOptions = {
                id: isSingleUpdate ? filterOrId : undefined
            };

            var dataQuery = this.buildDataQuery({
                query: query,
                additionalOptions: additionalOptions,
                updateObject: updateObject
            }, _constants.DataQueryOperations.RawUpdate);
            return this.processDataQuery(dataQuery, success, error);
        };

        // TODO: Check if there is a case in which replace = true is passed to this function


        Data.prototype._update = function _update(attrs, filterOrQuery, single, replace, success, error) {
            var dataQuery = this.buildDataQuery({
                updateObject: _defineProperty({}, replace ? '$replace' : '$set', attrs),
                additionalOptions: {
                    id: single ? attrs[_constants.idField] : undefined
                },
                query: filterOrQuery
            }, _constants.DataQueryOperations.Update);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.updateSingle = function updateSingle(model, success, error) {
            if (!_utils2.default.modelHasValidId(model)) {
                return this._invalidIdErrorResponse(error);
            }

            return this._update(model, null, true, false, success, error);
        };

        Data.prototype._invalidIdErrorResponse = function _invalidIdErrorResponse(errorHandler) {
            var err = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.invalidId);
            return _utils2.default.callbackAndPromiseErrorResponse(err, errorHandler);
        };

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.update = function update(model, filter, success, error) {
            return this._update(model, filter, false, false, success, error);
        };

        Data.prototype._destroy = function _destroy(attrs, filterOrQuery, single, success, error) {
            var op = single ? _constants.DataQueryOperations.DeleteById : _constants.DataQueryOperations.Delete;
            var idField = attrs && (typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object' ? attrs[_constants2.default.idField] : attrs;

            var dataQuery = this.buildDataQuery({
                additionalOptions: {
                    id: single ? idField : undefined
                },
                query: filterOrQuery
            }, op);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {string} itemId The ID of the item to delete.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {string} itemId The ID of the item to delete.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.destroySingle = function destroySingle(model, success, error) {
            if (!_utils2.default.modelHasValidId(model)) {
                return this._invalidIdErrorResponse(error);
            }

            return this._destroy(model, null, true, success, error);
        };

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.destroy = function destroy(filter, success, error) {
            return this._destroy(null, filter, false, success, error);
        };

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {object} operationParameters An object that accepts operation parameters.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} filter The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} filter The ID of the item or item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.setAcl = function setAcl(acl, filter, success, error) {
            var self = this;

            if (!_utils2.default.modelHasValidId(filter)) {
                return self._invalidIdErrorResponse(error);
            }

            var additionalOptions = { acl: acl };
            var data = { additionalOptions: additionalOptions };
            additionalOptions.id = filter[_constants.idField] || filter;

            var dataQuery = this.buildDataQuery(data, _constants.DataQueryOperations.SetAcl);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {object} operationParameters An object that accepts operation parameters.
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.useOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} filter The ID of the item or item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.setOwner = function setOwner(ownerId, filter, success, error) {
            if (!_utils2.default.modelHasValidId(filter)) {
                return this._invalidIdErrorResponse(error);
            }

            var data = {
                updateObject: { Owner: ownerId },
                additionalOptions: {}
            };

            data.additionalOptions.id = filter[_constants.idField] || filter;

            var dataQuery = this.buildDataQuery(data, _constants.DataQueryOperations.SetOwner);
            return this.processDataQuery(dataQuery, success, error);
        };

        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */


        Data.prototype.save = function save(model, success, error) {
            var _this2 = this;

            return (0, _utils.buildPromise)(function (success, error) {
                var isNew = _this2.isNew(model);
                var promise = void 0;
                if (isNew) {
                    promise = _this2.create(model);
                } else {
                    promise = _this2.updateSingle(model);
                }

                var type = isNew ? 'create' : 'update';
                promise.then(function (res) {
                    res.type = type;
                    success(res);
                }).catch(function (err) {
                    err.type = type;
                    error(err);
                });
            }, success, error);
        };

        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method isNew
         * @param model Item to check.
         * @returns {boolean}
         */


        Data.prototype.isNew = function isNew(model) {
            return typeof model[_constants.idField] === 'undefined';
        };

        _createClass(Data, [{
            key: 'offlineStorage',
            get: function get() {
                return this.sdk.offlineStorage;
            }
        }]);

        return Data;
    }(_Data2.default);

    return Data;
}();

},{"../../common/Data":37,"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/dataQuery/DataQuery":71,"../../everlive/everlive.platform":74,"../../everlive/query/Query":96,"../../everlive/utils":121,"rsvp":35,"underscore":36}],111:[function(require,module,exports){
'use strict';

var _utils = require('../../everlive/utils');

var _everlive = require('../../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _Data2 = require('../../everlive/types/Data');

var _Data3 = _interopRequireDefault(_Data2);

var _constants = require('../../everlive/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Files = function (_Data) {
    _inherits(Files, _Data);

    /**
     * @class Files
     * @protected
     * @extends Data
     */
    function Files(sdk) {
        _classCallCheck(this, Files);

        return _possibleConstructorReturn(this, _Data.call(this, sdk, 'Files'));
    }

    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */


    Files.prototype.getUploadUrl = function getUploadUrl() {
        return (0, _utils.buildUrl)(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @see [files.getDownloadUrlById]{@link ../Files/files.getDownloadUrlById}
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */


    Files.prototype.getDownloadUrl = function getDownloadUrl(fileId) {
        return (0, _utils.buildUrl)(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */


    Files.prototype.getUpdateUrl = function getUpdateUrl(fileId) {
        return (0, _utils.buildUrl)(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {Object} file The file metadata and the base64 encoded file content.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     * @returns {Promise} The promise for the request
     */


    Files.prototype.updateContent = function updateContent(fileId, file, success, error) {
        var data = file;
        var additionalOptions = { id: fileId };
        var dataQuery = this.buildDataQuery({
            data: data,
            additionalOptions: additionalOptions
        }, _constants.DataQueryOperations.FilesUpdateContent);
        return this.processDataQuery(dataQuery, success, error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @returns {Promise} The promise for the request
     */
    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @see [files.getDownloadUrlById]{@link ../Files/files.getDownloadUrlById}
     * @param {string} fileId File ID.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Files.prototype.getDownloadUrlById = function getDownloadUrlById(fileId, success, error) {
        if (_everlive2.default.isDesktop && !this.sdk.isOnline()) {
            //while in offline we cannot get the url of the file, but we can generate one
            var url = this.getDownloadUrl(fileId);
            return (0, _utils.buildPromise)(function (resolve) {
                return resolve(url);
            }, success);
        }

        var additionalOptions = { id: fileId };
        var dataQuery = this.buildDataQuery({ additionalOptions: additionalOptions }, _constants.DataQueryOperations.FilesGetDownloadUrlById);
        return this.processDataQuery(dataQuery, success, error);
    };

    /**
     * Downloads a file to the device's file system. Wraps the Apache Cordova "download()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
     * @memberof Files.prototype
     * @method download
     * @param {string} fileToDownload A Backend Services File ID.
     * @param {string} pathOnDevice An Apache Cordova FileSystem URL representing the local path on the device where the downloaded file will be saved. Maps to the "target" FileTransfer plugin parameter.
     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
     * @param {object} [options.headers] A JSON object containing headers to send along with the request.
     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Downloads a file to the device's file system. Wraps the Apache Cordova "download()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
     * @memberof Files.prototype
     * @method download
     * @param {string} url A Backend Services File ID.
     * @param {string} localPath An Apache Cordova FileSystem URL representing the local path on the device where the downloaded file will be saved. Maps to the "target" FileTransfer plugin parameter.
     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
     * @param {object} [options.headers] A JSON object containing headers to send along with the request.
     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
     * @param {Function} [success] A success callback that is passed an Apache Cordova [FileEntry](https://cordova.apache.org/docs/en/3.3.0/cordova_file_file.md.html#FileEntry) object. Maps to the "successCallback" FileTransfer plugin parameter.
     * @param {Function} [error] An error callback that is passed an Apache Cordova [FileTransferError](https://github.com/apache/cordova-plugin-file-transfer#filetransfererror) object. Maps to the "errorCallback" FileTransfer plugin parameter.
     */


    Files.prototype.download = function download(url, localPath, options, trustAllHosts, success, error) {
        var _this2 = this;

        return (0, _utils.buildPromise)(function (success, error) {
            if (!trustAllHosts) {
                trustAllHosts = false;
            }

            var headers = options && options.headers ? options.headers : {};

            var fileTransfer = new FileTransfer();
            _this2.withHeaders(headers).getById(url).then(function (res) {
                var file = res.result;
                url = file.Uri;
                fileTransfer.download(url, localPath, success, error, trustAllHosts, options);
            }, error);
        }, success, error);
    };

    /**
     * Uploads a file from the device's file system to Backend Services. Wraps the Apache Cordova "upload()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
     * @memberof Files.prototype
     * @method upload
     * @param {string} localPath An Apache Cordova FileSystem URL representing the full path to the file on the device.
     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
     * @param {string} [options.fileKey] The name of the form element. Defaults to 'file' in the FileTransfer plugin parameter.
     * @param {string} [options.fileName] The file name to use when uploading the file. Defaults to 'image.jpg' in the FileTransfer plugin.
     * @param {string} [options.httpMethod] The HTTP method to use, either POST or PUT. Defaults to 'POST' in the FileTransfer plugin parameter.
     * @param {string} [options.mimeType] The mime type of the uploaded data. Defaults to 'image/jpeg' in the FileTransfer plugin parameter.
     * @param {object} [options.params] A set of optional key/value pairs to pass in the HTTP request.
     * @param {boolean} [options.chunkedMode] Whether to upload the data in chunked streaming mode. Defaults to 'true' in the FileTransfer plugin parameter.
     * @param {object} [options.headers] A JSON object for the headers to send along with the request.
     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Uploads a file from the device's file system to Backend Services. Wraps the Apache Cordova "upload()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
     * @memberof Files.prototype
     * @method upload
     * @param {string} localPath An Apache Cordova FileSystem URL representing the full path to the file on the device.
     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
     * @param {string} [options.fileKey] The name of the form element. Defaults to 'file' in the FileTransfer plugin parameter.
     * @param {string} [options.fileName] The file name to use when uploading the file. Defaults to 'image.jpg' in the FileTransfer plugin parameter.
     * @param {string} [options.httpMethod] The HTTP method to use, either POST or PUT. Defaults to 'POST' in the FileTransfer plugin parameter.
     * @param {string} [options.mimeType] The mime type of the uploaded data. Defaults to 'image/jpeg' in the FileTransfer plugin parameter.
     * @param {object} [options.params] A set of optional key/value pairs to pass in the HTTP request.
     * @param {boolean} [options.chunkedMode] Whether to upload the data in chunked streaming mode. Defaults to 'true' in the FileTransfer plugin parameter.
     * @param {object} [options.headers] A JSON object for the headers to send along with the request.
     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
     * @param {Function} [success] A success callback that is passed an Apache Cordova [FileUploadResult](https://github.com/apache/cordova-plugin-file-transfer#fileuploadresult) object. Maps to the "successCallback" FileTransfer plugin parameter.
     * @param {Function} [error] An error callback that is passed an Apache Cordova [FileTransferError](https://github.com/apache/cordova-plugin-file-transfer#filetransfererror) object. Maps to the "errorCallback" FileTransfer plugin parameter.
     */


    Files.prototype.upload = function upload(localPath, options, trustAllHosts, success, error) {
        var url = this.getUploadUrl();
        return (0, _utils.buildPromise)(function (success, error) {
            if (!trustAllHosts) {
                trustAllHosts = false;
            }
            var fileTransfer = new FileTransfer();
            var uri = encodeURI(url);
            fileTransfer.upload(localPath, uri, success, error, options, trustAllHosts);
        }, success, error);
    };

    Files.prototype._getUpdateUrl = function _getUpdateUrl(fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    return Files;
}(_Data3.default);

module.exports = Files;

},{"../../everlive/constants":70,"../../everlive/everlive.platform":74,"../../everlive/types/Data":110,"../../everlive/utils":121}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = require('../../everlive/utils');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _EverliveError = require('../../everlive/EverliveError');

var _Data2 = require('../../everlive/types/Data');

var _Data3 = _interopRequireDefault(_Data2);

var _constants = require('../../everlive/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Users = function (_Data) {
    _inherits(Users, _Data);

    /**
     * @class Users
     * @extends Data
     * @protected
     */
    function Users(sdk) {
        _classCallCheck(this, Users);

        return _possibleConstructorReturn(this, _Data.call(this, sdk, 'Users'));
    }

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.register = function register(username, password, attrs, success, error) {
        (0, _utils.guardUnset)(username, 'username');
        (0, _utils.guardUnset)(password, 'password');
        var user = _underscore2.default.extend({
            Username: username,
            Password: password
        }, attrs);

        return this.create(user, success, error);
    };

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with [Users.ResultTypes.currentUserResult]{@link Users.ResultTypes.currentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with [Users.ResultTypes.currentUserResult]{@link Users.ResultTypes.currentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.currentUser = function currentUser(success, error) {
        var _this2 = this;

        var id = this.sdk._isOfflineStorageEnabled() && this.sdk.isOffline() ? this.sdk.setup.principalId : 'me';
        return (0, _utils.buildPromise)(function (success, error) {
            if (id === 'me' && !_this2.sdk.setup.token && !_this2.sdk.setup.masterKey || !id) {
                return success({ result: null });
            }

            _this2.getById(id).then(function (res) {
                if (typeof res.result !== 'undefined') {
                    success({ result: res.result });
                } else {
                    success({ result: null });
                }
            }, function (err) {
                if (_this2.sdk.authentication && _this2.sdk.authentication.isAuthenticationInProgress()) {
                    success({ result: null });
                } else if (err.code === 601) {
                    // invalid request, i.e. the access token is missing
                    success({ result: null });
                } else if (err.code === 801) {
                    error(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.invalidToken));
                } else {
                    error(err);
                }
            });
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.changePassword = function changePassword(username, password, newPassword, keepTokens, success, error) {
        var _this3 = this;

        var data = {
            Username: username,
            Password: password,
            NewPassword: newPassword
        };
        var additionalOptions = { keepTokens: keepTokens };
        var dataQuery = this.buildDataQuery({ data: data, additionalOptions: additionalOptions }, _constants.DataQueryOperations.UserChangePassword);
        return (0, _utils.buildPromise)(function (success, error) {
            return _this3.processDataQuery(dataQuery).then(function (data) {
                if (data && data.result) {
                    if (!keepTokens) {
                        _this3.clearAuthorization();
                    }
                }

                return success(data);
            }).catch(error);
        }, success, error);
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.login = function login(username, password, success, error) {
        return this.sdk.authentication.login(username, password, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.logout = function logout(success, error) {
        return this.sdk.authentication.logout(success, error);
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.loginWithFacebook = function loginWithFacebook(accessToken, success, error) {
        return this.sdk.authentication.loginWithFacebook(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.linkWithFacebook = function linkWithFacebook(userId, accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.unlinkFromFacebook = function unlinkFromFacebook(userId, success, error) {
        return this._unlinkFromProvider('Facebook', userId, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.loginWithADFS = function loginWithADFS(accessToken, success, error) {
        return this.sdk.authentication.loginWithADFS(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.linkWithADFS = function linkWithADFS(userId, accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.unlinkFromADFS = function unlinkFromADFS(userId, success, error) {
        return this._unlinkFromProvider('ADFS', userId, success, error);
    };

    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.loginWithLiveID = function loginWithLiveID(accessToken, success, error) {
        return this.sdk.authentication.loginWithLiveID(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.linkWithLiveID = function linkWithLiveID(userId, accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.unlinkFromLiveID = function unlinkFromLiveID(userId, success, error) {
        return this._unlinkFromProvider('LiveID', userId, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.loginWithGoogle = function loginWithGoogle(accessToken, success, error) {
        return this.sdk.authentication.loginWithGoogle(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.linkWithGoogle = function linkWithGoogle(userId, accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };
        return this._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.unlinkFromGoogle = function unlinkFromGoogle(userId, success, error) {
        return this._unlinkFromProvider('Google', userId, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.loginWithTwitter = function loginWithTwitter(token, tokenSecret, success, error) {
        return this.sdk.authentication.loginWithTwitter(token, tokenSecret, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.linkWithTwitter = function linkWithTwitter(userId, token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };
        return this._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.unlinkFromTwitter = function unlinkFromTwitter(userId, success, error) {
        return this._unlinkFromProvider('Twitter', userId, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.setAuthorization}
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */


    Users.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this.sdk.authentication.setAuthorization(token, tokenType, principalId);
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.clearAuthorization}
     * @memberOf Users.prototype
     */


    Users.prototype.clearAuthorization = function clearAuthorization() {
        this.sdk.authentication.setAuthorization(null, null, null);
    };

    /**
     * Sends a password reset email to a specified user.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {Object} user The user object, which must container either username or email address.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Sends a password reset email to a specified user.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {Object} user The user object, which must container either username or email address.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.resetPassword = function resetPassword(user, success, error) {
        var dataQuery = this.buildDataQuery(user, _constants.DataQueryOperations.UserResetPassword);
        return this.processDataQuery(dataQuery, success, error);
    };

    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {string} setPasswordObject.ResetCode The reset code obtained using a password reset email.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {string} setPasswordObject.ResetCode The reset code obtained using a password reset email.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {number} setPasswordObject.Username The username that the password will be changed.
     * @param {number} setPasswordObject.SecretQuestionId The id of the secret question.
     * @param {string} setPasswordObject.SecretAnswer The answer to the secret question.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {number} setPasswordObject.Username The username that the password will be changed.
     * @param {number} setPasswordObject.SecretQuestionId The id of the secret question.
     * @param {string} setPasswordObject.SecretAnswer The answer to the secret question.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */


    Users.prototype.setPassword = function setPassword(setPasswordObject, success, error) {
        var dataQuery = this.buildDataQuery(setPasswordObject, _constants.DataQueryOperations.UserSetPassword);
        return this.processDataQuery(dataQuery, success, error);
    };

    Users.prototype._linkWithProvider = function _linkWithProvider(identity, userId, success, error) {
        var dataQuery = this.buildDataQuery({
            additionalOptions: {
                id: userId
            },
            data: identity
        }, _constants.DataQueryOperations.UserLinkWithProvider);
        return this.processDataQuery(dataQuery, success, error);
    };

    Users.prototype._unlinkFromProvider = function _unlinkFromProvider(providerName, userId, success, error) {
        var dataQuery = this.buildDataQuery({
            additionalOptions: { userId: userId },
            data: {
                Provider: providerName
            }
        }, _constants.DataQueryOperations.UserUnlinkFromProvider);
        return this.processDataQuery(dataQuery, success, error);
    };

    return Users;
}(_Data3.default);

exports.default = Users;

},{"../../everlive/EverliveError":58,"../../everlive/constants":70,"../../everlive/types/Data":110,"../../everlive/utils":121,"underscore":36}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
        value: true
});

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../../../everlive/EverliveError');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataPreprocessor = function () {
        function DataPreprocessor() {
                _classCallCheck(this, DataPreprocessor);
        }

        DataPreprocessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
                var offlineStorageEnabled = data.sdk._isOfflineStorageEnabled();
                query.useOffline = offlineStorageEnabled ? !data.sdk.isOnline() : false;

                var isCachingEnabled = data.sdk.setup.caching === true || data.sdk.setup.caching && data.sdk.setup.caching.enabled;
                var isSupportedInOffline = _utils2.default.isQuerySupportedOffline(query);

                if (data.options) {
                        query = _underscore2.default.extend(query, data.options);
                }

                query.useCache = isCachingEnabled && !query.isSync && isSupportedInOffline;
                query.applyOffline = query.applyOffline !== undefined ? query.applyOffline : offlineStorageEnabled || query.useCache;

                if (!query.useCache && query.forceCache) {
                        return iterator.error(new _EverliveError.EverliveError(_EverliveError.EverliveErrors.cannotForceCacheWhenDisabled));
                }

                data.options = null;
                return iterator.next(value);
        };

        return DataPreprocessor;
}();

exports.default = DataPreprocessor;

},{"../../../everlive/EverliveError":58,"../../../everlive/utils":121,"underscore":36}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _EverliveError = require('../../../everlive/EverliveError');

var _DataQuery = require('../../../everlive/dataQuery/DataQuery');

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _underscore = require('underscore');

var _platform = require('../../../common/platform');

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OfflineQueryPreprocessor = function () {
    function OfflineQueryPreprocessor() {
        _classCallCheck(this, OfflineQueryPreprocessor);
    }

    OfflineQueryPreprocessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (!query.isSync && data.offlineStorage && data.offlineStorage.isSynchronizing()) {
            var error = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.syncInProgress);
            return iterator.error(error);
        }

        if (_utils2.default.isContentType.files(data.collectionName) && _platform2.default.isDesktop) {
            var op = query.operation;

            if (query.useOffline && query.applyOffline && (op === _DataQuery.operations.Create || op === _DataQuery.operations.Update)) {
                var _error = new _EverliveError.EverliveError(_EverliveError.EverliveErrors.filesNotSupportedInBrowser);
                return iterator.error(_error);
            }
        }

        return iterator.next(value);
    };

    return OfflineQueryPreprocessor;
}();

exports.default = OfflineQueryPreprocessor;

},{"../../../common/platform":51,"../../../everlive/EverliveError":58,"../../../everlive/dataQuery/DataQuery":71,"../../../everlive/utils":121,"underscore":36}],115:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _utils = require('../../../everlive/utils');

var _utils2 = _interopRequireDefault(_utils);

var _EverliveError = require('../../../everlive/EverliveError');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AuthenticationProcessor = function () {
    function AuthenticationProcessor() {
        _classCallCheck(this, AuthenticationProcessor);
    }

    AuthenticationProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (!query.skipAuth && data.sdk.authentication && data.sdk.authentication.isAuthenticationInProgress()) {
            iterator.prependOnceListener('error', function (error, ev) {

                var err = _utils.parseUtilities.parseErrorOrResponse(error);
                if (err && (err.code === _EverliveError.EverliveErrors.invalidToken.code || err.code === _EverliveError.EverliveErrors.expiredToken.code)) {
                    ev.cancel();
                    var _whenAuthenticatedPromise = data.sdk.authentication._ensureAuthentication();
                    if (!query.noRetry) {
                        _whenAuthenticatedPromise.then(function () {
                            if (query.headers && query.headers.authorization) {
                                //at this stage if a token is used for authentication it is already invalidated
                                //we need to set the new one to the query
                                var authHeader = _utils2.default.buildAuthHeader(data.sdk.setup);
                                _underscore2.default.extend(query.headers, authHeader);
                            }

                            return iterator.restart();
                        });
                    } else {
                        return iterator.next(value);
                    }
                }
            });

            //if we are currently authenticating, queue the data query after we have logged in
            if (data.sdk.authentication.isAuthenticating()) {
                var whenAuthenticatedPromise = data.sdk.authentication._ensureAuthentication();
                if (!query.noRetry) {
                    whenAuthenticatedPromise.then(function () {
                        return iterator.restart();
                    });
                }

                return whenAuthenticatedPromise;
            } else {
                return iterator.next(value);
            }
        } else {
            return iterator.next(value);
        }
    };

    return AuthenticationProcessor;
}();

exports.default = AuthenticationProcessor;

},{"../../../everlive/EverliveError":58,"../../../everlive/utils":121,"underscore":36}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _constants = require('../../../everlive/constants');

var _RequestService = require('../../../everlive/services/RequestService');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BusinessLogicQueryProcessor = function () {
    function BusinessLogicQueryProcessor() {
        _classCallCheck(this, BusinessLogicQueryProcessor);
    }

    BusinessLogicQueryProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        var op = query.operation;
        if (op !== _constants.DataQueryOperations.InvokeCloudFunction && op !== _constants.DataQueryOperations.InvokeStoredProcedure) {
            return iterator.next(value);
        }

        var request = _RequestService.RequestService.buildRequest(query, data);
        return request.send().then(function (res) {
            return iterator.end(res);
        }).catch(function (err) {
            return iterator.error(err);
        });
    };

    return BusinessLogicQueryProcessor;
}();

exports.default = BusinessLogicQueryProcessor;

},{"../../../everlive/constants":70,"../../../everlive/services/RequestService":105}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _RequestService = require('../../../everlive/services/RequestService');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CacheQueryProcessor = function () {
    function CacheQueryProcessor() {
        _classCallCheck(this, CacheQueryProcessor);
    }

    CacheQueryProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (!query.useCache || query.useCache && query.canUseOffline) {
            return iterator.next(value);
        }

        return this._cacheDataQuery(query, data).then(function (result) {
            return iterator.next(result || value);
        }, function (error) {
            return iterator.error(error);
        });
    };

    CacheQueryProcessor.prototype._cacheDataQuery = function _cacheDataQuery(query, data) {
        var shouldSkipCache = data.sdk.cache._shouldSkipCache(query);
        if (shouldSkipCache) {
            if (query.ignoreCache && !data.sdk.cache.isQueryUnsupportedOffline(query)) {
                var hash = data.sdk.cache._getHashForQuery(query);

                return data.sdk.cache._cacheQuery(query, hash, data);
            } else {
                return _RequestService.RequestService.handleRequestProcessing(query, data);
            }
        } else {
            query.useCache = false;
            return data.sdk.cache._processCacheItem(query, data);
        }
    };

    return CacheQueryProcessor;
}();

exports.default = CacheQueryProcessor;

},{"../../../everlive/services/RequestService":105}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('underscore');

var _require = require('../../../everlive/constants');

var DataQueryOperations = _require.DataQueryOperations;
var Events = _require.Events;

var EventQuery = require('../../../everlive/query/EventQuery');

var beforeExecuteAllowedOperations = [DataQueryOperations.Count, DataQueryOperations.Read, DataQueryOperations.Create, DataQueryOperations.Update, DataQueryOperations.UpdateById, DataQueryOperations.Delete, DataQueryOperations.DeleteById, DataQueryOperations.ReadById, DataQueryOperations.Aggregate, DataQueryOperations.RawUpdate];

var EventQueryProcessor = function () {
    function EventQueryProcessor() {
        _classCallCheck(this, EventQueryProcessor);
    }

    EventQueryProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (_.contains(beforeExecuteAllowedOperations, query.operation)) {
            var eventQuery = EventQuery.fromDataQuery(query);
            data.sdk._emitter.emit(Events.BeforeExecute, eventQuery);
            if (eventQuery.isCancelled()) {
                return iterator.cancel();
            }

            query.applyEventQuery(eventQuery);
        }

        return iterator.next(value);
    };

    return EventQueryProcessor;
}();

exports.default = EventQueryProcessor;

},{"../../../everlive/constants":70,"../../../everlive/query/EventQuery":95,"underscore":36}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _EverliveError = require('../../../everlive/EverliveError');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OfflineQueryProcessor = function () {
    function OfflineQueryProcessor() {
        _classCallCheck(this, OfflineQueryProcessor);
    }

    OfflineQueryProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (!query.canUseOffline) {
            return iterator.next(value);
        }

        if (!query.applyOffline) {
            var error = new _EverliveError.EverliveError('The applyOffline must be true when working offline.');
            return iterator.error(error);
        } else {
            return data.offlineStorage.processQuery(query).then(function () {
                return iterator.next.apply(iterator, arguments);
            }, function (err) {
                if (!err.code) {
                    err = new _EverliveError.EverliveError(err.message, _EverliveError.EverliveErrors.generalDatabaseError.code);
                }

                return iterator.error(err);
            });
        }
    };

    return OfflineQueryProcessor;
}();

exports.default = OfflineQueryProcessor;

},{"../../../everlive/EverliveError":58}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _RequestService = require('../../../everlive/services/RequestService');

var _EverliveError = require('../../../everlive/EverliveError');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OnlineQueryProcessor = function () {
    function OnlineQueryProcessor() {
        _classCallCheck(this, OnlineQueryProcessor);
    }

    OnlineQueryProcessor.prototype.processDataQuery = function processDataQuery(query, iterator, data, value) {
        if (query.canUseOffline || query.useCache) {
            return iterator.next(value);
        }

        return _RequestService.RequestService.handleRequestProcessing(query, data).then(function (result) {
            return iterator.next(result || value);
        }, function (err) {
            return iterator.error(err);
        });
    };

    return OnlineQueryProcessor;
}();

exports.default = OnlineQueryProcessor;

},{"../../../everlive/EverliveError":58,"../../../everlive/services/RequestService":105}],121:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _everlive = require('../everlive/everlive.platform');

var _everlive2 = _interopRequireDefault(_everlive);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _constants = require('../everlive/constants');

var _constants2 = _interopRequireDefault(_constants);

var _utils = require('../common/utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = _underscore2.default.deepExtend({}, _utils2.default);

//brings down all keys to the same level (lowerCase)
utils.normalizeKeys = function normalizeKeys(obj) {
    var normalizedKeys = {};

    _underscore2.default.each(obj, function (val, key) {
        var lowerKey = key.toLowerCase();

        if (!normalizedKeys.hasOwnProperty(lowerKey)) {
            normalizedKeys[lowerKey] = val;
        }
    });

    return normalizedKeys;
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    } else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return { authorization: authHeaderValue };
    } else {
        return null;
    }
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.appId) {
        url += setup.appId + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string' || typeof expression === 'number') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression || {});
    _underscore2.default.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (_typeof(expression[key]) === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};

utils.disableRequestCache = function (url, method) {
    if (method === 'GET') {
        var timestamp = new Date().getTime();
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        url += separator + '_el=' + timestamp;
    }

    return url;
};

var unsupportedDbOperators = ['$geoWithin', '$geoIntersects', '$near', '$within', '$nearSphere'];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _underscore2.default.intersection(dbOperators, unsupportedDbOperators);
};

utils.isQuerySupportedOffline = function (query) {
    var queryParams = query.getQueryParameters();
    var hasExpandExpression = !_underscore2.default.isEmptyObject(queryParams.expand);
    var unsupportedOperators = utils.getUnsupportedOperators(queryParams.filter);
    var hasUnsupportedOperators = unsupportedOperators.length !== 0;
    var isUnsupportedInOffline = hasExpandExpression || hasUnsupportedOperators;
    return !isUnsupportedInOffline;
};

// http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript/16245768#16245768
utils.b64toBlob = function (b64Data, contentType, sliceSize) {
    contentType = contentType || '';
    sliceSize = sliceSize || 512;

    var byteCharacters = atob(b64Data);
    var byteArrays = [];

    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        var slice = byteCharacters.slice(offset, offset + sliceSize);

        var byteNumbers = new Array(slice.length);
        for (var i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }

        var byteArray = new Uint8Array(byteNumbers);

        byteArrays.push(byteArray);
    }

    var blob = new Blob(byteArrays, { type: contentType });
    return blob;
};

// http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
utils.arrayBufferToBase64 = function (buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }

    return btoa(binary);
};

utils.transformPlatformPath = function transformPlatformPath(platformPath) {
    if (!platformPath) {
        return '';
    }

    if (_everlive2.default.isWindowsPhone) {
        if (platformPath.charAt(0) === '/' && platformPath.charAt(1) !== '/') {
            platformPath = '/' + platformPath;
        }
    } else {
        //TODO: probably desktop too
        if (platformPath.indexOf('file:/') !== -1 && platformPath.indexOf('file:///') === -1) {
            platformPath = platformPath.replace('file:/', 'file:///');
        }
    }

    return platformPath;
};

utils._stringCompare = function (string, check) {
    return string.toLowerCase() === check;
};

utils.isContentType = {
    files: function files(collectionName) {
        return utils._stringCompare(collectionName, 'files');
    },
    users: function users(collectionName) {
        return utils._stringCompare(collectionName, 'users');
    },
    pushNotifications: function pushNotifications(collectionName) {
        return utils._stringCompare(collectionName, _constants2.default.Push.NotificationsType.toLowerCase());
    },
    pushDevices: function pushDevices(collectionName) {
        return utils._stringCompare(collectionName, _constants2.default.Push.DevicesType.toLowerCase());
    }
};

utils.isElement = {
    _isElement: function _isElement(el, check) {
        var tag = el;

        if (typeof tag !== 'string') {
            if (el instanceof HTMLElement) {
                tag = el.tagName;
            }
        }

        return utils._stringCompare(tag, check);
    },
    image: function image(el) {
        return utils.isElement._isElement(el, 'img');
    },
    anchor: function anchor(el) {
        return utils.isElement._isElement(el, 'a');
    }
};

utils.joinPath = function joinPath() {
    var args = [].slice.apply(arguments).map(function (arg) {
        return arg || '';
    });

    var joinedPath = _path2.default.join.apply(_path2.default, args);
    return utils.transformPlatformPath(joinedPath);
};

utils.getId = function (obj) {
    return obj.Id || obj._id || obj.id;
};

utils._inAppBuilderSimulator = function () {
    return typeof window !== 'undefined' && window.navigator && window.navigator.simulator;
};

utils.isValidId = function (input) {
    var isValidString = typeof input === 'string' && input !== '';
    var isValidNumber = typeof input === 'number' && !_underscore2.default.isNaN(input);

    return isValidString || isValidNumber;
};

utils.modelHasValidId = function (model) {
    var idToValidate = (typeof model === 'undefined' ? 'undefined' : _typeof(model)) === 'object' && model !== null ? model.Id : model;
    return utils.isValidId(idToValidate);
};

utils.callbackAndPromiseErrorResponse = function (err, errorHandler) {
    errorHandler = errorHandler || _underscore2.default.noop;
    errorHandler(err);
    return utils.rejectedPromise(err);
};

utils.toQueryString = function (obj) {
    var queryString = '',
        encode = encodeURIComponent,
        append = function append(k, v) {
        queryString += encode(k) + '=' + encode(v) + '&';
    };

    if (_underscore2.default.isArray(obj)) {
        for (var i = 0; obj && i < obj.length; i++) {
            append(obj[i].name, obj[i].value);
        }
    } else {
        for (var propName in obj) {
            if (!obj.hasOwnProperty(propName)) {
                continue;
            }

            var value = obj[propName];

            if (_underscore2.default.isArray(value)) {
                for (i = 0; i < value.length; i++) {
                    append(propName, value[i]);
                }
            } else {
                append(propName, obj[propName]);
            }
        }
    }

    // spaces should be + according to spec
    return queryString.replace(/&$/, '').replace(/%20/g, '+');
};

utils.lazyRequire = function (_dynamic_module_, exportName) {
    exportName = exportName || _dynamic_module_;
    var obj = {};

    Object.defineProperty(obj, exportName, {
        get: function get() {
            return require(_dynamic_module_);
        }
    });

    return obj;
};

module.exports = utils;

},{"../common/utils":54,"../everlive/constants":70,"../everlive/everlive.platform":74,"path":4,"underscore":36}],122:[function(require,module,exports){
'use strict';

require('./common/index');

var _index = require('./everlive/index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//initialize platform specific sdk

//build-specific sdk, e.g. if we build with --target sitefinity this will require the index.js file in the sitefinity folder
//and index.js in the platform folder if the --target is platform
module.exports = _index2.default; //initialize common sdk

},{"./common/index":46,"./everlive/index":79}],123:[function(require,module,exports){
'use strict';

var AggregationTranslator = {};

function getFieldAggregation(aggregationDefinition) {
    var result;

    if (aggregationDefinition.hasOwnProperty('count')) {
        result = { '$sum': 1 };
    } else if (aggregationDefinition.min) {
        result = { '$min': '$' + aggregationDefinition.min };
    } else if (aggregationDefinition.max) {
        result = { '$max': '$' + aggregationDefinition.max };
    } else if (aggregationDefinition.avg) {
        result = { '$avg': '$' + aggregationDefinition.avg };
    } else if (aggregationDefinition.sum) {
        result = { '$sum': '$' + aggregationDefinition.sum };
    } else {
        throw new Error('The aggregating function was not recognized or is not supported: ' + JSON.stringify(aggregationDefinition));
    }

    return result;
};

function addGroupingField(fieldName, _idObject, $project) {
    //Add the field in the _id object
    _idObject[fieldName] = '$' + fieldName;

    //Add projection so that the result contains the actual field e.g. is { fieldName: fieldValue } instead of { _id: { fieldName: fieldValue } }
    $project[fieldName] = '$_id.' + fieldName;
}

/*
 * aggregateDefinition = {
 *		Filter: object|null,
 *		GroupBy: string|array|null,
 *		Aggregate: object|null
 * }
 */
AggregationTranslator.translate = function (aggregateDefinition, options) {
    var $match; //$match clause for the pipeline
    var $group; //$group clause for the pipeline
    var $project; //$project clause for the pipeline

    options = options || {};

    //Process the filter
    if (aggregateDefinition.Filter) {
        $match = aggregateDefinition.Filter;
    }

    //Process the GroupBy clause
    var _id; //The required _id clause in the Mongo $group clause
    var groupByDefinition = aggregateDefinition.GroupBy;
    if (groupByDefinition) {
        //Mongo returns all the values of the grouping fields in an _id field, but we use projection to put the values of grouping fields on first level, thus we do not want the _id
        $project = { _id: 0 };

        _id = {};
        if (Array.isArray(groupByDefinition)) {
            //The GroupBy value is an array of fields to group by
            var groupingFields = groupByDefinition;

            //Process each grouping field
            for (var i = 0; i < groupingFields.length; i++) {
                var groupingField = groupingFields[i];
                addGroupingField(groupingField, _id, $project);
            }
        } else {
            //TODO: check if the value is string, and if not - throw error

            //The GroupBy value is the name of the field to group by
            var groupingField = groupByDefinition;

            //Process the grouping field
            addGroupingField(groupingField, _id, $project);
        }
    } else {
        //No GroupBy clause, meaning we apply the aggregation to the whole resultset
        _id = null;

        //Adjust the $project definition so that the '_id' returned by Mongo is not included in the result.
        $project = { _id: 0 };
    }
    $group = { '_id': _id };

    //Process the Aggregate clause
    var aggregateDefinition = aggregateDefinition.Aggregate;
    if (aggregateDefinition) {
        for (var outputFieldName in aggregateDefinition) {
            if (aggregateDefinition.hasOwnProperty(outputFieldName)) {
                var fieldAggregation = aggregateDefinition[outputFieldName];

                //Add the field aggregation to the Mongo $group clause
                $group[outputFieldName] = getFieldAggregation(fieldAggregation);

                //Add the field to the projection, so that it is included in the result
                $project[outputFieldName] = 1;
            }
        }
    }

    //Construct the pipeline
    var pipeline = [];

    if ($match) pipeline.push({ $match: $match });

    if (options.maxDocumentsCount) {
        pipeline.push({ $limit: options.maxDocumentsCount });
    }

    if ($group) pipeline.push({ $group: $group });

    if ($project) pipeline.push({ $project: $project });

    return pipeline;
};

module.exports = AggregationTranslator;

},{}],124:[function(require,module,exports){
'use strict';

var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';
Constants.ReturnItemsCountFieldName = 'ReturnItemsCount';
Constants.AggregateExpressionFieldName = 'Aggregate';

module.exports = Constants;

},{}],125:[function(require,module,exports){
'use strict';

var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function ExecutionNode(parentNode, relationNode) {
    var parentPath = '';
    if (parentNode) {
        parentPath = parentNode.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.aggregateExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A RelationNode instance.
 */
ExecutionNode.prototype._insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype._insertChildNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.aggregateExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a RelationTree object. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of RelationTree.
 * @constructor
 */
var ExecutionTree = function ExecutionTree(relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

ExecutionTree.prototype.getRelationTree = function () {
    return this._relationTree;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relationNodePath - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relationNodePath) {
    if (relationNodePath) {
        return this._relationTree.map[relationNodePath] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree.map[this._relationTree.map.$root] || null;
};

ExecutionTree.prototype.getRootNode = function () {
    var executionTreeMap = this._map;
    var executionTreeRoot = null;
    for (var exNode in executionTreeMap) {
        if (executionTreeMap.hasOwnProperty(exNode)) {
            if (executionTreeMap[exNode].parent === '') {
                executionTreeRoot = executionTreeMap[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

ExecutionTree.prototype.getNode = function (nodeName) {
    return this._map[nodeName];
};

/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.map.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot); //no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parentPath);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {
        //if there is a child that we combine the relation
        childToCombine._insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation); //create a separate execution node that will host the relation
        rootExecutionNode._insertChildNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree.map[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient;

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = { '$in': parentRelationIds };
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return { '$and': filters };
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A RelationNode instance which will get the filter.
 * @param includeArrays - Whether to include array values of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree.map[relation.parentPath];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if (itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if (parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":124}],126:[function(require,module,exports){
'use strict';

function ExpandError(message) {
    this.name = 'ExpandError';
    this.message = message;
    this.stack = new Error().stack;
}
ExpandError.prototype = new Error();
module.exports = ExpandError;

},{}],127:[function(require,module,exports){
'use strict';

var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

function Processor(options) {
	this._executionNodeFunction = options.executionNodeFunction;
	this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
	var self = this;
	return function (done) {
		var relationNode = executionTree.getRelationNode(executionNode.relations[0]); //get the relation node for the only relation of the execution node.
		var parentRelationNode = executionTree.getRelationNode(relationNode.parentPath);
		var includeArrays = !(parentRelationNode.parentPath && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
		var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

		var errorMessage = RelationTreeBuilder.validateSingleRelation(relationNode);
		if (errorMessage) {
			return done(new ExpandError(errorMessage));
		}

		// if we have such options executionNode should have only one relation.
		var node = {};
		node.select = relationNode.fieldsExpression;
		node.sort = relationNode.sortExpression;
		node.skip = relationNode.skip;
		node.take = relationNode.take;
		node.filter = filter;
		node.targetTypeName = relationNode.targetTypeName;
		node.returnItemsCount = relationNode.returnItemsCount;
		node.aggregate = relationNode.aggregateExpression;

		self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
			if (err) {
				return done(err);
			}

			var childRelationNode;

			for (var i = 0; i < executionNode.relations.length; i++) {
				childRelationNode = executionTree.getRelationNode(executionNode.relations[i]);
				childRelationNode.result = self._extractResultForRelation(childRelationNode, result);
			}
			executionNode.result = childRelationNode.result;

			var arr = [];
			for (var j = 0; j < executionNode.children.length; j++) {
				var executionTreeMap = executionTree._map;
				arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
			}
			async.parallel(arr, done);
		});
	};
};

Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject, singleObjectIndex) {
	if (!singleObject) {
		return null;
	}

	var childRelation;
	var childItem;

	// if relation has singleFieldName option we just replace the parent id with a single value
	if (relation.singleFieldName) {
		if (relation.children && relation.children.length > 0) {
			childRelation = relationsTree[relation.children[0]];
			childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
			return this._getSingleResult(relationsTree, childRelation, childItem, 0);
		}
		return singleObject[relation.singleFieldName];
	}

	var result = {};
	var passedProperties = {};

	if (relation.children && relation.children.length > 0) {
		for (var j = 0; j < relation.children.length; j++) {
			childRelation = relationsTree[relation.children[j]];
			var childRelationField = childRelation.relationField;
			var userDefinedRelName = childRelation.userDefinedName;
			if (!childRelation.isInvertedRelation && childRelationField === userDefinedRelName) {
				passedProperties[childRelationField] = 1;
			}

			var innerRelationResult = childRelation.result;

			if (childRelation.isInvertedRelation) {
				if (childRelation.aggregateExpression) {
					result[userDefinedRelName] = innerRelationResult[singleObjectIndex];
				} else if (childRelation.returnItemsCount) {
					result[userDefinedRelName] = innerRelationResult;
				} else {
					for (var k = 0; k < innerRelationResult.length; k++) {
						var singleResult = this._getSingleResult(relationsTree, childRelation, innerRelationResult[k], k);
						if (singleResult) {
							result[userDefinedRelName] = result[userDefinedRelName] || [];
							if (Array.isArray(relation.result)) {
								//Insert the related items in their proper place in the parent item
								if (singleResult[childRelation.relationField] === singleObject.Id) {
									result[userDefinedRelName].push(singleResult);
								}
							} else {
								result[userDefinedRelName].push(singleResult);
							}
						}
					}
				}
			} else {
				result[userDefinedRelName] = childRelation.isArray() ? [] : null;

				if (singleObject[childRelationField]) {
					if (Array.isArray(singleObject[childRelationField])) {
						if (childRelation.aggregateExpression) {
							result[userDefinedRelName] = innerRelationResult[singleObjectIndex];
						} else if (childRelation.sortExpression) {
							// if there is a sorting we replace items using order of the query result
							for (var p = 0; p < innerRelationResult.length; p++) {
								if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
									childItem = innerRelationResult[p];
									this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
								}
							}
						} else {
							// we just replace items getting them by id which we have
							for (var i = 0; i < singleObject[childRelationField].length; i++) {
								childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
								this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
							}
						}
					} else {
						childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
						result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem, 0);
					}
				}
			}
		}
	}

	// add all other fields to the result (except the relation fields which we have already replaced).
	for (var prop in singleObject) {
		if (singleObject.hasOwnProperty(prop)) {
			var propertyShouldBeAddedToResult = !passedProperties[prop] && this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
			if (propertyShouldBeAddedToResult) {
				result[prop] = singleObject[prop];
			}
		}
	}

	return result;
};

Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
	var singleResult = this._getSingleResult(relationsTree, childRelation, childItem, 0);
	result[userDefinedRelName] = result[userDefinedRelName] || [];
	if (singleResult) {
		result[userDefinedRelName].push(singleResult);
	}
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
	if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
		return true;
	}

	if (field === Constants.IdFieldNameClient) {
		if (fieldsExpression[field] === undefined) {
			return true;
		}
		return fieldsExpression[field];
	}

	var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

	if (isExclusive === undefined) {
		return true;
	}

	if (isExclusive) {
		return !fieldsExpression.hasOwnProperty(field);
	} else {
		return fieldsExpression.hasOwnProperty(field);
	}
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype._extractResultForRelation = function (relation, queryResult) {
	if (relation.returnItemsCount || relation.aggregateExpression) {
		return queryResult;
	} else {
		var result = [];
		for (var i = 0; i < queryResult.length; i++) {
			if (relation.parentRelationIds) {
				if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
					result.push(queryResult[i]);
				}
			}
			if (relation.isInvertedRelation) {
				result.push(queryResult[i]);
			}
		}
		return result;
	}
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype._getObjectByIdFromArray = function (array, id) {
	if (array) {
		for (var i = 0; i < array.length; i++) {
			if (array[i].Id === id) {
				return array[i];
			}
		}
	}
	return null;
};

/**
 * @public
 * @param expandExpression
 * @param mainTypeName
 * @param isArray
 * @param fieldsExpression
 * @param maxTakeValue
 * @param prepareContext
 * @param done
 */
Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
	var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
	rtb.build(function (err, map) {
		var mainQueryFieldsExpression;
		if (map) {
			mainQueryFieldsExpression = map[map.$root].fieldsExpression;
			var prepareResult = {
				relationsTree: rtb,
				mainQueryFieldsExpression: mainQueryFieldsExpression
			};
		}
		done(err, prepareResult);
	});
};

/**
 * @public
 * @param relationsTree
 * @param mainQueryResult
 * @param expandContext
 * @param done
 */
Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
	var relationsTreeMap = relationsTree.map;
	var self = this;

	//Build the execution tree
	var executionTree = new ExecutionTree(relationsTree);
	executionTree.build();
	relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;

	var executionTreeMap = executionTree._map;
	var rootExecutionNode = executionTree.getRootNode();
	if (!rootExecutionNode) return;

	//Get a list of execute definitions(queries) to execute against the DB
	var executionList = this._getExecutionList(executionTree, rootExecutionNode, expandContext);

	//Check for the max queries limit
	var maxQueriesCount = 25;
	if (executionList.length > maxQueriesCount) {
		done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
	}

	//Execute them in series, since the result of the parent relation is used to get correct filter.
	async.forEachSeries(executionList, function (executeDefinition, callback) {
		var executeOptions = executeDefinition.executeOptions;
		var relationNode = executeDefinition.relationNode;

		//Adjust the filter for the execute definition, as it sometimes uses the result of the parent relation, which is only available after execution
		self._adjustFilterForExecuteDefinition(executionTree, executeDefinition);

		//Apply the restrictions for expand
		var errorMessage = RelationTreeBuilder.validateSingleRelation(relationNode, relationsTree);
		if (errorMessage) {
			return callback(new ExpandError(errorMessage));
		}

		//Execute the query and set the result
		self._executionNodeFunction.call(null, executeOptions, expandContext, function onProcessExecutionNode(err, result) {
			if (err) {
				return callback(err);
			}

			var relationResult;

			if (executeDefinition.dataItem) {
				relationResult = self._extractResultForRelation(relationNode, result);
				if (!relationNode.result) relationNode.result = [];
				relationNode.result.push(relationResult);
			} else {
				var executionNode = executeDefinition.executionNode;
				var childRelationNode;
				for (var i = 0; i < executionNode.relations.length; i++) {
					childRelationNode = executionTree.getRelationNode(executionNode.relations[i]);
					childRelationNode.result = self._extractResultForRelation(childRelationNode, result);
				}
				executionNode.result = childRelationNode.result;
			}

			callback();
		});
	}, function onProcessExecutionTree(err) {
		if (err) {
			done(err);
		} else {
			var output;
			var rootRelation = relationsTreeMap[relationsTreeMap.$root];
			if (Array.isArray(mainQueryResult)) {
				output = [];
				for (var i = 0; i < mainQueryResult.length; i++) {
					var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i], i);
					if (singleResult) {
						output.push(singleResult);
					}
				}
			} else {
				output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult, 0);
			}
			done(null, output);
		}
	});
};

Processor.prototype._getExecutionList = function (executionTree, executionNode, expandContext) {
	var self = this;

	var relationTree = executionTree.getRelationTree();
	var relationNode = executionTree.getRelationNode(executionNode.name);
	var relationResult = relationNode.result;

	var executeDefinitions = [];
	for (var i = 0; i < executionNode.children.length; i++) {
		var executeDefinition;

		var childNodeName = executionNode.children[i];
		var childExecutionNode = executionTree.getNode(childNodeName);
		var childRelationNode = executionTree.getRelationNode(childNodeName);
		if (childRelationNode.aggregateExpression) {
			var relationResult = relationResult;
			if (!Array.isArray(relationResult)) relationResult = [relationResult];

			for (var j = 0; j < relationResult.length; j++) {
				executeDefinition = this._getExecuteDefinitionForItem(relationResult[j], childRelationNode, relationTree, expandContext);
				executeDefinitions.push(executeDefinition);
			}
		} else {
			executeDefinition = this._getExecuteDefinitionForNode(executionTree, childExecutionNode, expandContext);
			executeDefinitions.push(executeDefinition);
		}

		var childFunctions = this._getExecutionList(executionTree, childExecutionNode, expandContext);
		executeDefinitions = executeDefinitions.concat(childFunctions);
	}

	return executeDefinitions;
};

//Adjusts the filter for the query
Processor.prototype._adjustFilterForExecuteDefinition = function (executionTree, executeDefinition) {
	var filter;

	var relationNode = executeDefinition.relationNode;

	if (executeDefinition.dataItem) {
		filter = this._getFilterFromSingleItem(executeDefinition.dataItem, relationNode);
	} else {
		var executionNode = executeDefinition.executionNode;
		var parentRelationNode = executionTree.getRelationNode(relationNode.parentPath);
		var includeArrays = !(parentRelationNode.parentPath && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
		filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);
	}

	executeDefinition.executeOptions.filter = filter;
};

Processor.prototype._getExecuteDefinitionForItem = function (dataItem, relationNode, relationTree, expandContext) {
	//Create ExecuteOptions object
	var executeOptions = {};
	executeOptions.select = relationNode.fieldsExpression;
	executeOptions.sort = relationNode.sortExpression;
	executeOptions.skip = relationNode.skip;
	executeOptions.take = relationNode.take;
	executeOptions.targetTypeName = relationNode.targetTypeName;
	executeOptions.returnItemsCount = relationNode.returnItemsCount;
	executeOptions.aggregate = relationNode.aggregateExpression;

	return {
		executeOptions: executeOptions,
		relationNode: relationNode,
		dataItem: dataItem
	};
};

Processor.prototype._getExecuteDefinitionForNode = function (executionTree, executionNode, expandContext) {
	//get the relation node for the only relation of the execution node.
	var relationNode = executionTree.getRelationNode(executionNode.relations[0]);

	// if we have such options executionNode should have only one relation.
	var executeOptions = {};
	executeOptions.select = relationNode.fieldsExpression;
	executeOptions.sort = relationNode.sortExpression;
	executeOptions.skip = relationNode.skip;
	executeOptions.take = relationNode.take;
	executeOptions.targetTypeName = relationNode.targetTypeName;
	executeOptions.returnItemsCount = relationNode.returnItemsCount;
	executeOptions.aggregate = relationNode.aggregateExpression;

	return {
		executeOptions: executeOptions,
		relationNode: relationNode,
		executionNode: executionNode
	};
};

/**
 * Gets filter expression from a single item for certain relation.
 * along with user defined filters.
 * @param dataItem - The dataItem to get filter for.
 * @param relationNode - A RelationNode instance.
 * @returns {*}
 */
Processor.prototype._getFilterFromSingleItem = function (dataItem, relationNode) {
	var userDefinedFilter = relationNode.filterExpression;
	var itemFilter;

	var relationFieldName = relationNode.relationField;

	if (relationNode.isInvertedRelation) {
		itemFilter = {};
		itemFilter[relationNode.relationField] = dataItem.Id;
	} else {
		var relationData = dataItem[relationFieldName];
		if (relationData) {
			if (Array.isArray(relationData)) {
				itemFilter = { "Id": { "$in": relationData } };
			} else {
				itemFilter = { "Id": relationData };
			}
		} else {
			//TODO
			//Here we must stop the query, as there are no related items
		}
	}

	if (itemFilter && userDefinedFilter) {
		return { '$and': [itemFilter, userDefinedFilter] };
	} else if (itemFilter) {
		return itemFilter;
	} else if (userDefinedFilter) {
		return userDefinedFilter;
	} else {
		return null;
	}
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":124,"./ExecutionTree":125,"./ExpandError":126,"./RelationTreeBuilder":129,"async":1}],128:[function(require,module,exports){
'use strict';

var Constants = require('./Constants');
var _ = require('underscore');
var ExpandError = require('./ExpandError');

function RelationNode(options) {
    this.parentPath = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    this.targetTypeName = options.targetTypeName;
    //An array containing the paths(strings) of the child relations for this node
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false; //set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
    this.returnItemsCount = expandExpression[Constants.ReturnItemsCountFieldName];
    this.aggregateExpression = expandExpression[Constants.AggregateExpressionFieldName];
}

/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
};

/**
 * Creates a RelationNode object representing an external(inverted) relation.
 * @param relationPath - A path to the external relation field (example: "Comments.ActivityId")
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param parentRelationPath - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationNode.createInverted = function (relationPath, expandExpression, parentRelationPath, maxTakeValue) {
    var relationNameParts = relationPath.split('.');
    var targetTypeName = relationNameParts[0];
    var relationField = relationNameParts[1];

    return RelationNode._create(relationPath, targetTypeName, relationField, parentRelationPath, maxTakeValue, expandExpression, true);
};

/**
 * Creates a RelationNode object representing a regular relation.
 * @param relationField - The field to expand (example: "Likes")
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param parentRelationPath - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationNode.createRegular = function (relationField, expandExpression, parentRelationPath, maxTakeValue) {
    var options = {};

    var relationPath = parentRelationPath + '.' + relationField;
    var targetTypeName = expandExpression[Constants.TargetTypeNameFieldName];

    return RelationNode._create(relationPath, targetTypeName, relationField, parentRelationPath, maxTakeValue, expandExpression, false);
};

RelationNode._create = function (relationPath, targetTypeName, releationField, parentRelationPath, maxTakeValue, expandExpression, isInvertedRelation) {
    var options = {};

    options.parent = parentRelationPath;
    options.path = relationPath;
    options.maxTakeValue = maxTakeValue;
    options.validated = false;
    options.expandExpression = expandExpression;
    options.relationField = releationField;
    options.targetTypeName = targetTypeName;
    options.isInvertedRelation = isInvertedRelation;

    return new RelationNode(options);
};

module.exports = RelationNode;

},{"./Constants":124,"./ExpandError":126,"underscore":36}],129:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [Constants.ExpandExpressionName, Constants.ReturnAsFieldName, Constants.FieldsExpressionName, Constants.SingleFieldExpressionName, Constants.SortExpressionName, Constants.FilterExpressionName, Constants.SkipExpressionName, Constants.TakeExpressionName, Constants.ParentRelationFieldName, Constants.TargetTypeNameFieldName, Constants.ReturnItemsCountFieldName, Constants.AggregateExpressionFieldName];

/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this._processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype._processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([this.configureRelationTree.bind(this), this.validateRelationTree.bind(this)], function (err) {
        done(err, self.map);
    });
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var fieldExpression = expandExpression[relationName];

            //Check if all options in an expand field definition are recognized
            for (var option in fieldExpression) {
                if (fieldExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                //If the relation is inverted
                var invertedRelation = RelationNode.createInverted(relationName, fieldExpression, rootName, this.maxTakeValue);

                this.map[invertedRelation.path] = invertedRelation;
                this.map[rootName].children.push(invertedRelation.path);

                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parentPath].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this._processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var relationNode = RelationNode.createRegular(relationName, fieldExpression, rootName, this.maxTakeValue);

                this.map[relationNode.path] = relationNode;
                this.map[rootName].children.push(relationNode.path);

                if (fieldExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (_typeof(fieldExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this._processExpandExpression(fieldExpression.Expand), relationNode.path);
                    } else {
                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var relationPath in this.map) {
            if (this.map.hasOwnProperty(relationPath)) {
                if (this.map[relationPath].parentPath !== null) {
                    relationNames.push(this.map[relationPath].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += RelationTreeBuilder.validateSingleRelation(relation, this);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new ExpandError(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parentPath) {
        var parentRelationFieldsExpression = this.map[relation.parentPath].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parentPath], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relationNode - A relation which will be validated.
 * @param relationTree - The whole relation tree.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.validateSingleRelation = function (relationNode, relationTree) {
    var errorMessage = '';
    var relationTreeMap = relationTree.map;
    var rootRelationNode = relationTreeMap[relationTreeMap.$root];
    var EOL = '\r\n';
    var isGetByFilterQuery = rootRelationNode.isArrayRoot;

    if (relationNode.path === relationNode.parentPath) {
        errorMessage += relationNode.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relationNode.isArray()) {
        var multipleQueriesCount = RelationTreeBuilder._getParentMultipleRelationsCount(relationNode, relationTree);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relationNode.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (relationTreeMap[relationNode.parentPath] === rootRelationNode && isGetByFilterQuery && (relationNode.filterExpression || relationNode.sortExpression)) {
            errorMessage += 'Filter and Sort are not allowed when expanding multiple items.';
            errorMessage += EOL;
        }

        if (relationTreeMap[relationNode.parentPath] === rootRelationNode && isGetByFilterQuery && relationNode.isInvertedRelation && relationNode.skip) {
            errorMessage += 'Skip and Take are not supported when expanding multiple items with external relation.';
            errorMessage += EOL;
        }

        //if (isGetByFilterQuery && relationNode.isInvertedRelation) {
        //    errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
        //    errorMessage += EOL;
        //}
    }

    if (!relationNode.targetTypeName) {
        errorMessage += 'Expanding relation \"' + relationNode.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
        errorMessage += EOL;
    }

    if (relationNode.fieldsExpression && Object.keys(relationNode.fieldsExpression).length && relationNode.singleFieldName) {
        errorMessage += relationNode.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }

    if (relationNode.singleFieldName) {
        if (relationNode.children) {
            if (relationNode.children.length > 1) {
                errorMessage += relationNode.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relationNode.children.length === 1 && relationTreeMap[relationNode.children[0]].relationField !== relationNode.singleFieldName) {
                errorMessage += 'Expand expression ' + relationNode.path;
                errorMessage += ' single field \"' + relationNode.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + relationTreeMap[relationNode.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder._getParentMultipleRelationsCount = function (relationNode, relationTree) {
    var result = 0;
    var currentRelation = relationNode;
    while (currentRelation.parentPath) {
        var parentRelation = relationTree.map[currentRelation.parentPath];
        if (parentRelation.isArray() && parentRelation.parentPath) {
            result += 1;
        }
        currentRelation = parentRelation;
    }
    return result;
};

/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (_typeof(fieldsExpression[fieldName]) === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":124,"./ExpandError":126,"./RelationNode":128,"async":1,"underscore":36}]},{},[122])(122)
});
//# sourceMappingURL=everlive.map
