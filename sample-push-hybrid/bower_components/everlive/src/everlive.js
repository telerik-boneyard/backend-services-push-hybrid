if (typeof define !== "undefined" && define.amd) { define(function () { return Everlive; }); }(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],6:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":5,"_process":4,"inherits":3}],7:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":18,"component-type":10,"debug":11,"dot-component":14,"mongo-eql":16,"object-component":17}],8:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":7,"./mods":9,"component-type":10,"debug":11,"dot-component":14,"object-component":17}],9:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":10,"debug":11,"dot-component":14,"mongo-eql":16,"object-component":17}],10:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],11:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":12}],12:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":13}],13:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],14:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":15}],15:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],16:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":10}],17:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],18:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":10,"mongo-eql":16}],19:[function(require,module,exports){
var CryptoJS = require('./lib/core').CryptoJS;
require('./lib/enc-base64');
require('./lib/md5');
require('./lib/evpkdf');
require('./lib/cipher-core');
require('./lib/aes');
var JsonFormatter = require('./lib/jsonformatter').JsonFormatter;

exports.CryptoJS = CryptoJS;
exports.JsonFormatter = JsonFormatter;
},{"./lib/aes":20,"./lib/cipher-core":21,"./lib/core":22,"./lib/enc-base64":23,"./lib/evpkdf":24,"./lib/jsonformatter":25,"./lib/md5":26}],20:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

},{"./core":22}],21:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

},{"./core":22}],22:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

exports.CryptoJS = CryptoJS;

},{}],23:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

},{"./core":22}],24:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;

    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */
    var EvpKDF = C_algo.EvpKDF = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.EvpKDF.create();
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init hasher
            var hasher = cfg.hasher.create();

            // Initial values
            var derivedKey = WordArray.create();

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                if (block) {
                    hasher.update(block);
                }
                var block = hasher.update(password).finalize(salt);
                hasher.reset();

                // Iterations
                for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                }

                derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
    };
}());

},{"./core":22}],25:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

// create custom json serialization format
var JsonFormatter = {
	stringify: function (cipherParams) {
		// create json object with ciphertext
		var jsonObj = {
			ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
		};
		
		// optionally add iv and salt
		if (cipherParams.iv) {
			jsonObj.iv = cipherParams.iv.toString();
		}
		
		if (cipherParams.salt) {
			jsonObj.s = cipherParams.salt.toString();
		}

		// stringify json object
		return JSON.stringify(jsonObj)
	},

	parse: function (jsonStr) {
		// parse json string
		var jsonObj = JSON.parse(jsonStr);
		
		// extract ciphertext from json object, and create cipher params object
		var cipherParams = CryptoJS.lib.CipherParams.create({
			ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
		});
		
		// optionally extract iv and salt
		if (jsonObj.iv) {
			cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
		}
            
		if (jsonObj.s) {
			cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
		}
		
		return cipherParams;
	}
};

exports.JsonFormatter = JsonFormatter;
},{"./core":22}],26:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

},{"./core":22}],27:[function(require,module,exports){
'use strict';
var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';

module.exports = Constants;
},{}],28:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function (parent, relationNode) {
    var parentPath = '';
    if (parent) {
        parentPath = parent.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A Relation instance.
 */
ExecutionNode.prototype.insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype.insertChildrenNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a relationTree. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of relation tree.
 * @constructor
 */
var ExecutionTree = function (relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relation - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relation) {
    if (relation) {
        return this._relationTree[relation] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree[this._relationTree.$root] || null;
};
/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parent);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {//if there is a child that we combine the relation
        childToCombine.insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
        rootExecutionNode.insertChildrenNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return {'$and': filters};
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A relation instance which will get the filter.
 * @param includeArrays - Whether to include array valus of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree[relation.parent];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":27}],29:[function(require,module,exports){
'use strict';
function ExpandError(message) {
    this.name = 'ExpandError';
    this.message = message;
    this.stack = (new Error()).stack;
}
ExpandError.prototype = new Error;
module.exports = ExpandError;
},{}],30:[function(require,module,exports){
'use strict';
var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

function Processor(options) {
    this._executionNodeFunction = options.executionNodeFunction;
    this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype._getExecutionTreeRoot = function (executionTree) {
    var executionTreeRoot = null;
    for (var exNode in executionTree) {
        if (executionTree.hasOwnProperty(exNode)) {
            if (executionTree[exNode].parent === '') {
                executionTreeRoot = executionTree[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
    var self = this;
    var relationsTreeMap = relationsTree.map;
    return function (done) {
        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
        var parentRelationNode = executionTree.getRelationNode(relationNode.parent);
        var includeArrays = !(parentRelationNode.parent && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

        var errorMessage = relationsTree.validateSingleRelation(relationNode);
        if (errorMessage) {
            return done(new ExpandError(errorMessage));
        }

        // if we have such options executionNode should have only one relation.
        var node = {};
        node.select = relationNode.fieldsExpression;
        node.sort = relationNode.sortExpression;
        node.skip = relationNode.skip;
        node.take = relationNode.take;
        node.filter = filter;
        node.targetTypeName = relationNode.targetTypeName;

        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
            if (err) {
                return done(err);
            }

            for (var i = 0; i < executionNode.relations.length; i++) {
                var childRelation = relationsTreeMap[executionNode.relations[i]];
                childRelation.result = self._extractResultForRelation(relationsTreeMap[executionNode.relations[i]], result);
            }
            executionNode.result = childRelation.result;
            var arr = [];
            for (var j = 0; j < executionNode.children.length; j++) {
                var executionTreeMap = executionTree._map;
                arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
            }
            async.parallel(arr, done);
        });
    };
};

Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject) {
    if (!singleObject) {
        return null;
    }

    var childRelation;
    var childItem;

    // if relation has singleFieldName option we just replace the parent id with a single value
    if (relation.singleFieldName) {
        if (relation.children && relation.children.length > 0) {
            childRelation = relationsTree[relation.children[0]];
            childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
            return this._getSingleResult(relationsTree, childRelation, childItem);
        }
        return singleObject[relation.singleFieldName];
    }

    var result = {};
    var passedProperties = {};

    if (relation.children && relation.children.length > 0) {
        for (var j = 0; j < relation.children.length; j++) {
            childRelation = relationsTree[relation.children[j]];
            var childRelationField = childRelation.relationField;
            var userDefinedRelName = childRelation.userDefinedName;
            if (!childRelation.isInvertedRelation) {
                passedProperties[childRelationField] = 1;
            }

            var innerRelationResult = childRelation.result;

            if (childRelation.isInvertedRelation) {
                for (var k = 0; k < innerRelationResult.length; k++) {
                    this._addSingleResultToParentArray(relationsTree, childRelation, innerRelationResult[k], result, userDefinedRelName);
                }
            } else {
                result[userDefinedRelName] = childRelation.isArray() ? [] : null;

                if (singleObject[childRelationField]) {
                    if (Array.isArray(singleObject[childRelationField])) {
                        if (childRelation.sortExpression) {
                            // if there is a sorting we replace items using order of the query result
                            for (var p = 0; p < innerRelationResult.length; p++) {
                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
                                    childItem = innerRelationResult[p];
                                    this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                                }
                            }
                        } else {
                            // we just replace items getting them by id which we have
                            for (var i = 0; i < singleObject[childRelationField].length; i++) {
                                childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
                                this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                            }
                        }
                    } else {
                        childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
                        result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem);
                    }
                }
            }
        }
    }

    // add all other fields to the result (except the relation fields which we have already replaced).
    for (var prop in singleObject) {
        var propertyShouldBeAddedToResult = singleObject.hasOwnProperty(prop) && !passedProperties[prop] &&
            this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
        if (propertyShouldBeAddedToResult) {
            result[prop] = singleObject[prop];
        }
    }

    return result;
};

Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
    var singleResult = this._getSingleResult(relationsTree, childRelation, childItem);
    result[userDefinedRelName] = result[userDefinedRelName] || [];
    if (singleResult) {
        result[userDefinedRelName].push(singleResult);
    }
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return true;
    }

    if (field === Constants.IdFieldNameClient) {
        if (fieldsExpression[field] === undefined) {
            return true;
        }
        return fieldsExpression[field];
    }

    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return true;
    }

    if (isExclusive) {
        return !fieldsExpression.hasOwnProperty(field);
    } else {
        return fieldsExpression.hasOwnProperty(field);
    }
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype._extractResultForRelation = function (relation, queryResult) {
    var result = [];
    for (var i = 0; i < queryResult.length; i++) {
        if (relation.parentRelationIds) {
            if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
                result.push(queryResult[i]);
            }
        }
        if (relation.isInvertedRelation) {
            result.push(queryResult[i]);
        }
    }
    return result;
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype._getObjectByIdFromArray = function (array, id) {
    if (array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].Id === id) {
                return array[i];
            }
        }
    }
    return null;
};

/**
 * @public
 * @param expandExpression
 * @param mainTypeName
 * @param isArray
 * @param fieldsExpression
 * @param maxTakeValue
 * @param prepareContext
 * @param done
 */
Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
    rtb.build(function (err, map) {
        var mainQueryFieldsExpression;
        if (map) {
            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
            var prepareResult = {
                relationsTree: rtb,
                mainQueryFieldsExpression: mainQueryFieldsExpression
            }
        }
        done(err, prepareResult);
    });
};

/**
 * @public
 * @param relationsTree
 * @param mainQueryResult
 * @param expandContext
 * @param done
 */
Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
    var relationsTreeMap = relationsTree.map;
    var self = this;
    var executionTree = new ExecutionTree(relationsTreeMap);
    executionTree.build();
    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
    var executionTreeMap = executionTree._map;

    var executionTreeRoot = this._getExecutionTreeRoot(executionTreeMap);

    var maxQueriesCount = 20;
    if (Object.keys(executionTreeMap).length > maxQueriesCount) {
        done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
    }

    if (executionTreeRoot) {
        var execFuncs = [];
        for (var i = 0; i < executionTreeRoot.children.length; i++) {
            execFuncs.push(this._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionTreeRoot.children[i]], expandContext));
        }
        // execFuncs are functions created for every single execution note
        // we execute them in async, since the result of the parent relation is used to get correct filter.
        async.series(execFuncs, function onProcessExecutionTree(err) {
            if (err) {
                done(err);
            } else {
                var output;
                var rootRelation = relationsTreeMap[relationsTreeMap.$root];
                if (Array.isArray(mainQueryResult)) {
                    output = [];
                    for (var i = 0; i < mainQueryResult.length; i++) {
                        var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i]);
                        if (singleResult) {
                            output.push(singleResult);
                        }
                    }
                } else {
                    output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult);
                }
                done(null, output);
            }
        });
    }
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":27,"./ExecutionTree":28,"./ExpandError":29,"./RelationTreeBuilder":32,"async":33}],31:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');
var _ = require('underscore');
var ExpandError = require('./ExpandError');

function RelationNode(options) {
    this.parent = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    this.targetTypeName = options.targetTypeName;
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
}


/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
};

module.exports = RelationNode;

},{"./Constants":27,"./ExpandError":29,"underscore":1}],32:[function(require,module,exports){
'use strict';
var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [
    Constants.ExpandExpressionName,
    Constants.ReturnAsFieldName,
    Constants.FieldsExpressionName,
    Constants.SingleFieldExpressionName,
    Constants.SortExpressionName,
    Constants.FilterExpressionName,
    Constants.SkipExpressionName,
    Constants.TakeExpressionName,
    Constants.ParentRelationFieldName,
    Constants.TargetTypeNameFieldName
];


/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this.processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype.processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([
        this.configureRelationTree.bind(this),
        this.validateRelationTree.bind(this)
    ], function (err) {
        done(err, self.map);
    });
};

/**
 *
 * @param relationName - A path to the external relation collection (Comments.ActivityId)
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param rootName - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationTreeBuilder.prototype.createInvertedRelation = function (relationName, expandExpression, rootName) {
    var options = {};
    var relationNameParts = relationName.split('.');
    options.parent = rootName;
    options.relationField = relationNameParts[1];
    options.isInvertedRelation = true;
    options.targetTypeName = relationNameParts[0];
    options.expandExpression = expandExpression;
    options.path = relationName;
    options.maxTakeValue = this.maxTakeValue;
    options.validated = false;

    return new RelationNode(options);
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var currentExpression = expandExpression[relationName];

            for (var option in currentExpression) {
                if (currentExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                var invertedRelation = this.createInvertedRelation(relationName, currentExpression, rootName);
                this.map[invertedRelation.path] = invertedRelation;
                this.map[invertedRelation.parent].children.push(invertedRelation.path);
                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parent].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this.processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var options = {};
                options.relationField = relationName;
                options.parent = rootName;
                options.expandExpression = currentExpression;
                options.maxTakeValue = this.maxTakeValue;
                options.targetTypeName = currentExpression[Constants.TargetTypeNameFieldName];
                var relationNode = new RelationNode(options);
                var parentNode = this.map[options.parent];
                parentNode.children.push(relationNode.path);
                this.map[relationNode.path] = relationNode;

                if (currentExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (typeof(currentExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this.processExpandExpression(currentExpression.Expand), relationNode.path);
                    } else {
                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var rel in this.map) {
            if (this.map.hasOwnProperty(rel)) {
                if (this.map[rel].parent !== null) {
                    relationNames.push(this.map[rel].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += this.validateSingleRelation(relation);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new ExpandError(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parent) {
        var parentRelationFieldsExpression = this.map[relation.parent].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parent], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relation - A relation which will be validated.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.prototype.validateSingleRelation = function (relation) {
    var errorMessage = '';
    var EOL = '\r\n';
    var isGetByFilterQuery = this.map[this.map.$root].isArrayRoot;

    if (relation.path === relation.parent) {
        errorMessage += relation.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relation.isArray()) {
        var multipleQueriesCount = this.getParentMultipleRelationsCount(relation);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relation.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (this.map[relation.parent] === this.map[this.map.$root] &&
            isGetByFilterQuery &&
            (relation.filterExpression || relation.sortExpression)) {
            errorMessage += 'Filter and Sort expressions are not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }

        if (isGetByFilterQuery && relation.isInvertedRelation) {
            errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }
    }
    if (!relation.targetTypeName) {
        errorMessage += 'Expanding relation \"' + relation.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
        errorMessage += EOL;
    }
    if (relation.fieldsExpression && Object.keys(relation.fieldsExpression).length && relation.singleFieldName) {
        errorMessage += relation.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }
    if (relation.singleFieldName) {
        if (relation.children) {
            if (relation.children.length > 1) {
                errorMessage += relation.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relation.children.length === 1 && this.map[relation.children[0]].relationField !== relation.singleFieldName) {
                errorMessage += 'Expand expression ' + relation.path;
                errorMessage += ' single field \"' + relation.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + this.map[relation.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder.prototype.getParentMultipleRelationsCount = function (relation) {
    var result = 0;
    var relationForLoop = relation;
    while (relationForLoop.parent) {
        var parentRelation = this.map[relationForLoop.parent];
        if (parentRelation.isArray() && parentRelation.parent) {
            result += 1;
        }
        relationForLoop = parentRelation;
    }
    return result;
};


/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (typeof fieldsExpression[fieldName] === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":27,"./ExpandError":29,"./RelationNode":31,"async":33,"underscore":1}],33:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":4}],34:[function(require,module,exports){
var buildPromise = require('./utils').buildPromise;
var EverliveError = require('./EverliveError').EverliveError;
var Platform = require('./constants').Platform;
var common = require('./common');
var jstz = common.jstz;
var _ = common._;

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (success, error) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            if (self.emulatorMode) {
                                success();
                            } else {
                                var pushNotification = window.plugins.pushNotification;
                                var unregisterOptions;
                                var platformType = self._getPlatformType(device.platform);
                                if (platformType === Platform.WindowsPhone) {
                                    unregisterOptions = {'channelName': self.pushSettings.wp8.channelName};
                                }
                                pushNotification.unregister(
                                    function () {
                                        self.isInitialized = false;
                                        success();
                                    },
                                    error,
                                    unregisterOptions
                                );
                            }
                        },
                        success,
                        error
                    );
                },
                error
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function (actionIdentifier) {
                var action = _.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
                }
            });

            pushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error, {
                    // asking permission for these features
                    types: notificationTypes,
                    // register these categories
                    categories: categories
                }
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(
                    function () {
                        self._deviceRegistrationSuccess('fake_push_token');
                    },
                    1000
                );
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType(device.platform);
            if (platformType === Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                this._validateIOSSettings(apnRegistrationOptions);
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this),
                    apnRegistrationOptions
                );
            } else if (platformType === Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this),
                    gcmRegistrationOptions
                );
            } else if (platformType === Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;


                pushNotification.register(
                    _.bind(this._successSentRegistrationWP8, this),
                    _.bind(this._errorSentRegistrationWP8, this),
                    wp8RegistrationOptions
                );

            } else {
                throw new EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function (result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _validateWP8Settings: function (settings) {
            if (!settings.channelName) {
                throw new EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _validateIOSSettings: function (iOSSettings) {

        },

        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = device.model;
                            var platformType = self._getPlatformType(device.platform);
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = locale.value;
                            var platformVersion = device.version;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }
        },

        _getDeviceId: function () {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function (platformString) {
            var psLower = platformString.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                case 'wince':
                    return Platform.WindowsPhone;
                case 'win32nt': // real wp8 devices return this string as platform identifier.
                    return Platform.WindowsPhone;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function (id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function (e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function (e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}());
},{"./EverliveError":36,"./common":46,"./constants":47,"./utils":66}],35:[function(require,module,exports){
var Setup = require('./Setup');
var Data = require('./types/Data');
var usersModule = require('./types/Users');
var filesModule = require('./types/Files');
var constants = require('./constants');
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var Push = require('./Push');
var Authentication = require('./auth/Authentication');
var offlineModule = require('./offline/offline');
var Request = require('./Request');
var common = require('./common');
var rsvp = common.rsvp;
var _ = common._;
var EverliveError = require('./EverliveError').EverliveError;
var EverliveErrors = require('./EverliveError').EverliveErrors;
var EventEmitter = require('events').EventEmitter;

module.exports = (function () {

    // The constructor of Everlive instances.
    // The entry point for the SDK.

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your API key.
     * @param {string} options.apiKey - Your API key.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offlineStorage] - Set this option to true to use the default offline settings.
     * @param {boolean} [options.offlineStorage.autoSync=true] - Whether to sync data automatically when offing online.
     * @param {boolean} [options.offlineStorage.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offlineStorage.conflictResolutionStrategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {StorageProvider|object} [options.offlineStorage.storageProviderSettings=StorageProvider.LocalStorage] - An object specifying settings for the offline storage provider.
     * @param {function} [options.offlineStorage.syncStart=null] - A function that is called whenever a synchronisation starts.
     * @param {function} [options.offlineStorage.syncEnd=null] - A function that is called when the synchronization completes. The function receives a list of sync errors.
     */
    function Everlive(options) {
        var self = this;
        this.setup = new Setup(options);
        _.each(initializations, function (init) {
            init.func.call(self, options);
        });

        if (Everlive.$ === null) {
            Everlive.$ = self;
        }

        this._emitter = new EventEmitter();
    }

    Everlive.prototype._emitterProxy = function (event, args) {
        this._emitter[event].apply(this._emitter, args);
    };

    Everlive.prototype.addListener = function () {
        this._emitterProxy('addListener', arguments);
    };
    Everlive.prototype.on = Everlive.prototype.addListener;

    Everlive.prototype.removeListener = function () {
        this._emitterProxy('removeListener', arguments);
    };
    Everlive.prototype.off = Everlive.prototype.removeListener;

    Everlive.prototype.once = function () {
        this._emitterProxy('once', arguments);
    };

    Everlive.prototype.removeAllListeners = function () {
        this._emitterProxy('removeAllListeners', arguments);
    };

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */
    Everlive.$ = null;
    Everlive.idField = constants.idField;


    // An array keeping initialization functions called by the Everlive constructor.
    // These functions will be used to extend the functionality of an Everlive instance.
    var initializations = [];

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */
    Everlive.initializations = initializations;

    /** Creates a new {{site.TelerikBackendServices}} (Everlive) Java Script SDK instance.
     * @memberOf Everlive
     * @param {object} options - An object containing options used to initialize the {{site.bs}} JavaScript SDK instance.
     * @returns {Everlive} The instance of the {{site.bs}} (Everlive) JavaScript SDK that was created using the provided options.
     * @static
     * @method
     */
    Everlive.init = function (options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    Everlive.prototype.data = function (collectionName) {
        return new Data(this.setup, collectionName, this.offlineStorage, this);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */
    Everlive.prototype.buildUrl = function () {
        return utils.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */
    Everlive.prototype.buildAuthHeader = function () {
        return buildAuthHeader(this.setup);
    };

    Everlive.disableRequestCache = function (url, method) {
        if (method === 'GET') {
            var timestamp = (new Date()).getTime();
            var separator = url.indexOf('?') > -1 ? '&' : '?';
            url += separator + '_el=' + timestamp;
        }

        return url;
    };

    Everlive.AuthStatus = constants.AuthStatus;

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Everlive.prototype.authInfo = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self.setup;
            if (setup.masterKey) {
                return success({status: Everlive.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: Everlive.AuthStatus.unauthenticated});
            }

            if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                return success({status: Everlive.AuthStatus.authenticating});
            }

            self.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: Everlive.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                        return success({status: Everlive.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.expiredToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: Everlive.AuthStatus.invalidAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the API key section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter]({% slug rest-api-querying-filtering %}) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */
    Everlive.prototype.request = function (options) {
        return new Request(this.setup, options);
    };

    function protectOfflineEnabled() {
        if (!this._isOfflineStorageEnabled()) {
            throw new EverliveError('You have instantiated the SDK without support for offline storage');
        }
    }

    Everlive.prototype._isOfflineStorageEnabled = function () {
        return !!this.setup.offlineStorage;
    };

    /**
     * Sets the SDK to work in offline mode
     * @memberOf Everlive.prototype
     * @param {boolean} [offline] Boolean parameter for setting the SDK to online or offline mode
     */
    Everlive.prototype.offline = function () {
        protectOfflineEnabled.call(this);

        var isOffline;
        if (arguments.length === 0) {
            isOffline = true;
        } else {
            isOffline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(isOffline);
    };

    /**
     * Sets the SDK to work in online mode
     * @memberOf Everlive.prototype
     * @param {boolean} [online] Boolean parameter for setting the SDK to online or offline mode
     */
    Everlive.prototype.online = function () {
        protectOfflineEnabled.call(this);

        var isOnline;
        if (arguments.length === 0) {
            isOnline = true;
        } else {
            isOnline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(!isOnline);
    };

    /**
     * Check if the SDK is in offline mode
     * @memberOf Everlive.prototype
     * @returns {boolean} isOffline Returns true if the SDK is in offline mode
     */
    Everlive.prototype.isOffline = function () {
        protectOfflineEnabled.call(this);
        return !this.isOnline();
    };

    /**
     * Check if the SDK is in online mode
     * @memberOf Everlive.prototype
     * @returns {boolean} isOnline Returns true if the SDK is in online mode
     */
    Everlive.prototype.isOnline = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.isOnline();
    };

    /**
     * Starts the synchronization procedure. Emits the 'syncStart' event once started and the 'syncEnd' event once the procedure finishes
     * @memberOf Everlive.prototype
     */
    Everlive.prototype.sync = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
    };

    var initDefault = function initDefault() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} Users
         */
        this.Users = this.data('Users');
        usersModule.addUsersFunctions(this.Users, this);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} Files
         */
        this.Files = this.data('Files');
        filesModule.addFilesFunctions(this.Files);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Push]{@link Push} class for working with push notifications.
         * @member {Push} push
         */
        this.push = new Push(this);
    };

    var initAuthentication = function initAuthentication() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
         * @member {Authentication} authentication
         */
        this.authentication = new Authentication(this, this.setup.authentication);
    };

    initializations.push({name: 'offlineStorage', func: offlineModule.initOfflineStorage});
    initializations.push({name: 'default', func: initDefault});
    initializations.push({name: 'authentication', func: initAuthentication});

    return Everlive;
}());

},{"./EverliveError":36,"./Push":41,"./Request":42,"./Setup":43,"./auth/Authentication":44,"./common":46,"./constants":47,"./offline/offline":53,"./types/Data":63,"./types/Files":64,"./types/Users":65,"./utils":66,"events":2}],36:[function(require,module,exports){
var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 4242,
        message: 'A conflict occurred while syncing data.'
    },
    syncError: {
        code: 4243,
        message: 'Synchronization failed for item.'
    },
    syncInProgress: {
        code: 4244,
        message: 'Cannot perform operation while synchronization is in progress'
    },
    generalDatabaseError: {
        code: 107,
        message: 'General database error'
    },
    invalidToken: {
        code: 301,
        message: 'Invalid access token'
    },
    expiredToken: {
        code: 302,
        message: 'Expired access token'
    },
    invalidExpandExpression: {
        code: 618,
        message: 'Invalid expand expression.'
    },
    invalidRequest: {
        code: 601,
        message: 'Invalid request.'
    }
};

var EverliveError = (function () {
    function EverliveError(message, code) {
        var tmp = Error.apply(this, arguments);

        tmp.name = this.name = 'EverliveError';

        this.message = tmp.message;
        this.code = code;

        Object.defineProperty(this, 'stack', {
            get: function () {
                return tmp.stack
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            stack: this.stack
        };
    };

    return EverliveError;
}());

var DeviceRegistrationError = (function () {
    var DeviceRegistrationError = function (errorType, message, additionalInformation) {
        EverliveError.call(this, message);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}());

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    DeviceRegistrationError: DeviceRegistrationError
};
},{}],37:[function(require,module,exports){
var Processor = require('./common').Processor;
var DataQuery = require('./query/DataQuery');
var Query = require('./query/Query');
var EverliveError = require('./EverliveError').EverliveError;

module.exports = (function () {
    return new Processor({
        executionNodeFunction: function (node, expandContext, done) {
            var query = new DataQuery({
                operation: DataQuery.operations.read,
                collectionName: node.targetTypeName,
                filter: new Query(node.filter, node.select, node.sort, node.skip, node.take)
            });

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        }
    });
}());

},{"./EverliveError":36,"./common":46,"./query/DataQuery":56,"./query/Query":57}],38:[function(require,module,exports){
module.exports = (function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function (operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}());
},{}],39:[function(require,module,exports){
module.exports = (function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}());
},{}],40:[function(require,module,exports){
var platform = require('./everlive.platform');
var isNativeScript = platform.isNativeScript;
var isNodejs = platform.isNodejs;
var constants = require('./constants');

module.exports = (function () {
    'use strict';

    function getLocalStorage(sdk) {
        if (isNativeScript) {
            var localSettings = require('application-settings');

            return {
                getItem: function (key) {
                    return localSettings.getString(key);
                },

                removeItem: function (key) {
                    return localSettings.remove(key);
                },

                setItem: function (key, value) {
                    return localSettings.setString(key, value);
                }
            };
        } else {
            var localStorage;
            if (isNodejs) {
                var LocalStorage = require('node-localstorage').LocalStorage;
                localStorage = new LocalStorage(sdk.offlineStorage.setup.storage.storagePath);
            } else {
                localStorage = window.localStorage;
            }

            return {
                getItem: function (key) {
                    return localStorage.getItem(key);
                },

                removeItem: function (key) {
                    return localStorage.removeItem(key);
                },

                setItem: function (key, value) {
                    return localStorage.setItem(key, value);
                }
            };
        }
    }

    function LocalStore(sdk) {
        this.sdk = sdk;
        this._localStorage = getLocalStorage(this.sdk);
    }

    LocalStore.prototype = {
        getItem: function (key) {
            return this._localStorage.getItem(key);
        },

        removeItem: function (key) {
            return this._localStorage.removeItem(key);
        },

        setItem: function (key, value) {
            return this._localStorage.setItem(key, value);
        }
    };

    return LocalStore;
}());
},{"./constants":47,"./everlive.platform":49,"application-settings":"application-settings","node-localstorage":"node-localstorage"}],41:[function(require,module,exports){
var utils = require('./utils');
var buildPromise = utils.buildPromise;
var DeviceRegistrationResult = utils.DeviceRegistrationResult;
var everliveErrorModule = require('./EverliveError');
var DeviceRegistrationError = everliveErrorModule.DeviceRegistrationError;
var EverliveError = everliveErrorModule.EverliveError;
var CurrentDevice = require('./CurrentDevice');
var Platform = require('./constants').Platform;

module.exports = (function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data('Push/Notifications');
        this.devices = el.data('Push/Devices');
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function () {
            var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);

            if (!isPushNotificationPluginAvailable) {
                throw new EverliveError("The push notification plugin is not available. Ensure that the pushNotification plugin is included " +
                "and use after `deviceready` event has been fired.");
            }
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function (emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }

            if (!window.cordova) {
                throw new EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
            }

            if (!this._currentDevice) {
                this._currentDevice = new CurrentDevice(this);
            }

            this._currentDevice.emulatorMode = emulatorMode;

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function (token, callback) {
                var result = new DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function (err, callback) {
                var registrationError = DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function (token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType(device.platform);
                var clearBadge = platformType === Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return buildPromise(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration()
                        .then(function () {
                            currentDevice.updateRegistration(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, function (err) {
                                errorCallback(err, errorCb);
                            });
                        }, function (err) {
                            if (err.code === 801) { //Not registered
                                currentDevice.register(customParameters, function () {
                                    clearBadgeIfNeeded(token, successCb, errorCb);
                                }, errorCb);
                            } else {
                                errorCallback(err, errorCb);
                            }
                        });
                }, function (err) {
                    var deviceRegistrationError = DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function (badge, onSuccess, onError) {
            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return buildPromise(function (success, error) {
                    error(new EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return buildPromise(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(
                    function () {
                        if (window.plugins && window.plugins.pushNotification) {
                            return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                        } else {
                            return successCb();
                        }
                    }, errorCb)
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function (notification, onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return buildPromise(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        }
    };

    return Push;
}());
},{"./CurrentDevice":34,"./EverliveError":36,"./constants":47,"./utils":66}],42:[function(require,module,exports){
var utils = require('./utils');
var rsvp = require('./common').rsvp;
var buildAuthHeader = utils.buildAuthHeader;
var parseUtilities = utils.parseUtilities;
var guardUnset = utils.guardUnset;
var common = require('./common');
var reqwest = common.reqwest;
var _ = common._;
var Headers = require('./constants').Headers;
var isNodejs = require('./everlive.platform').isNodejs;

module.exports = (function () {
    var _self;

    // The Request type is an abstraction over Ajax libraries
    // A Request object needs information about the Everlive connection and initialization options

    function Request(setup, options) {
        guardUnset(setup, 'setup');
        guardUnset(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;
        this.headers = {};
        // TODO success and error callbacks should be uniformed for all ajax libs
        this.success = null;
        this.error = null;
        this.parse = Request.parsers.simple;

        _.extend(this, options);
        _self = this;
        this._init(options);
    }

    Request.prototype = {
        // Calls the underlying Ajax library
        send: function () {
            Request.sendRequest(this);
        },
        // Returns an authorization header used by the request.
        // If there is a logged in user for the Everlive instance then her/his authentication will be used.
        buildAuthHeader: buildAuthHeader,
        // Builds the URL of the target Everlive service
        buildUrl: function buildUrl(setup) {
            return utils.buildUrl(setup);
        },
        // Processes the given query to return appropriate headers to be used by the request
        buildQueryHeaders: function buildQueryHeaders(query) {
            if (query) {
                if (query instanceof Everlive.Query) {
                    return Request.prototype._buildQueryHeaders(query);
                }
                else {
                    return Request.prototype._buildFilterHeader(query);
                }
            }
            else {
                return {};
            }
        },
        // Initialize the Request object by using the passed options
        _init: function (options) {
            _.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.filter), options.headers);
        },
        // Translates an Everlive.Query to request headers
        _buildQueryHeaders: function (query) {
            query = query.build();
            var headers = {};
            if (query.$where !== null) {
                headers[Headers.filter] = JSON.stringify(query.$where);
            }
            if (query.$select !== null) {
                headers[Headers.select] = JSON.stringify(query.$select);
            }
            if (query.$sort !== null) {
                headers[Headers.sort] = JSON.stringify(query.$sort);
            }
            if (query.$skip !== null) {
                headers[Headers.skip] = query.$skip;
            }
            if (query.$take !== null) {
                headers[Headers.take] = query.$take;
            }
            if (query.$expand !== null) {
                headers[Headers.expand] = JSON.stringify(query.$expand);
            }
            return headers;
        },
        // Creates a header from a simple filter
        _buildFilterHeader: function (filter) {
            var headers = {};
            headers[Headers.filter] = JSON.stringify(filter);
            return headers;
        }
    };

    var parseOnlyCompleteDateTimeString = _self && _self.setup && _self.setup.parseOnlyCompleteDateTimeObjects;

    var reviver = parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

    Request.parsers = {
        simple: {
            result: parseUtilities.parseResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        single: {
            result: parseUtilities.parseSingleResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        update: {
            result: parseUtilities.parseUpdateResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        }
    };

    // TODO built for request
    if (typeof Request.sendRequest === 'undefined') {
        Request.sendRequest = function (request) {
            var url = request.buildUrl(request.setup) + request.endpoint;
            url = Everlive.disableRequestCache(url, request.method);
            var data = request.method === 'GET' ? request.data : JSON.stringify(request.data);

            var requestParams = {
                url: url,
                method: request.method,
                data: data,
                headers: request.headers,
                contentType: 'application/json'
            };

            if (isNodejs) {
                requestParams.success = function (data, response) {
                    request.success.call(request, request.parse.result(data), response);
                };

                requestParams.error = function (jqXHR) {
                    request.error.call(request, request.parse.error(jqXHR.responseText || jqXHR.statusText));
                };
            } else {
                requestParams.type = 'json';
                requestParams.crossOrigin = true;
                requestParams.success = function (data, textStatus, jqXHR) {
                    var result = request.parse.result(data);
                    request.success.call(request, result);
                };

                requestParams.error = function (jqXHR, textStatus, errorThrown) {
                    var error = request.parse.error(jqXHR.responseText || jqXHR.statusText);
                    request.error.call(request, error);
                };
            }

            reqwest(requestParams);
        };
    }

    return Request;
}());
},{"./common":46,"./constants":47,"./everlive.platform":49,"./utils":66}],43:[function(require,module,exports){
var _ = require('./common')._;
var constants = require('./constants');
var AuthenticationSetup = require('./auth/AuthenticationSetup');

module.exports = (function () {
    var everliveUrl = constants.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.apiKey = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.principalId = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;
        if (typeof options === 'string') {
            this.apiKey = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _.extend(this, options);
        }

        this.authentication = new AuthenticationSetup(this, options.authentication);
    }

    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
        this.token = token;
        this.tokenType = tokenType;
        this.principalId = principalId;
    };

    Setup.prototype.getAuthorizationProperties = function () {
        return {
            token: this.token,
            tokenType: this.tokenType,
            principalId: this.principalId
        };
    };

    return Setup;

}());
},{"./auth/AuthenticationSetup":45,"./common":46,"./constants":47}],44:[function(require,module,exports){
'use strict';
var utils = require('../utils');
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var Everlive = require('../Everlive');
var constants = require('../constants');
var usersCollectionName = 'Users';
var buildPromise = utils.buildPromise;
var LocalStore = require('../LocalStore');
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports = (function () {
    /**
     * @class Authentication
     * @classdesc A class for managing authentication of a user in your application.
     * @protected
     * @param el {Everlive} Everlive Object
     * @param setup {AuthSetup} the authentication setup object
     */
    var Authentication = function (el, setup) {
        this.authSetup = setup || {};
        this._el = el;
        this._authenticationCallbacks = null;
        this._localStore = new LocalStore(el);
        if (this.authSetup.persist) {
            var self = this;
            var localStoreKey = this._getLocalStoreKey();
            var authOptions = this._localStore.getItem(localStoreKey);
            var authInfo;
            if (authOptions) {
                authInfo = JSON.parse(this._localStore.getItem(localStoreKey));
            }
            if (authInfo) {
                self._el.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
            }
        }
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.login = function (username, password, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogin,
                collectionName: usersCollectionName,
                data: {
                    username: username,
                    password: password,
                    grant_type: 'password'
                },
                skipAuth: true,
                onSuccess: successFunc,
                onError: error
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.logout = function (success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._logoutSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var errorFunc = function (err) {
                if (err.code === 301) { //invalid token
                    self.clearAuthorization();
                }

                error.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogout,
                collectionName: usersCollectionName,
                skipAuth: true,
                onSuccess: successFunc,
                onError: errorFunc
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    Authentication.prototype._getLocalStoreKey = function () {
        return constants.AuthStoreKey + this._el.setup.apiKey + '$authentication';
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithFacebook = function (accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithADFS = function (accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithLiveID = function (accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithGoogle = function (accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Authentication.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    Authentication.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this._el.setup.setAuthorizationProperties(token, tokenType, principalId);

        if (this.authSetup.persist) {
            var localStoreKey = this._getLocalStoreKey();
            var authorizationProperties = this._el.setup.getAuthorizationProperties();
            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
        }

        if (this._authenticationCallbacks) {
            this._authenticationCallbacks.success();
            this._authenticationCallbacks = null;
        }
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
     * @method clearAuthorization
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null, null);
        this.clearPersistedAuthentication();
    };

    /**
     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
     * @method clearPersistedAuthentication
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearPersistedAuthentication = function () {
        if (this._localStore) {
            var localStoreKey = this._getLocalStoreKey();
            this._localStore.removeItem(localStoreKey);
        }
    };

    /**
     * @memberOf Authentication.prototype
     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
     * @returns {boolean} whether an onAuthenticationRequired function is provided
     */
    Authentication.prototype.isAuthenticationInProgress = function () {
        return typeof this.authSetup.onAuthenticationRequired === 'function';
    };

    /** Ensures that authentication is completed before continuing.
     * @memberOf Authentication.prototype
     * @private
     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
     * @throws throws an error if no onAuthenticationRequired handler is provided to the setup.
     */
    Authentication.prototype._ensureAuthentication = function () {
        if (!this.isAuthenticationInProgress()) {
            throw new Error('onAuthenticationRequired option of Everlive.Setup.Authentication is required.');
        }
        if (this.isAuthenticating()) {
            return this._authenticationCallbacks.promise;
        }
        this.clearAuthorization();
        this.authSetup.onAuthenticationRequired.call(this);
        this._authenticationCallbacks = utils.getCallbacks();
        return this._authenticationCallbacks.promise;
    };

    /**
     * A method that should be called with the authentication result.
     * @memberOf Authentication.prototype
     * @param authentication authentication object containing information about the
     * @param authentication.access_token
     * @param authentication.token_type
     * @param authentication.principal_id
     */
    Authentication.prototype.completeAuthentication = function (authentication) {
        this._el.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
    };
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.getAuthenticationStatus = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self._el.setup;
            if (setup.masterKey) {
                return success({status: constants.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: constants.AuthStatus.unauthenticated});
            }

            if (self.isAuthenticationInProgress()) {
                return success({status: constants.AuthStatus.authenticating});
            }

            self._el.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: constants.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.isAuthenticationInProgress()) {
                        return success({status: constants.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.invalidToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: constants.AuthStatus.invalidAuthentication});
                    } else if (err.code === EverliveErrors.expiredToken.code) {
                        return success({status: constants.AuthStatus.expiredAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
     * @memberOf Everlive.prototype
     * @returns {boolean}
     */
    Authentication.prototype.isAuthenticating = function () {
        return !!this._authenticationCallbacks;
    };

    Authentication.prototype._loginSuccess = function (data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
    };

    Authentication.prototype._logoutSuccess = function () {
        this.clearAuthorization();
    };

    Authentication.prototype._loginWithProvider = function (identity, success, error) {
        var user = {
            Identity: identity
        };
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLoginWithProvider,
                collectionName: usersCollectionName,
                data: user,
                authHeaders: false,
                skipAuth: true,
                parse: Request.parsers.single,
                onSuccess: successFunc,
                onError: error
            });

            self._el.Users.processDataQuery(query);
        }, success, error);
    };

    return Authentication;
}());

},{"../Everlive":35,"../EverliveError":36,"../LocalStore":40,"../Request":42,"../constants":47,"../query/DataQuery":56,"../utils":66}],45:[function(require,module,exports){
'use strict';
var AuthenticationSetup = function (everlive, options) {
    options = options || {};
    this.onAuthenticationRequired = options.onAuthenticationRequired;
    this.persist = options.persist;
};

module.exports = AuthenticationSetup;
},{}],46:[function(require,module,exports){
(function (global){
module.exports = (function () {
    var common = {};

    var platform = require('./everlive.platform');
    var isNativeScript = platform.isNativeScript;
    var isNodejs = platform.isNodejs;

    if (!isNodejs && !isNativeScript) {
        common.reqwest = require('reqwest');
    } else if (isNativeScript) {
        common.root = global;
        common.reqwest = require('./reqwest.nativescript');
    } else if (isNodejs) {
        common.root = global;
        common.reqwest = require('./reqwest.nodejs');
    }

    if (!common.root) {
        //browser/requirejs/cordova
        common.root = window;
    }

    var ensureDependency = function ensureDependency(globalName, localName) {
        if (!localName) {
            localName = globalName;
        }

        if (!Object.keys(common[localName]).length) {
            common[localName] = common.root[globalName];
        }
    };

    //for the everlive bundle without dependencies included browserify replaces them with empty objects
    common._ = require('underscore');
    ensureDependency('_');

    common.jstz = require('jstimezonedetect').jstz;
    ensureDependency('jstz');

    common.mongoQuery = require('mongo-query');
    ensureDependency('mongoQuery');

    common.Mingo = require('mingo');
    ensureDependency('Mingo');

    common.uuid = require('uuid');
    ensureDependency('uuid');

    common.Processor = require('../scripts/bs-expand-processor');
    ensureDependency('Processor');

    common.rsvp = require('rsvp');
    ensureDependency('RSVP', 'rsvp');

    if (!isNodejs && !isNativeScript) {
        ensureDependency('reqwest');
    }

    return common;
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../scripts/bs-expand-processor":30,"./everlive.platform":49,"./reqwest.nativescript":61,"./reqwest.nodejs":62,"jstimezonedetect":1,"mingo":1,"mongo-query":8,"reqwest":1,"rsvp":1,"underscore":1,"uuid":1}],47:[function(require,module,exports){
var constants = {
    idField: 'Id',
    guidEmpty: '00000000-0000-0000-0000-000000000000',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.StorageProvider
     */
    StorageProvider: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },

    DefaultStoragePath: 'el_store/',

    EncryptionProvider: {
        Default: 'default',
        Custom: 'custom'
    },
    // The headers used by the Everlive services
    Headers: {
        filter: 'X-Everlive-Filter',
        select: 'X-Everlive-Fields',
        sort: 'X-Everlive-Sort',
        skip: 'X-Everlive-Skip',
        take: 'X-Everlive-Take',
        expand: 'X-Everlive-Expand',
        singleField: 'X-Everlive-Single-Field',
        includeCount: 'X-Everlive-Include-Count',
        powerFields: 'X-Everlive-Power-Fields',
        debug: 'X-Everlive-Debug',
        overrideSystemFields: 'X-Everlive-Override-System-Fields'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @property {string} expiredAuthentication Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated',
        expiredAuthentication: 'expiredAuthentication',
        authenticating: 'authenticating'
    },
    offlineItemStates: {
        created: 'created',
        modified: 'modified',
        deleted: 'deleted'
    },

    /**
     * HTTP Methods
     * @enum {string}
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

constants.SyncErrors = {
    generalError: 'generalError',
    itemSyncError: 'itemSyncError'
};

constants.syncBatchSize = 10;

constants.AuthStoreKey = '__everlive_auth_key';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes

module.exports = constants;
},{}],48:[function(require,module,exports){
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var AES = CryptoJS.AES;

module.exports = (function () {

    function CryptographicProvider (sdk) {
        this.sdk = sdk;
    }

    CryptographicProvider.prototype = {
        _getKey: function () {
            return this.sdk.offlineStorage.setup.encryption.key;
        },

        _canEncryptDecrypt: function (content) {
            return this._getKey() && content !== null && content !== undefined;
        },

        encrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.encrypt(content, this._getKey()).toString();
        },

        decrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.decrypt(content, this._getKey()).toString(CryptoJS.enc.Utf8);
        }
    };

    return CryptographicProvider;
}());
},{"node-cryptojs-aes":19}],49:[function(require,module,exports){
(function (global){
var isNativeScriptApplication = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
    || (typeof UIButton !== 'undefined' && UIButton)));

if (isNativeScriptApplication) {
    global.isNativeScriptApplication = isNativeScriptApplication;
    global.isCordovaApplication = false;

    global.window = {
            localStorage: {
                removeItem: function () { } //shim for mongo-query under nativescript
            }
        };
} else if (typeof window !== 'undefined') {
    var isCordovaApplication = /^file:\/{3}[^\/]/i.test(window.location.href) && /ios|iphone|ipod|ipad|android/i.test(navigator.userAgent);
}

var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;

module.exports = {
    isCordova: isCordovaApplication,
    isNativeScript: isNativeScriptApplication,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],50:[function(require,module,exports){
/*!
 The MIT License (MIT)
 Copyright (c) 2013 Telerik AD
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.y distributed under the MIT license.
 */
/*!
 Everlive SDK
 Version 1.3.0
 */
(function () {
    var Everlive = require('./Everlive');
    var platform = require('./everlive.platform');
    var common = require('./common');
    common.root.Everlive = Everlive;

    if (!platform.isNativeScript && !platform.isNodejs) {
        var kendo = require('./kendo/kendo.everlive');
        Everlive.createDataSource = kendo.createDataSource;
        Everlive.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    Everlive.PushCallbacks = {};
    Everlive.Offline = {};

    Everlive.Query = require('./query/Query');
    Everlive.QueryBuilder = require('./query/QueryBuilder');
    Everlive.GeoPoint = require('./GeoPoint');
    Everlive.Constants = require('./constants');
    Everlive.Request = require('./Request');
    Everlive.Data = require('./types/Data');
    Everlive._utils = require('./utils');
    Everlive._traverseAndRevive = Everlive._utils.parseUtilities.traverseAndRevive;
    Everlive._common = require('./common');

    var persistersModule = require('./offline/offlinePersisters');
    Everlive.persister = {
        LocalStorage: persistersModule.LocalStoragePersister,
        FileSystem: persistersModule.FileSystemPersister
    };

    if (typeof exports === 'object') {
        module.exports = common.root.Everlive;
    }
}());
},{"./Everlive":35,"./GeoPoint":39,"./Request":42,"./common":46,"./constants":47,"./everlive.platform":49,"./kendo/kendo.everlive":51,"./offline/offlinePersisters":54,"./query/Query":57,"./query/QueryBuilder":58,"./types/Data":63,"./utils":66}],51:[function(require,module,exports){
var QueryBuilder = require('../query/QueryBuilder');
var Query = require('../query/Query');
var Request = require('../Request');
var constants = require('../constants');
var _ = require('../common')._;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;

(function () {
    if (typeof window !== 'undefined' && typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined') {
        return;
    }

    var $ = window.jQuery;
    var kendo = window.kendo;

    var extend = $.extend;

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function (options) {
            this.everlive$ = options.dataProvider || Everlive.$;
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },

        read: function (options) {
            var methodOption = this.options['read'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var query = translateKendoQuery(options.data);
            var everliveQuery = new Query(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;

            if (id) {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery).then(options.success, options.error);
            }
        },

        update: function (options) {
            var methodOption = this.options['update'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate)
                    .then(options.success.bind(this, itemForUpdate), options.error);
            }
        },

        create: function (options) {
            var methodOption = this.options['create'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData)
                .then(options.success.bind(this, createData), options.error);
        },

        destroy: function (options) {
            var methodOption = this.options['destroy'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }
            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroy(options.data)
                .then(options.success, options.error);
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: function (data) {
                    return data.hasOwnProperty('count') ? data.count : data.Count;
                },
                data: function (data) {
                    return data.result || Everlive._traverseAndRevive(data.Result) || data;
                },
                model: {
                    id: constants.idField
                }
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                var filter = filterBuilder.build(data.filter);
                result.$where = filter;
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function (filter) {
            return filterBuilder._build(filter);
        },
        _build: function (filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            }
            else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            }
            else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            }
            else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            }
            else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function (filter) {
            return filter.operator === '_raw';
        },
        _raw: function (filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function (filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function (filter) {
            var term = {}, fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            }
            else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function (filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function (filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function (filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith': // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + "$", "i");
            }
            throw new Error("Unknown operator type.");
        },
        _getRegexValue: function (regex) {
            return QueryBuilder.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function (filter) {
            return filter.logic === 'and';
        },
        _and: function (filter) {
            var i, l, term, result = {};
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result = filterBuilder._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            return QueryBuilder.prototype._andAppend.call(this, andObj, newObj);
        },
        _isOr: function (filter) {
            return filter.logic === 'or';
        },
        _or: function (filter) {
            var i, l, term, result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return "$ne";
                case 'gt':
                    return "$gt";
                case 'lt':
                    return "$lt";
                case 'gte':
                    return "$gte";
                case 'lte':
                    return "$lte";
            }
            throw new Error("Unknown operator type.");
        }
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo scripts is required*.
     * @param options data source options. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @param options.transport.typeName the content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
     *   transport: {
     *     typeName: 'Books'
     *   }
     * });
     * ```
     */
    var createDataSource = function (options) {
        options = options || {};
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a kendo DataSource.");
        }

        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo DataSource.");
        }

        return everlive$.getKendoDataSource(typeName, options);
    };

    /**
     * Creates a new [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo scripts is required*.
     * @param options data source options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand an array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - an object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - an object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - a number specifying the skip value.
     * @param {object} ExpandDefinition.take - a number specifying the take value.
     * @param {object} ExpandDefinition.fields - an object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource)
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
     *   "typeName": "Continents",
     *   "expand": ["Countries", "Towns"]
     * });
     *
     * ...
     * ("#treeview").kendoTreeView({
     *   dataSource: continents,
     *   dataTextField: ["ContinentName", "CountryName", "TownName"]
     * });
     * ```
     */
    var createHierarchicalDataSource = function (options) {
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a kendo DataSource.");
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo DataSource.");
        }
        return everlive$.getHierarchicalDataSource(typeName, options);

    };

    Everlive.prototype.getKendoDataSource = function (typeName, datasourceOptions) {
        datasourceOptions = _.extend({}, datasourceOptions);
        if (datasourceOptions.hasOwnProperty('serverGrouping') && datasourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }

        var defaultEverliveOptions = {
            type: 'everlive',
            transport: {
                typeName: typeName,
                dataProvider: this
            }
        };

        var options = _.defaults(defaultEverliveOptions, datasourceOptions);
        return new kendo.data.DataSource(options);
    };


    var getUrlGeneratorForNode = function (baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return (function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {//if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            }
        }(pathUrl, expandField));
    }

    var getHeadersForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return {};
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            }
        }
    };

    var getRelationFieldForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    Everlive.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
        dataSourceOptions = dataSourceOptions || {};
        if (dataSourceOptions.hasOwnProperty('serverGrouping') && dataSourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }
        var expand = dataSourceOptions.expand || dataSourceOptions;
        delete dataSourceOptions.expand;
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo HierarchicalDataSource.");
        }
        if (!$.isArray(expand)) {
            throw new Error("You need to set 'expand' array option in order to create a kendo HierarchicalDataSource");
        }
        var baseUrl = this.buildUrl() + typeName;

        var expandSchema;
        var isOfflineStorageEnabled = this._isOfflineStorageEnabled();
        for (var i = expand.length - 1; i >= 0; i--) { //recursively build the hierarchical data source
            var expandNode = expand[i];
            if (isOfflineStorageEnabled) {
                if (!$.isPlainObject(expandNode)) {
                    throw new Error("When offline is enabled, each member of the expand array option must be an object. (Expand node index: " + i + ")");
                }
                if (!expandNode.relation) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: " + i + ")");
                }
                if (!expandNode.typeName) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: " + i + ")");
                }

                var headers;
                var expandExpression = {};
                expandExpression[expandNode.relation] = {
                    TargetTypeName: expandNode.typeName,
                    Filter: expandNode.filter,
                    Sort: expandNode.sort,
                    Take: expandNode.take,
                    Skip: expandNode.skip,
                    Fields: expandNode.fields,
                    SingleField: expandNode.singleField
                };
                headers = {
                    'X-Everlive-Expand': JSON.stringify(expandExpression),
                    'X-Everlive-Single-Field': expandNode.relation
                };
                var parentType;
                if (i === 0) {
                    parentType = typeName;
                } else {
                    parentType = expand[i - 1].typeName;
                }
                expandSchema = {
                    model: {
                        hasChildren: expandNode.relation,
                        children: {
                            type: "everlive",
                            transport: {
                                typeName: parentType,
                                read: {
                                    headers: headers
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            } else {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expandNode),
                        children: {
                            type: "everlive",
                            transport: {
                                read: {
                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
                                    headers: getHeadersForExpandNode(expandNode)
                                }
                            },
                            schema: expandSchema
                        }
                    }
                }
            }
        }
        var options = {};
        options.type = 'everlive';
        options.transport = {
            typeName: typeName,
            dataProvider: this
        };
        options.schema = expandSchema;
        if ($.isPlainObject(dataSourceOptions)) {
            extend(true, options, dataSourceOptions);
        }
        return new kendo.data.HierarchicalDataSource(options);
    };


    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
}());
},{"../Everlive":35,"../EverliveError":36,"../Request":42,"../common":46,"../constants":47,"../query/Query":57,"../query/QueryBuilder":58}],52:[function(require,module,exports){
var DataQuery = require('../query/DataQuery');
var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;
var constants = require('../constants');
var offlineItemStates = constants.offlineItemStates;
var Headers = constants.Headers;
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var mingo = common.Mingo;
var mongoQuery = common.mongoQuery;
var uuid = common.uuid;
var utils = require('../utils');
var Request = require('../Request');
var expandProcessor = require('../ExpandProcessor');
var offlineTransformations = require('./offlineTransformations');
var buildPromise = require('../utils').buildPromise;

/**
 * @class OfflineModule
 * @classDesc A class providing access to some offline storage functionalities.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} storage
 */

module.exports = (function () {
    function OfflineModule(everlive, options, persister, encryptionProvider) {
        this.everlive = everlive;
        this.setup = options;
        this._persister = persister;
        this._encryptionProvider = encryptionProvider;
        this._isSynchronizing = false;
        this._collectionCache = {};
    }


    var getSyncFilterForItem = function (item) {
        var filter = getSyncFilterNoModifiedAt(item);
        filter.ModifiedAt = item.ModifiedAt;
        return filter;
    };

    var getSyncFilterNoModifiedAt = function (item) {
        return {
            Id: item.Id
        }
    };

    function buildUsersErrorMessage(dataQuery) {
        var operation = dataQuery.operation;
        if (operation === DataQuery.operations.userLoginWithProvider ||
            operation === DataQuery.operations.userLinkWithProvider ||
            operation === DataQuery.operations.userUnlinkFromProvider) {
            operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
        }

        return 'The Users operation ' + operation + ' is not supported in offline mode';
    }

    var unsupportedUsersOperations = {};
    unsupportedUsersOperations[DataQuery.operations.create] = true;
    unsupportedUsersOperations[DataQuery.operations.update] = true;
    unsupportedUsersOperations[DataQuery.operations.remove] = true;
    unsupportedUsersOperations[DataQuery.operations.removeSingle] = true;
    unsupportedUsersOperations[DataQuery.operations.rawUpdate] = true;
    unsupportedUsersOperations[DataQuery.operations.setAcl] = true;
    unsupportedUsersOperations[DataQuery.operations.setOwner] = true;
    unsupportedUsersOperations[DataQuery.operations.userLoginWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLinkWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userUnlinkFromProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogin] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogout] = true;
    unsupportedUsersOperations[DataQuery.operations.userChangePassword] = true;

    var unsupportedOfflineHeaders = [Headers.powerFields];

    OfflineModule.prototype = {
        /**
         * Removes all data from the offline storage
         * @memberOf OfflineModule.prototype
         * @param {function} success
         * @param {function} error
         */
        /**
         * Removes all data from the offline storage
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        purgeAll: function (success, error) {
            var self = this;
            this._collectionCache = {};
            return buildPromise(function (success, error) {
                self._persister.purgeAll(success, error);
            }, success, error);
        },

        /**
         * Removes all data for a specific content type from the offline storage
         * @memberOf OfflineStorageModule.prototype
         * @param {string} contentType The content type to purge
         * @param success
         * @param error
         */
        /**
         * Removes all data for a specific content type from the offline storage
         * @memberOf OfflineStorageModule.prototype
         * @param {string} contentType The content type to purge
         * @returns Promise
         */
        purge: function (contentType, success, error) {
            var self = this;
            return buildPromise(function (success, error) {
                self._persister.purge(contentType, success, error);
            }, success, error);
        },

        processQuery: function (dataQuery) {
            var unsupportedClientOpMessage = this.getUnsupportedClientOpMessage(dataQuery);
            if (unsupportedClientOpMessage && !dataQuery.isSync) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(new EverliveError(unsupportedClientOpMessage));
                });
            }

            var sort = dataQuery.getHeaderAsJSON(Headers.sort);
            var limit = dataQuery.getHeaderAsJSON(Headers.take);
            var skip = dataQuery.getHeaderAsJSON(Headers.skip);
            var select = dataQuery.getHeaderAsJSON(Headers.select);
            var filter = dataQuery.getHeaderAsJSON(Headers.filter);
            var expand = dataQuery.getHeaderAsJSON(Headers.expand);

            if (dataQuery.filter instanceof Everlive.Query) {
                var filterObj = dataQuery.filter.build();
                filter = filterObj.$where || filter;
                sort = filterObj.$sort || sort;
                limit = filterObj.$take || limit;
                skip = filterObj.$skip || skip;
                select = filterObj.$select || select;
                expand = filterObj.$expand || expand;
            } else {
                filter = dataQuery.filter || filter;
            }

            if (!filter) {
                filter = {};
            }

            var unsupportedOperators = utils.getUnsupportedOperators(filter);
            var unsupportedOperatorCount = unsupportedOperators.length;
            if (unsupportedOperatorCount) {
                return new rsvp.Promise(function (resolve, reject) {
                    var errorMessage;
                    if (unsupportedOperatorCount === 1) {
                        errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                    } else {
                        errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                    }

                    reject(new EverliveError(errorMessage));
                });
            }

            offlineTransformations.traverseAndTransformFilterId(filter);

            switch (dataQuery.operation) {
                case DataQuery.operations.read:
                    return this.read(dataQuery, filter, sort, skip, limit, select, expand);
                case DataQuery.operations.readById:
                    return this.readById(dataQuery, expand);
                case DataQuery.operations.count:
                    return this.count(dataQuery, filter);
                case DataQuery.operations.create:
                    return this.create(dataQuery);
                case DataQuery.operations.rawUpdate:
                case DataQuery.operations.update:
                    return this.update(dataQuery, filter);
                case DataQuery.operations.remove:
                    return this.remove(dataQuery, filter);
                case DataQuery.operations.removeSingle:
                    filter._id = dataQuery.additionalOptions.id;
                    return this.remove(dataQuery, filter);
                default:
                    return new rsvp.Promise(function (resolve, reject) {
                        if (dataQuery.isSync) {
                            resolve();
                        } else {
                            reject(new EverliveError(dataQuery.operation + ' is not supported in offline mode'));
                        }
                    });
            }
        },

        getUnsupportedClientOpMessage: function (dataQuery) {
            for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
                var header = unsupportedOfflineHeaders[i];
                if (dataQuery.getHeader(header)) {
                    return 'The header ' + header + ' is not supported in offline mode';
                }
            }

            if (dataQuery.collectionName.toLowerCase() === 'files') {
                return 'Operations on files are not supported in offline mode';
            }

            if (dataQuery.collectionName.toLowerCase() === 'users' && unsupportedUsersOperations[dataQuery.operation]) {
                return buildUsersErrorMessage(dataQuery);
            }
        },

        _getEncryptionProvider: function () {
            return this._encryptionProvider;
        },

        _getCreateResult: function (createdItems) {
            if (createdItems.length === 1) {
                return {
                    result: {
                        CreatedAt: utils.cloneDate(createdItems[0].CreatedAt),
                        Id: createdItems[0]._id
                    }
                }
            } else {
                var multipleCreateResult = [];
                _.each(createdItems, function (createdItem) {
                    multipleCreateResult.push({
                        CreatedAt: utils.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    });
                });

                return {
                    result: multipleCreateResult
                }
            }
        },

        create: function (dataQuery) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState, function (createdItems) {
                    var createResult = self._getCreateResult(createdItems);
                    resolve(createResult);
                }, reject);
            });
        },

        read: function (dataQuery, filter, sort, skip, limit, select, expand) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var collectionLength;

                self._prepareExpand(expand, dataQuery, true)
                    .then(function (prepareExpandResult) {
                        if (prepareExpandResult) {
                            select = prepareExpandResult.mainQueryFieldsExpression;
                        }

                        return self._getCollection(dataQuery.collectionName)
                            .then(function (collection) {
                                var result = self._readInternal(collection, filter, sort, skip, limit, select);

                                if (skip || limit) {
                                    var all = self._readInternal(collection);
                                    collectionLength = all.length;
                                }

                                if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
                                    result = offlineTransformations.removeIdTransform(result, true);
                                } else {
                                    result = offlineTransformations.idTransform(result);
                                }

                                return self._expandResult(prepareExpandResult, result);
                            });
                    })
                    .then(function (result) {
                        var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                        resolve(response);
                    })
                    .catch(reject);
            });
        },

        _readInternal: function (collection, filter, sort, skip, limit, select) {
            var filterCopy = _.extend({}, filter);
            var actualFilter = this._getWithoutDeletedFilter(filterCopy);
            offlineTransformations.traverseAndTransformFilterId(actualFilter);
            var query = mingo.Query(actualFilter);
            var cursor = mingo.Cursor(collection, query, select);
            if (sort) {
                cursor = cursor.sort(sort);
            }

            if (skip) {
                cursor.skip(skip);
            }

            if (limit) {
                cursor.limit(limit);
            }

            return _.map(cursor.all(), function (item) {
                return _.extend({}, item);
            });
        },

        readById: function (dataQuery, expand) {
            var self = this;

            return self._prepareExpand(expand, dataQuery, false)
                .then(function (prepareExpandResult) {
                    return self._getCollection(dataQuery.collectionName)
                        .then(function (collection) {
                            return new rsvp.Promise(function (resolve, reject) {
                                var item = self._getById(collection, dataQuery.additionalOptions.id);

                                if (!item) {
                                    return reject(EverliveErrors.itemNotFound);
                                }

                                item = offlineTransformations.idTransform(item);
                                return self._expandResult(prepareExpandResult, item).then(resolve).catch(reject);
                            });
                        });
                })
                .then(function (result) {
                    var response = self._transformOfflineResult(result, null, dataQuery);
                    return response;
                });
        },

        _prepareExpand: function (expand, dataQuery, isArray) {
            return new rsvp.Promise(function (resolve, reject) {
                if (expand) {
                    expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                        if (err) {
                            if (err.name === 'ExpandError') {
                                err.code = EverliveErrors.invalidExpandExpression.code;
                            }
                            return reject(err);
                        }
                        resolve(prepareResult);
                    });
                } else {
                    resolve();
                }
            });
        },

        _expandResult: function (prepareExpandResult, result) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                if (prepareExpandResult) {
                    expandProcessor.expand(prepareExpandResult.relationsTree, result, {
                        offlineModule: self
                    }, function (err, result) {
                        if (err) {
                            if (err.name === 'ExpandError') {
                                err.code = EverliveErrors.invalidExpandExpression.code;
                            }
                            return reject(err);
                        }
                        resolve(result);
                    });
                } else {
                    resolve(result);
                }
            })
        },

        _getWithoutDeletedFilter: function (filter) {
            var withoutDeletedFilter = {
                $and: []
            };
            withoutDeletedFilter.$and.push(filter);
            var deleteOfflineFilter = {};
            deleteOfflineFilter[constants.offlineItemsStateMarker] = {$ne: offlineItemStates.deleted};
            withoutDeletedFilter.$and.push(deleteOfflineFilter);
            return withoutDeletedFilter;
        },

        update: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync, resolve, reject);
            });
        },

        remove: function (dataQuery, filter) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                self._removeItems(dataQuery, filter, dataQuery.isSync, resolve, reject);
            });
        },

        count: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._getCollection(dataQuery.collectionName)
                    .then(function (collection) {
                        var filterResult = self._readInternal(collection, filter);
                        resolve({result: filterResult.length});
                    }).catch(reject);
            });
        },

        _setOffline: function (offline) {
            this.setup.offline = offline;
        },

        isOnline: function () {
            return !this.setup.offline;
        },

        _prepareSyncData: function (contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _.each(contentTypesForSync, function (contentType, typeName) {
                var syncItems = offlineTransformations.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function (syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts)
                .then(self._mergeResolvedConflicts.bind(self, syncData.conflicts, syncData.contentTypesSyncData))
                .then(function () {
                    return syncData.contentTypesSyncData;
                });
        },

        isSynchronizing: function () {
            return this._isSynchronizing;
        },

        _fireSyncStart: function () {
            var self = this;

            return new rsvp.Promise(function (resolve) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self.everlive._emitter.emit('syncStart');
                    resolve();
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function () {
            var self = this;

            this._isSynchronizing = false;
            _.each(this._syncResultInfo.syncedItems, function (syncedItems, contentTypeName) {
                self._syncResultInfo.syncedToServer += _.where(syncedItems, {storage: 'server'}).length;
                self._syncResultInfo.syncedToClient += _.where(syncedItems, {storage: 'client'}).length;
            });

            this.everlive._emitter.emit('syncEnd', this._syncResultInfo);
            delete this._syncResultInfo;
        },

        _eachSyncItem: function (items, getFilterFunction, contentTypeName, operation) {
            var self = this;

            _.each(items, function (item) {
                var itemFilter = getFilterFunction(item.remoteItem);
                // if we already have an error for this item we do not want to try and sync it again
                var resultItem = item.resultingItem;
                if (_.some(self._syncResultInfo.failedItems[contentTypeName], {itemId: resultItem.Id})) {
                    return;
                }

                operation(resultItem, itemFilter);
            });
        },

        _addCreatedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            var resultingItemsForCreate = _.pluck(contentTypeData.createdItems, 'resultingItem');
            var ids;
            if (!this._shouldAutogenerateIdForContentType(dataCollection.collectionName)) {
                ids = _.pluck(resultingItemsForCreate, 'Id');
                resultingItemsForCreate = offlineTransformations.removeIdTransform(resultingItemsForCreate);
            }

            syncPromises['create'] =
                new rsvp.Promise(function (resolve, reject) {
                    dataCollection
                        .isSync(true)
                        .applyOffline(false)
                        .create(resultingItemsForCreate)
                        .then(function (res) {
                            resultingItemsForCreate = _.map(resultingItemsForCreate, function (item, index) {
                                item.Id = res.result[index].Id;
                                item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
                                return item;
                            });

                            return dataCollection
                                .isSync(true)
                                .useOffline(true)
                                .create(resultingItemsForCreate)
                                .then(function () {
                                    var collectionName = dataCollection.collectionName;
                                    _.each(resultingItemsForCreate, function (createdItem) {
                                        self._addItemSynced(createdItem, collectionName, 'server', 'create');
                                    });

                                    if (ids && ids.length) {
                                        var filter = {Id: {$in: ids}};
                                        return dataCollection
                                            .isSync(true)
                                            .useOffline(true)
                                            .destroy(filter).catch(function (err) {
                                                reject({
                                                    type: 'create',
                                                    items: resultingItemsForCreate,
                                                    contentType: dataCollection.collectionName,
                                                    error: err,
                                                    storage: 'client'
                                                })
                                            });
                                    }
                                }, function (err) {
                                    reject({
                                        type: 'create',
                                        items: resultingItemsForCreate,
                                        contentType: dataCollection.collectionName,
                                        error: err,
                                        storage: 'client'
                                    })
                                });
                        }, function (err) {
                            reject({
                                type: 'create',
                                items: resultingItemsForCreate,
                                contentType: dataCollection.collectionName,
                                error: err,
                                storage: 'server'
                            })
                        })
                        .then(resolve)
                        .catch(function (err) {
                            reject({
                                type: 'create',
                                items: resultingItemsForCreate,
                                contentType: dataCollection.collectionName,
                                error: err
                            });
                        });
                });
        },

        _addUpdatedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
            var self = this;
            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
        },

        _addDeletedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
            var self = this;

            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
        },

        _onSyncResponse: function (res, item, collectionName, operation) {
            var self = this;

            if (res.result !== 1) {
                return new rsvp.Promise(function (resolve, reject) {
                    self._removeItemSynced(item, collectionName);
                    reject(_.extend({}, EverliveErrors.syncConflict, {
                        contentType: collectionName
                    }));
                });
            } else {
                if (operation === DataQuery.operations.update) {
                    self._addItemSynced(item, collectionName, 'server', 'update');
                    var updatedItem = _.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    var updateQuery = new DataQuery({
                        operation: operation,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        collectionName: collectionName,
                        isSync: true
                    });

                    return this.processQuery(updateQuery);
                } else if (operation === DataQuery.operations.remove) {
                    self._addItemSynced(item, collectionName, 'server', 'delete');
                    return this._purgeById(collectionName, item.Id);
                }
            }
        },

        _purgeById: function (contentType, itemId) {
            var self = this;

            return self._getCollection(contentType)
                .then(function (collection) {
                    delete collection[itemId];
                    return self._persistData(contentType);
                });
        },

        sync: function () {
            var self = this;
            self._syncResultInfo = self._syncResultInfo || {
                syncedItems: {},
                syncedToServer: 0,
                syncedToClient: 0,
                failedItems: {},
                error: undefined // added for visibility
            };

            if (!this.isOnline()) {
                throw new EverliveError('Cannot synchronize while offline');
            }

            self._fireSyncStart()
                .then(self._applySync.bind(self))
                .then(function (syncResults) {
                    var conflictsWhileSync = [];
                    _.each(syncResults, function (syncResult, itemId) {
                        if (syncResult && syncResult.state === 'rejected') {
                            var targetType = syncResult.reason.contentType;
                            if (syncResult.reason && syncResult.reason.code === EverliveErrors.syncConflict.code) {
                                conflictsWhileSync.push(syncResult);
                            } else {
                                // to save time and traffic we are using a single create request for all items
                                // this is why if there is an error we need to split the items we tried to create
                                // and set the same error for all items.
                                var type = syncResult.reason.type;
                                self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
                                if (type === 'create') {
                                    _.each(syncResult.reason.items, function (item) {
                                        self._removeItemSynced(item, targetType, 'server', 'create');
                                        self._syncResultInfo.failedItems[targetType]
                                            .push(_.extend({itemId: item.Id}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                    });
                                } else {
                                    self._removeItemSynced(itemId, targetType, 'server');
                                    self._syncResultInfo.failedItems[targetType]
                                        .push(_.extend({itemId: itemId}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                }
                            }
                        }
                    });

                    if (conflictsWhileSync.length) {
                        return self.sync();
                    } else {
                        self._fireSyncEnd();
                    }
                })
                .catch(function (err) {
                    self._syncResultInfo.error = err;
                    self._fireSyncEnd();
                });
        },

        _handleKeepServer: function (typeName, conflictingItem, offlineSyncOperations) {
            var self = this;

            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.removeSingle,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(new rsvp.Promise(function (resolve, reject) {
                self.processQuery(syncQuery)
                    .then(function () {
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                self._addItemSynced(serverItem, typeName, 'client', 'update');
                                break;
                            case DataQuery.operations.create:
                                self._addItemSynced(serverItem, typeName, 'client', 'create');
                                break;
                            case DataQuery.operations.removeSingle:
                                self._addItemSynced(clientItem, typeName, 'client', 'delete');
                                break;
                        }
                        resolve();
                    }, function (err) {
                        var itemId;
                        var operation;
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                itemId = serverItem.Id;
                                operation = 'update';
                                break;
                            case DataQuery.operations.create:
                                itemId = serverItem.Id;
                                operation = 'create';
                                break;
                            case DataQuery.operations.removeSingle:
                                itemId = clientItem.Id;
                                operation = 'delete';
                                break;
                        }

                        reject({
                            itemId: itemId,
                            type: operation,
                            contentType: syncQuery.collectionName,
                            error: err,
                            storage: 'client'
                        })
                    })
            }));
        },

        _handleKeepClient: function (conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            if (serverItem && clientItem) {
                var modifiedObject = _.extend(clientItem, {ModifiedAt: new Date(serverItem.ModifiedAt)});

                contentTypeSyncData.modifiedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: modifiedObject
                });
            } else if (serverItem && !clientItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem
                });
            } else if (!serverItem && clientItem) {
                contentTypeSyncData.createdItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: clientItem
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }
        },

        _handleCustom: function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = _.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
            if (serverItem && customItem) {
                var createItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem // create the server item offline and it will be updated when sync finishes
                });

                createItemOfflineQuery.preserveState = true;
                createItemOfflineQuery.isSync = true;

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));
            }

            if (serverItem && customItem && !clientItem) {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem
                });
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
                customItem.Id = clientItem.Id;

                contentTypeSyncData.createdItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            } else {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            }
        },

        _mergeResolvedConflicts: function (conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case constants.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations);
                            break;
                        case constants.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Custom:
                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                    }
                });
            });

            return rsvp.all(offlineSyncOperations);
        },

        _getSyncItemStates: function (contentType, offlineItems, serverItems) {
            var self = this;

            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    deletedItems: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _.each(offlineItems, function (offlineItem) {
                var serverItem = _.findWhere(serverItems, {Id: offlineItem.Id});
                if (serverItem) {
                    if (serverItem.Id === offlineItem.Id && offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                        self._syncResultInfo.failedItems[contentType] = self._syncResultInfo.failedItems[contentType] || [];
                        self._syncResultInfo.failedItems[contentType].push({
                            itemId: serverItem.Id,
                            type: 'create',
                            storage: 'client',
                            error: EverliveErrors.syncError
                        });

                        return;
                    }

                    var clientItemChanged = !!offlineItem[constants.offlineItemsStateMarker];
                    var hasUpdateConflict = false;

                    if (clientItemChanged) {
                        hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime();
                    }

                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.createdItems.push({
                            remoteItem: serverItem,
                            resultingItem: offlineItem
                        });
                    }
                }

                delete offlineItem[constants.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function (resolutionType, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType
            };
        },

        _applyResolutionStrategy: function (conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.setup.conflicts.strategy;
            return new rsvp.Promise(function (resolve, reject) {
                for (var i = 0; i < conflicts.length; i++) {
                    var conflict = conflicts[i];
                    if (conflict.conflictingItems.length) {
                        switch (conflictResolutionStrategy) {
                            case constants.ConflictResolutionStrategy.ServerWins:
                                _.each(conflict.conflictingItems,
                                    self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepServer));
                                break;
                            case constants.ConflictResolutionStrategy.ClientWins:
                                break;
                            case constants.ConflictResolutionStrategy.Custom:
                                var customStrategy = self.setup.conflicts.implementation;
                                if (!customStrategy) {
                                    return reject(new EverliveError('Implementation of the conflict resolution strategy ' +
                                    'must be provided when set to Custom'));
                                }

                                customStrategy(conflicts, resolve);
                                break;
                            default:
                                return reject(new EverliveError('Invalid resolution strategy provided'));
                        }
                    }
                }

                resolve();
            });
        },

        _getSyncPromiseBatch: function (contentType, batchIds) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var dataQuery = new DataQuery({
                    collectionName: contentType,
                    filter: {
                        'Id': {
                            '$in': batchIds
                        }
                    },
                    operation: DataQuery.operations.read,
                    onSuccess: function (res) {
                        resolve(res.result);
                    },
                    applyOffline: false,
                    onError: reject
                });

                var getRequestOptionsFromQuery = RequestOptionsBuilder[dataQuery.operation];
                var requestOptions = getRequestOptionsFromQuery(dataQuery);
                var request = new Request(self.everlive.setup, requestOptions);
                request.send();
            });
        },

        _getSyncPromiseForCollection: function (collection, contentType) {
            var self = this;

            var batches = [];
            var batchSize = constants.syncBatchSize;

            var offlineItemsToSync = self._getDirtyItems(collection);

            var allIdsForSync;
            if (this._shouldAutogenerateIdForContentType(contentType)) {
                allIdsForSync = _.pluck(offlineItemsToSync, '_id');
            } else {
                allIdsForSync = _.pluck(_.reject(offlineItemsToSync, function (offlineItem) {
                    return offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created;
                }), '_id');
            }

            var batchCount = Math.ceil(allIdsForSync.length / batchSize);

            for (var i = 0; i < batchCount; i++) {
                var batchSkipSize = i * batchSize;
                var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
                var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
                batches.push(syncGetServerItemsPromise);
            }

            return rsvp.all(batches)
                .then(function (serverItemsSyncResponses) {
                    var result = {
                        serverItems: []
                    };

                    _.each(serverItemsSyncResponses, function (serverItems) {
                        result.serverItems = _.union(result.serverItems, serverItems);
                    });

                    result.offlineItemsToSync = offlineItemsToSync;
                    return result;
                });
        },

        _addItemSynced: function (item, contentType, syncStorage, syncType) {
            if (!this._syncResultInfo.syncedItems[contentType]) {
                this._syncResultInfo.syncedItems[contentType] = [];
            }

            this._syncResultInfo.syncedItems[contentType].push({
                itemId: item.Id,
                type: syncType,
                storage: syncStorage
            })
        },

        _removeItemSynced: function (item, contentType) {
            var itemId;
            if (typeof item === 'string' || typeof item === 'number') {
                itemId = item;
            } else {
                itemId = item.Id;
            }

            if (!this._syncResultInfo.syncedItems[contentType]) {
                this._syncResultInfo.syncedItems[contentType] = [];
            }

            var syncedItems = this._syncResultInfo.syncedItems[contentType];
            this._syncResultInfo.syncedItems[contentType] = _.without(syncedItems, _.findWhere(syncedItems, {itemId: itemId}));
        },

        _getClientWinsSyncData: function (collections) {
            var self = this;

            var syncData = {};
            _.each(collections, function (collection, key) {
                if (!syncData[key]) {
                    syncData[key] = {
                        createdItems: [],
                        modifiedItems: [],
                        deletedItems: []
                    };
                }

                var dirtyItems = self._getDirtyItems(collection);
                var itemsForSync = offlineTransformations.idTransform(dirtyItems);
                _.each(itemsForSync, function (itemForSync) {
                    switch (itemForSync[constants.offlineItemsStateMarker]) {
                        case offlineItemStates.created:
                            syncData[key].createdItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.modified:
                            syncData[key].modifiedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.deleted:
                            syncData[key].deletedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                    }

                    delete itemForSync[constants.offlineItemsStateMarker];
                });

                syncData[key].offlineItemsToSync = itemsForSync;
            });
            return syncData;
        },

        _addModifiedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
                var itemId = item.Id;
                if (!itemId) {
                    throw new EverliveError('When updating an item it must have an Id field.');
                }
                var collectionName = dataCollection.collectionName;
                syncPromises[itemId] = new rsvp.Promise(function (resolve, reject) {
                    return dataCollection
                        .isSync(true)
                        .applyOffline(false)
                        .updateSingle(item)
                        .then(function (res) {
                            self._addItemSynced(item, collectionName, 'server', 'update');
                            var updatedItem = _.extend({}, item, {
                                ModifiedAt: res.ModifiedAt
                            });

                            var updateQuery = new DataQuery({
                                operation: DataQuery.operations.update,
                                data: updatedItem,
                                additionalOptions: {
                                    id: item.Id
                                },
                                collectionName: collectionName,
                                isSync: true
                            });

                            return self.processQuery(updateQuery).then(resolve, function () {
                                reject(_.extend({}, {
                                    storage: 'client',
                                    type: 'update',
                                    itemId: item.Id,
                                    contentType: collectionName,
                                    error: res
                                }));
                            });
                        }, function (res) {
                            reject(_.extend({}, {
                                storage: 'server',
                                type: 'update',
                                itemId: item.Id,
                                contentType: collectionName,
                                error: res
                            }));
                        })
                });
            });
        },

        _addDeletedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection,
                function (item, itemFilter) {
                    var collectionName = dataCollection.collectionName;
                    syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                        var itemId = item.Id;
                        if (!itemId) {
                            throw new EverliveError('When deleting an item it must have an Id field.');
                        }

                        return dataCollection
                            .isSync(true)
                            .applyOffline(false)
                            .destroySingle(itemFilter)
                            .then(function () {
                                self._addItemSynced(item, collectionName, 'server', 'delete');
                                return self._purgeById(collectionName, item.Id).then(function () {
                                    resolve();
                                }, function (err) {
                                    reject(_.extend({}, {
                                        storage: 'client',
                                        type: 'delete',
                                        contentType: collectionName,
                                        itemId: itemId,
                                        error: err
                                    }));
                                });
                            }, function (err) {
                                reject(_.extend({}, {
                                    storage: 'server',
                                    type: 'delete',
                                    contentType: collectionName,
                                    error: err,
                                    itemId: itemId
                                }));
                            });
                    });
                });
        },

        _applyClientWins: function (collections) {
            var self = this;
            var syncData = this._getClientWinsSyncData(collections);
            var syncPromises = {};

            _.each(syncData, function (contentTypeData, typeName) {
                var dataCollection = self.everlive.data(typeName);
                if (contentTypeData.createdItems.length) {
                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.modifiedItems.length) {
                    self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.deletedItems.length) {
                    self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }
            });

            return rsvp.hashSettled(syncPromises);
        },

        _applyStandardSync: function (collections) {
            var self = this;

            var promises = {};
            _.each(collections, function (collection, contentType) {
                promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
            });

            return rsvp.hash(promises)
                .then(self._prepareSyncData.bind(self))
                .then(self._resolveConflicts.bind(self))
                .then(function (contentTypeSyncData) {
                    var syncPromises = {};
                    _.each(contentTypeSyncData, function (contentTypeData, typeName) {
                        var dataCollection = self.everlive.data(typeName);
                        if (contentTypeData.createdItems.length) {
                            self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                        }

                        if (contentTypeData.modifiedItems.length) {
                            self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .update(item, itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, typeName, DataQuery.operations.update);
                                    });
                            });
                        }

                        if (contentTypeData.deletedItems.length) {
                            self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .destroy(itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, typeName, DataQuery.operations.remove);
                                    });
                            });
                        }
                    });

                    return rsvp.hashSettled(syncPromises);
                });
        },

        _applySync: function () {
            var self = this;

            return this._getAllCollections()
                .then(function (collections) {
                    if (self.setup.conflicts.strategy === constants.ConflictResolutionStrategy.ClientWins) {
                        return self._applyClientWins(collections);
                    } else {
                        return self._applyStandardSync(collections);
                    }
                });
        },

        _getDirtyItems: function (collection) {
            var filter = {};
            filter[constants.offlineItemsStateMarker] = {$exists: true};
            var query = mingo.Query(filter);
            var cursor = mingo.Cursor(collection, query);
            return cursor.all();
        },

        _getAllCollections: function () {
            return new rsvp.Promise(this._persister.getAllData.bind(this._persister));
        },

        _getCollection: function (contentType) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                // check the persister if there is no data in the collection cache for this content type
                if (!self._collectionCache[contentType]) {
                    self._persister.getData(contentType, function (data) {
                        self._collectionCache[contentType] = data || {};
                        resolve(self._collectionCache[contentType]);
                    }, reject);
                } else {
                    resolve(self._collectionCache[contentType]);
                }
            });
        },

        _persistData: function (contentType) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var contentTypeData = self._collectionCache[contentType];
                self._transformPersistedData(contentType, contentTypeData);
                self._persister.saveData(contentType, contentTypeData, resolve, reject);
            });
        },

        _getById: function (collection, id) {
            if (!id) {
                throw new EverliveError('Id field is mandatory when using offline storage');
            }

            if (collection[id]) {
                var item = _.extend({}, collection[id]);
                var isDeleted = item && item[constants.offlineItemsStateMarker] === offlineItemStates.deleted;

                return isDeleted ? undefined : item;
            }
        },

        _setItem: function (collection, item, state) {
            if (!state) {
                delete item[constants.offlineItemsStateMarker];
            } else {
                item[constants.offlineItemsStateMarker] = state;
            }

            collection[item._id] = item;
        },

        _shouldAutogenerateIdForContentType: function (contentType) {
            return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
        },

        _createItems: function (contentType, items, isSync, preserveState, success, error) {
            var self = this;
            this._getCollection(contentType)
                .then(function (collection) {
                    var itemsForCreate = _.isArray(items) ? items : [items];
                    var createdItems = _.map(itemsForCreate, function (currentItem, index) {
                        var itemToCreate = _.extend({}, currentItem);

                        itemToCreate._id = itemToCreate.Id || uuid.v1();
                        delete itemToCreate.Id;

                        var existingItem = self._getById(collection, itemToCreate._id);
                        var itemExists = !!existingItem;
                        var state;
                        if (itemExists && (!isSync && !preserveState)) {
                            // TODO: [offline] return the same error as the server does
                            return error(new Error('An item with the specified id already exists'));
                        } else {
                            if (isSync && preserveState && itemExists) {
                                state = existingItem[constants.offlineItemsStateMarker];
                            } else {
                                state = isSync ? undefined : offlineItemStates.created; // set the state to created only if not syncing
                            }
                        }

                        // we need to manually clone the dates in order to dereference them from the original object as
                        // _.extends will pass a reference to the original date instead of creating a new instance
                        if (currentItem.CreatedAt && currentItem.CreatedAt instanceof Date) {
                            itemToCreate.CreatedAt = utils.cloneDate(currentItem.CreatedAt);
                        } else {
                            itemToCreate.CreatedAt = new Date();
                        }

                        if (currentItem.ModifiedAt && currentItem.ModifiedAt instanceof Date) {
                            itemToCreate.ModifiedAt = utils.cloneDate(currentItem.ModifiedAt);
                        } else {
                            itemToCreate.ModifiedAt = utils.cloneDate(itemToCreate.CreatedAt);
                        }

                        itemToCreate.CreatedBy = itemToCreate.CreatedBy || self.everlive.setup.principalId || constants.guidEmpty;
                        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
                        if (contentType === 'Users') {
                            itemToCreate.Owner = itemToCreate._id;
                        } else {
                            itemToCreate.Owner = itemToCreate.CreatedBy || constants.guidEmpty;
                        }

                        self._setItem(collection, _.extend({}, itemToCreate), state);
                        return itemToCreate;
                    });

                    return self._persistData(contentType).then(function () {
                        if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
                            createdItems = offlineTransformations.removeIdTransform(createdItems);
                        }
                        success(createdItems);
                    });
                }).catch(error);
        },

        _applyUpdateOperation: function (originalUpdateExpression, itemToUpdate, collection, isSync) {
            var dbOperators = utils.getDbOperators(originalUpdateExpression, true);
            var hasDbOperator = dbOperators.length !== 0;

            var updateExpression;
            if (hasDbOperator) {
                updateExpression = originalUpdateExpression;
            } else {
                updateExpression = {
                    $set: originalUpdateExpression
                };
            }
            var updateExpressionForUser = {
                ModifiedBy: this.everlive.setup.principalId || constants.guidEmpty
            };
            updateExpression.$set = _.extend(updateExpressionForUser, updateExpression.$set);

            if (isSync) {
                updateExpression.$set.ModifiedAt = utils.cloneDate(originalUpdateExpression.ModifiedAt);
            }

            mongoQuery(itemToUpdate, {}, updateExpression, {strict: true}); // Setting strict to true so only exact matches would be updated

            itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
            delete itemToUpdate.Id;

            var newState;
            if (isSync) {
                newState = undefined;
            } else if (itemToUpdate[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                newState = offlineItemStates.created;
            } else {
                newState = offlineItemStates.modified;
            }

            this._setItem(collection, itemToUpdate, newState);
        },

        _updateItems: function (dataQuery, updateExpression, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var updateItems;

                    if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                        itemToUpdate = self._getById(collection, dataQuery.additionalOptions.id);
                        self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync);
                        updateItems = [itemToUpdate];
                    } else {
                        updateItems = self._readInternal(collection, filter);
                        for (var i = 0; i < updateItems.length; i++) {
                            var itemToUpdate = updateItems[i];
                            var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                            if (!itemExists && !isSync) {
                                return reject(EverliveErrors.itemNotFound);
                            }

                            self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync);
                        }
                    }

                    return self._persistData(dataQuery.collectionName)
                        .then(function () {
                            var updatedItemCount = updateItems.length;
                            var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();

                            var result = {
                                ModifiedAt: modifiedAtResult,
                                result: updatedItemCount
                            };

                            resolve(result);
                        });
                }).catch(reject);
        },

        _clearItem: function (collection, item) {
            delete collection[item._id];
        },

        _removeItems: function (dataQuery, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var itemsToRemove = self._readInternal(collection, filter);

                    for (var i = 0; i < itemsToRemove.length; i++) {
                        var itemToRemove = itemsToRemove[i];
                        itemToRemove._id = itemToRemove._id || itemToRemove.Id;
                        var itemExists = !!self._getById(collection, itemToRemove._id.toString());

                        if (!itemExists && !isSync) {
                            return reject(new EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.'));
                        }

                        var removeFromMemory = itemToRemove[constants.offlineItemsStateMarker] === offlineItemStates.created || isSync;
                        if (removeFromMemory) {
                            self._clearItem(collection, itemToRemove);
                        } else {
                            self._setItem(collection, itemToRemove, offlineItemStates.deleted);
                        }
                    }

                    return self._persistData(dataQuery.collectionName)
                        .then(function () {
                            var response = self._transformOfflineResult(itemsToRemove.length);
                            resolve(response);
                        });
                }).catch(reject);
        },

        _applyTransformations: function (transformedResult, transformations) {
            if (Array.isArray(transformedResult.result)) {
                _.each(transformations, function (transformation) {
                    transformedResult.result.map(function (value, key) {
                        transformedResult.result[key] = transformation(value);
                    });
                });
            } else {
                _.each(transformations, function (transformation) {
                    transformedResult.result = transformation(transformedResult.result);
                });
            }
        },

        _transformOfflineResult: function (resultSet, count, dataQuery, additionalTransformations) {
            var transformedResult = {
                result: resultSet,
                count: count || (resultSet || []).length
            };

            if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
                transformedResult.count = count || resultSet.length;
            }

            var transformations = [];

            transformations.push(offlineTransformations.idTransform);
            transformations.push(offlineTransformations.removeMarkersTransform);

            if (dataQuery) {
                var includeCount = dataQuery.getHeader(Headers.includeCount);
                if (includeCount === false) {
                    delete transformedResult.count;
                }

                var singleFieldExpression = dataQuery.getHeader(Headers.singleField);
                if (typeof singleFieldExpression === 'string') {
                    transformations.push(offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
                }
            }

            if (additionalTransformations) {
                transformations = transformations.concat(additionalTransformations);
            }

            this._applyTransformations(transformedResult, transformations);

            if (transformedResult.count === undefined) {
                delete transformedResult.count;
            }

            return transformedResult;
        },

        _transformPersistedData: function (contentType, contentTypeData) {
            var transformFields = [];

            if (contentType === 'Users') {
                transformFields = transformFields.concat(['Password', 'QuestionId', 'SecretAnswer']);
            }

            if (transformFields.length) {
                _.each(contentTypeData, function (contentTypeObject) {
                    offlineTransformations.removeFieldsTransform(contentTypeObject, transformFields);
                });
            }
        }
    };

    return OfflineModule;
})();
},{"../EverliveError":36,"../ExpandProcessor":37,"../Request":42,"../common":46,"../constants":47,"../query/DataQuery":56,"../query/RequestOptionsBuilder":59,"../utils":66,"./offlineTransformations":55}],53:[function(require,module,exports){
var constants = require('../constants');
var persistersModule = require('./offlinePersisters');
var LocalStoragePersister = persistersModule.LocalStoragePersister;
var FileSystemPersister = persistersModule.FileSystemPersister;
var OfflineStorageModule = require('./OfflineStorageModule');
var EverliveError = require('../EverliveError').EverliveError;
var isNativeScript = require('../everlive.platform').isNativeScript;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var CryptographicProvider = require('../encryption/CryptographicProvider');

var defaultOfflineStorageOptions = {
    autoSync: true,
    enabled: true,
    conflicts: {
        strategy: constants.ConflictResolutionStrategy.ClientWins,
        implementation: null
    },
    offline: false,
    storage: {
        name: '',
        provider: isNativeScript ? constants.StorageProvider.FileSystem : constants.StorageProvider.LocalStorage,
        implementation: null,
        storagePath: constants.DefaultStoragePath
    },
    typeSettings: {},
    encryption: {
        provider: constants.EncryptionProvider.Default,
        implementation: null,
        key: ''
    }
};

module.exports = (function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(server);
        });
    };

    var initStoragePersister = function initStoragePersister(options) {
        var persister;
        var storageProvider = options.storage.provider;
        var storageProviderImplementation = options.storage.implementation;
        var storageKey = options.storage.name || 'everliveOfflineStorage_' + this.setup.apiKey;
        if (_.isObject(storageProviderImplementation) && storageProvider === constants.StorageProvider.Custom) {
            persister = storageProviderImplementation;
        } else {
            switch (storageProvider) {
                case constants.StorageProvider.LocalStorage:
                    persister = new LocalStoragePersister(storageKey, this);
                    break;
                case constants.StorageProvider.FileSystem:
                    persister = new FileSystemPersister(storageKey, this);
                    break;
                case constants.StorageProvider.Custom:
                    throw new EverliveError('Custom storage provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported storage type ' + storageProvider);
            }
        }

        options.storage.implementation = persister;
        return persister;
    };

    var initEncryptionProvider = function initEncryptionProvider(options) {
        var encryptor;
        var encryptionProvider = options.encryption.provider;
        var encryptionImplementation = options.encryption.implementation;
        if (_.isObject(encryptionImplementation) && encryptionProvider === constants.EncryptionProvider.Custom) {
            encryptor = encryptionImplementation;
        } else {
            switch (encryptionProvider) {
                case constants.EncryptionProvider.Default:
                    encryptor = new CryptographicProvider(this);
                    break;
                case constants.EncryptionProvider.Custom:
                    throw new EverliveError('Custom encryption provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported encryption provider ' + encryptionProvider);
            }
        }

        options.encryption.implementation = encryptor;
        return encryptor;
    };

    var buildOfflineStorageModule = function buildOfflineStorageModule(storageOptions) {
        var options;
        if (storageOptions === true) { // explicit check for shorthand initialization
            options = _.defaults({}, defaultOfflineStorageOptions);
        } else if (_.isObject(storageOptions)) {
            options = _.defaults(storageOptions, defaultOfflineStorageOptions);
            options.storage = _.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
            options.encryption = _.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
            options.conflicts = _.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
        } else {
            options = _.defaults({}, defaultOfflineStorageOptions);
            options.enabled = false;
        }

        var persister = initStoragePersister.call(this, options, storageOptions);
        var encryptionProvider = initEncryptionProvider.call(this, options);

        return new OfflineStorageModule(this, options, persister, encryptionProvider);
    };

    var initOfflineStorage = function (options) {
        this.offlineStorage = buildOfflineStorageModule.call(this, options.offlineStorage);
    };

    return {
        initOfflineStorage: initOfflineStorage
    }
}());
},{"../EverliveError":36,"../common":46,"../constants":47,"../encryption/CryptographicProvider":48,"../everlive.platform":49,"./OfflineStorageModule":52,"./offlinePersisters":54}],54:[function(require,module,exports){
var common = require('../common');
var _ = common._;
var platform = require('../everlive.platform');
var isNativeScript = platform.isNativeScript;
var isCordova = platform.isCordova;
var rsvp = common.rsvp;
var parseUtilities = require('../utils').parseUtilities;
var EverliveError = require('../EverliveError').EverliveError;
var util = require('util');
var LocalStore = require('../LocalStore');
var constants = require('../constants');

/**
 * Can be one of the following types: {@link LocalStoragePersister},
 * {@link FileSystemPersister} or a custom based on {@link BasePersister}
 * @memberOf OfflineModule
 * @instance
 * @member {BasePersister} local
 */

var BasePersister = (function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister(key, sdk) {
        this.key = key;
        this.sdk = sdk;
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @returns {Object} Keys are the content types and the values are the corresponding data
         */
        getAllData: function (success, error) {
            throw new EverliveError('The method getAllData is not implemented');
        },

        /**
         * Returns the saved data for a specific content type
         * @method getData
         * @param {string} contentType The content type for which to retreive the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         * @returns {Object} The retrieved data
         */
        getData: function (contentType, success, error) {
            throw new EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type
         * @method saveData
         * @param {string} contentType The content for which to save the data
         * @param {object} data The data corresponding to the specified content type
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        saveData: function (contentType, data, success, error) {
            throw new EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type
         * @method clear
         * @param {string} contentType The content type for which to clear the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        purge: function (contentType, success, error) {
            throw new EverliveError('The method clear is not implemented');
        },

        /**
         * Clears the persisted data for a content type
         * @method clearAll
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         */
        purgeAll: function (success, error) {
            throw new EverliveError('The method clearAll is not implemented');
        },

        _getKey: function (contentType) {
            return this.key + '_' + contentType;
        },

        _getEncryptionProvider: function () {
            return this.sdk.offlineStorage._getEncryptionProvider();
        }
    };

    return BasePersister;
}());

var LocalStoragePersister = (function () {
    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key, sdk) {
        BasePersister.apply(this, arguments);
        this._localStore = null;
    }

    util.inherits(LocalStoragePersister, BasePersister);

    //We need to offline storage path from the sdk.offlineStorage.setup in nodejs
    //but it is not available since it is created after the persisters are initialized
    //that is why we pospone the localstore initialization for the first time it is needed
    LocalStoragePersister.prototype._ensureLocalStore = function () {
        if (!this._localStore) {
            this._localStore = new LocalStore(this.sdk);
        }
    };

    LocalStoragePersister.prototype.getAllData = function (success, error) {
        var self = this;
        var contentTypes = this._getContentTypes();
        var allCollections = {};
        _.each(contentTypes, function (contentType) {
            allCollections[contentType] = new rsvp.Promise(function (resolve, reject) {
                self.getData(contentType, resolve, reject);
            });
        });

        rsvp.hash(allCollections).then(success, error);
    };

    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key) || '{}';
            var reviver = parseUtilities.getReviver();
            var storedItemObject = JSON.parse(storedItem, reviver);
            success(storedItemObject);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
        try {
            var collectionsString = JSON.stringify(data);
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, collectionsString);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            this._removeItem(key);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purgeAll = function (success, error) {
        try {
            var self = this;

            var contentTypes = this._getContentTypes();
            _.each(contentTypes, function (contentType) {
                var contentTypeKey = self._getKey(contentType);
                self._removeItem(contentTypeKey);
            });

            var contentTypesKey = this._getContentTypesCollectionKey();
            this._removeItem(contentTypesKey);

            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._getItem = function (key) {
        this._ensureLocalStore();
        var value = this._localStore.getItem(key);
        var encryptionProvider = this._getEncryptionProvider();
        return encryptionProvider.decrypt(value);
    };

    LocalStoragePersister.prototype._setItem = function (key, value) {
        this._ensureLocalStore();
        var encryptionProvider = this._getEncryptionProvider();
        value = encryptionProvider.encrypt(value);
		return this._localStore.setItem(key, value);

    };

    LocalStoragePersister.prototype._removeItem = function (key) {
        this._ensureLocalStore();
        return this._localStore.removeItem(key);
    };

    LocalStoragePersister.prototype._getKey = function (contentType) {
        this._ensureLocalStore();
        this._addTypeToCollectionsCache(contentType);
        return LocalStoragePersister.super_.prototype._getKey.apply(this, arguments);
    };

    LocalStoragePersister.prototype._getContentTypesCollectionKey = function () {
        return this.key + '@ContentTypes';
    };

    LocalStoragePersister.prototype._getContentTypes = function () {
        var collectionKey = this._getContentTypesCollectionKey();
        var localStorageString = this._getItem(collectionKey);

        if (localStorageString) {
            return JSON.parse(localStorageString);
        }

        return [];
    };

    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
        var collectionKey = this._getContentTypesCollectionKey();
        this._setItem(collectionKey, JSON.stringify(collection));
    };

    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
        var contentTypesCollection = this._getContentTypes();
        if (!_.contains(contentTypesCollection, typeName)) {
            contentTypesCollection.push(typeName);
            this._setContentTypesCollection(contentTypesCollection);
        }
    };

    return LocalStoragePersister;
}());

var FileSystemPersister = (function () {
    /**
     * @class FileSystemPersister
     * @extends BasePersister
     */
    function FileSystemPersister(key, sdk) {
        BasePersister.apply(this, arguments);

        if (!isCordova && !isNativeScript) {
            throw new EverliveError('FileSystemPersister can be used only with Cordova and NativeScript');
        }

        this.contentTypesStoreKey = '@ContentTypes';
    }

    util.inherits(FileSystemPersister, BasePersister);

    FileSystemPersister.prototype.getAllData = function (success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        var promises = {};
        this._getContentTypesMetadata(function (contentTypes) {
            Object.keys(contentTypes).forEach(function (contentType) {
                promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                    self.getData(contentType, resolve, reject);
                });
            });

            rsvp.hash(promises).then(success, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.getData = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._readFileContent(fileEntry, success, errorHandler);
        }, error);
    };

    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
        var self = this;
        var dataString = JSON.stringify(data);
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._writeFileContent(fileEntry, dataString, function () {
                self._saveContentTypesMetadata(contentType, success, errorHandler);
            }, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purge = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._removeFile(fileEntry, success, error);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purgeAll = function (success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._resolveDataDirectory(function (dataDirEntry) {
            self._removeFilesDirectory(dataDirEntry, success, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype._ensureProperties = function () {
        if (!this.filesDirectoryPath) {
            this.filesDirectoryPath = this.sdk.offlineStorage.setup.storage.storagePath;
        }

        if (!this.dataDirectoryPath) {
            if (isCordova) {
                if (cordova && !cordova.file) {
                    throw new EverliveError('You need to enable the cordova file plugin to use file offline storage. ' +
                    'Make sure that the "deviceReady" event has fired.');
                }

                this.dataDirectoryPath = cordova.file.dataDirectory;
            } else if (isNativeScript) {
                this.fs = require('file-system');
                this.dataDirectoryPath = this.fs.knownFolders.documents().path;
            }
        }
    };

    FileSystemPersister.prototype._getContentTypesMetadata = function (success, error) {
        this._ensureProperties();
        this.getData(this.contentTypesStoreKey, success, error);
    };

    FileSystemPersister.prototype._saveContentTypesMetadata = function (contentType, success, error) {
        this._ensureProperties();
        var self = this;
        this._getContentTypesMetadata(function (savedContentTypes) {
            savedContentTypes[contentType] = true;
            self._getFileFull(self.contentTypesStoreKey, function (contentTypesFile) {
                self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
            }, error);
        });
    };

    FileSystemPersister.prototype._getFileFull = function (contentType, success, error) {
        this._ensureProperties();
        var self = this;
        this._ensureFilesDirectory(function () {
            var path = self._getFilePath(contentType);
            self._getFileFromSystem(path, success, error);
        }, error);
    };

    FileSystemPersister.prototype._removeFilesDirectory = function (directoryEntry, success, error) {
        this._ensureProperties();
        if (isCordova) {
            directoryEntry.getDirectory(this.filesDirectoryPath, {
                create: true,
                exclusive: false
            }, function (filesDirEntry) {
                filesDirEntry.removeRecursively(function () {
                    success();
                }, error);
            }, error)
        } else if (isNativeScript) {
            var filesDirectoryPath = this.fs.path.join(directoryEntry.path, this.filesDirectoryPath);
            var filesDirectory = this.fs.Folder.fromPath(filesDirectoryPath);
            filesDirectory.remove().then(success, error);
        }
    };

    FileSystemPersister.prototype._removeFile = function (fileEntry, success, error) {
        this._ensureProperties();
        if (isCordova) {
            fileEntry.remove(function () {
                success();
            }, error);
        } else if (isNativeScript) {
            fileEntry.remove().then(success, error);
        }
    };

    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
        this._ensureProperties();
        var that = this;
        var readTextSuccess = function (content) {
            var encryptionProvider = that._getEncryptionProvider();
            content = encryptionProvider.decrypt(content);

            var reviver = parseUtilities.getReviver();
            var resultObject = JSON.parse(content || '{}', reviver);
            success(resultObject);
        };

        if (isCordova) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function () {
                    readTextSuccess(this.result);
                };
                reader.onerror = error;
                reader.readAsText(file);
            }, error);
        } else if (isNativeScript) {
            fileEntry.readText().then(readTextSuccess, error);
        }
    };

    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
        this._ensureProperties();
        var encryptionProvider = this._getEncryptionProvider();
        content = encryptionProvider.encrypt(content);

        if (isCordova) {
            fileEntry.createWriter(function (fileWriter) {
                fileWriter.onwriteend = function () {
                    success();
                };

                fileWriter.onerror = error;
                fileWriter.write(content);
            }, error);
        } else if (isNativeScript) {
            fileEntry.writeText(content).then(success, error);
        }
    };

    FileSystemPersister.prototype._getFileFromSystem = function (path, success, error) {
        this._ensureProperties();
        this._resolveDataDirectory(function (directoryEntry) {
            if (isCordova) {
                directoryEntry.getFile(path, {
                    create: true,
                    exclusive: false
                }, success, error);
            } else if (isNativeScript) {
                try {
                    var fullFilePath = this.fs.path.join(directoryEntry.path, path);
                    var file = this.fs.File.fromPath(fullFilePath);
                    success(file);
                } catch (e) {
                    error(e);
                }
            }
        }.bind(this));
    };

    FileSystemPersister.prototype._getFilePath = function (contentType) {
        this._ensureProperties();
        return this.filesDirectoryPath + this._getKey(contentType);
    };

    FileSystemPersister.prototype._resolveDataDirectory = function (success, error) {
        this._ensureProperties();
        if (isCordova) {
            resolveLocalFileSystemURL(this.dataDirectoryPath, success, error);
        } else if (isNativeScript) {
            var dataDirectory = this.fs.Folder.fromPath(this.dataDirectoryPath);
            success(dataDirectory);
        }
    };

    FileSystemPersister.prototype._ensureFilesDirectory = function (success, error) {
        this._ensureProperties();
        var filesDirectoryPath = this.filesDirectoryPath;
        this._resolveDataDirectory(function (directoryEntry) {
            if (isCordova) {
                directoryEntry.getDirectory(filesDirectoryPath, {
                    create: true,
                    exclusive: false
                }, success, error);
            } else if (isNativeScript) {
                try {
                    var fileDirectoryPath = this.fs.path.join(directoryEntry.path, filesDirectoryPath);
                    this.fs.Folder.fromPath(fileDirectoryPath);
                    success();
                } catch (e) {
                    error (e);
                }
            }
        }.bind(this), error);
    };

    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
        if (!isNativeScript) {
            var errorsMap = {};
            _.each(Object.keys(FileError), function (error) {
                errorsMap[FileError[error]] = error;
            });

            return function (e) {
                e.message = errorsMap[e.code];
                callback && callback(e);
            }
        }

        return function (e) {
            callback && callback(e);
        }
    };

    return FileSystemPersister;
}());

module.exports = {
    BasePersister: BasePersister,
    LocalStoragePersister: LocalStoragePersister,
    FileSystemPersister: FileSystemPersister
};
},{"../EverliveError":36,"../LocalStore":40,"../common":46,"../constants":47,"../everlive.platform":49,"../utils":66,"file-system":"file-system","util":6}],55:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var _ = require('../common')._;
var offlineItemStateMarker = constants.offlineItemsStateMarker;

var traverseAndApply = function (value, operation, additionalOptions) {
    if (_.isArray(value)) {
        return _.map(value, function (item) {
            return operation(item, additionalOptions);
        });
    } else {
        return operation(value, additionalOptions);
    }
};

var idTransformation = function (value) {
    if (typeof value === 'object' && value._id && !value.Id) {
        value.Id = value._id;
        delete value._id;
    }

    return value;
};

var removeIdTransform = function (value, opts) {
    var verifyStateCreated = opts.verifyStateCreated;
    var shouldModifyObject = verifyStateCreated ? value[constants.offlineItemsStateMarker] === constants.offlineItemStates.created : true;
    if (typeof value === 'object' && (value._id || value.Id) && shouldModifyObject) {
        delete value._id;
        delete value.Id;
    }

    return value;
};

var removeMarkerTransform = function (value) {
    delete value[offlineItemStateMarker];
    return value;
};

var offlineTransformations = {
    removeIdTransform: function (value, verifyStateCreated) {
        return traverseAndApply(value, removeIdTransform, {verifyStateCreated: verifyStateCreated});
    },
    idTransform: function (value) {
        return traverseAndApply(value, idTransformation);
    },
    singleFieldTransform: function (singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function (filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if (typeof objectMember === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function (value) {
        return traverseAndApply(value, removeMarkerTransform);
    },
    removeFieldsTransform: function (value, fields) {
        _.each(fields, function (field) {
            delete value[field];
        });

        return value;
    }
};

module.exports = offlineTransformations;
},{"../common":46,"../constants":47}],56:[function(require,module,exports){
var _ = require('../common')._;

module.exports = (function () {
    // TODO: [offline] Update the structure - filter field can be refactored for example and a skip/limit/sort property can be added
    var DataQuery = function (config) {
        this.collectionName = config.collectionName;
        this.headers = config.headers || {};
        this.filter = config.filter;
        this.onSuccess = config.onSuccess;
        this.onError = config.onError;
        this.operation = config.operation;
        this.parse = config.parse;
        this.additionalOptions = config.additionalOptions;
        this.data = config.data;
        this.useOffline = config.useOffline;
        this.applyOffline = config.applyOffline;
        this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
        this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
        this._normalizedHeaders = null;
        this.isSync = config.isSync;
    };

    DataQuery.prototype = {
        getHeader: function (header) {
            var self = this;
            var headerKeys = Object.keys(this.headers);

            if (!this._normalizedHeaders) {
                this._normalizedHeaders = {};
                _.each(headerKeys, function (headerKey) {
                    var normalizedKey = headerKey.toLowerCase();
                    var headerValue = self.headers[headerKey];
                    self._normalizedHeaders[normalizedKey] = headerValue;
                });
            }

            var normalizedHeader = header.toLowerCase();
            return this._normalizedHeaders[normalizedHeader];
        },

        getHeaderAsJSON: function (header) {
            var headerValue = this._normalizedHeaders[header.toLowerCase()];
            if (_.isObject(headerValue)) {
                return headerValue;
            }
            if (_.isString(headerValue)) {
                try {
                    return JSON.parse(headerValue);
                } catch (e) {
                    return headerValue;
                }
            } else {
                return headerValue;
            }
        }
    };

    DataQuery.operations = {
        read: 'read',
        create: 'create',
        update: 'update',
        remove: 'destroy',
        removeSingle: 'destroySingle',
        readById: 'readById',
        count: 'count',
        rawUpdate: 'rawUpdate',
        setAcl: 'setAcl',
        setOwner: 'setOwner',
        userLogin: 'login',
        userLogout: 'logout',
        userChangePassword: 'changePassword',
        userLoginWithProvider: 'loginWith',
        userLinkWithProvider: 'linkWith',
        userUnlinkFromProvider: 'unlinkFrom',
        filesUpdateContent: 'updateContent',
        filesGetDownloadUrlById: 'downloadUrlById'
    };

    return DataQuery;
}());
},{"../common":46}],57:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;
var WhereQuery = require('./WhereQuery');
var QueryBuilder = require('./QueryBuilder');

module.exports = (function () {
    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression]({% slug rest-api-querying-filtering %}) definition.
     * @param {object} [fields] A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
     * @param {object} [sort] A [sort expression]({% slug rest-api-querying-sorting %}) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        this.filter = filter;
        this.fields = fields;
        this.sort = sort;
        this.toskip = skip;
        this.totake = take;
        this.expandExpression = expand;
        this.expr = new Expression(OperatorType.query);
    }

    Query.prototype = {
        /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @param {object} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Query}
         */
        /** Defines a filter definition for the current query.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @returns {WhereQuery}
         */
        where: function (filter) {
            if (filter) {
                return this._simple(OperatorType.filter, [filter]);
            }
            else {
                return new WhereQuery(this);
            }
        },
        /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
         * @memberOf Query.prototype
         * @method select
         * @param {object} fieldsExpression A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
         * @returns {Query}
         */
        select: function () {
            return this._simple(OperatorType.select, arguments);
        },
        // TODO
        //exclude: function () {
        //    return this._simple(OperatorType.exclude, arguments);
        //},
        /** Sorts the items in the current query in ascending order by the specified field.
         * @memberOf Query.prototype
         * @method order
         * @param {string} field The field name to order by in ascending order.
         * @returns {Query}
         */
        order: function (field) {
            return this._simple(OperatorType.order, [field]);
        },
        /** Sorts the items in the current query in descending order by the specified field.
         * @memberOf Query.prototype
         * @method orderDesc
         * @param {string} field The field name to order by in descending order.
         * @returns {Query}
         */
        orderDesc: function (field) {
            return this._simple(OperatorType.order_desc, [field]);
        },
        /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
         * @memberOf Query.prototype
         * @method skip
         * @see [query.take]{@link query.take}
         * @param {number} value The number of items to skip.
         * @returns {Query}
         */
        skip: function (value) {
            return this._simple(OperatorType.skip, [value]);
        },
        /** Takes a specified number of items from the query result. Used for paging.
         * @memberOf Query.prototype
         * @method take
         * @see [query.skip]{@link query.skip}
         * @param {number} value The number of items to take.
         * @returns {Query}
         */
        take: function (value) {
            return this._simple(OperatorType.take, [value]);
        },
        /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Query.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Query}
         */
        expand: function (expandExpression) {
            return this._simple(OperatorType.expand, [expandExpression]);
        },
        /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
         * @memberOf Query.prototype
         * @method build
         * @returns {{$where,$select,$sort,$skip,$take,$expand}}
         */
        build: function () {
            return new QueryBuilder(this).build();
        },
        _simple: function (op, oprs) {
            var args = [].slice.call(oprs);
            this.expr.addOperand(new Expression(op, args));
            return this;
        }
    };

    return Query;
}());
},{"../Expression":38,"../constants":47,"./QueryBuilder":58,"./WhereQuery":60}],58:[function(require,module,exports){
var constants = require('../constants');
var OperatorType = constants.OperatorType;
var _ = require('../common')._;
var GeoPoint = require('../GeoPoint');
var EverliveError = require('../EverliveError').EverliveError;
var Expression = require('../Expression');
var maxDistanceConsts = constants.maxDistanceConsts;
var radiusConsts = constants.radiusConsts;

module.exports = (function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function () {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expandExpression || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand()
            };
        },
        _getSkip: function () {
            var skipExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function () {
            var takeExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function () {
            var expandExpression = _.chain(this.expr.operands)
                .filter(function (value) {
                    return value.operator === OperatorType.expand;
                })
                .reduce(function (result, expression) { //expression contains operands and has operator type expand
                    return _.extend(result, expression.operands[0]);
                }, {})
                .value();
            return _.isEmpty(expandExpression) ? null : expandExpression;
        },
        _buildSelect: function () {
            var selectExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildSort: function () {
            var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildWhere: function () {
            var whereExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new Expression(OperatorType.and, whereExpression.operands));
            }
            else {
                var filterExpression = _.find(this.expr.operands, function (value, index, list) {
                    return value.operator === OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function (expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            }
            else if (this._isRegex(expr)) {
                return this._regex(expr);
            }
            else if (this._isGeo(expr)) {
                return this._geo(expr);
            }
            else if (this._isAnd(expr)) {
                return this._and(expr);
            }
            else if (this._isOr(expr)) {
                return this._or(expr);
            }
            else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function (expr) {
            return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
        },
        _simple: function (expr) {
            var term = {}, fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            }
            else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function (expr) {
            return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
        },
        _regex: function (expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function (expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function (regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return {$regex: regex.source, $options: options};
        },
        _isGeo: function (expr) {
            return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
        },
        _geo: function (expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function (expr) {
            switch (expr.operator) {
                case OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function (expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function (expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function (point) {
            if (_.isArray(point)) {
                return new GeoPoint(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function (points) {
            var self = this;
            return _.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function (expr) {
            return expr.operator === OperatorType.and;
        },
        _and: function (expr) {
            var i, l, term, result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                }
                else {
                    newValue = newObj[key];
                    if (typeof value === 'object' && typeof newValue === 'object') {
                        value = _.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function (expr) {
            return expr.operator === OperatorType.or;
        },
        _or: function (expr) {
            var i, l, term, result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _isNot: function (expr) {
            return expr.operator === OperatorType.not;
        },
        _not: function (expr) {
            return {$not: this._build(expr.operands[0])};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case OperatorType.equal:
                    return null;
                case OperatorType.not_equal:
                    return '$ne';
                case OperatorType.gt:
                    return '$gt';
                case OperatorType.lt:
                    return '$lt';
                case OperatorType.gte:
                    return '$gte';
                case OperatorType.lte:
                    return '$lte';
                case OperatorType.isin:
                    return '$in';
                case OperatorType.notin:
                    return '$nin';
                case OperatorType.all:
                    return '$all';
                case OperatorType.size:
                    return '$size';
            }
            throw new EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}());
},{"../EverliveError":36,"../Expression":38,"../GeoPoint":39,"../common":46,"../constants":47}],59:[function(require,module,exports){
var DataQuery = require('./DataQuery');
var Request = require('../Request');
var _ = require('../common')._;

module.exports = (function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
            endpoint += '/' + dataQuery.additionalOptions.id;
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            filter: dataQuery.filter,
            success: dataQuery.onSuccess,
            error: dataQuery.onError,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
    };

    RequestOptionsBuilder[DataQuery.operations.read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.readById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.rawUpdate] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        var ofilter = null; // request options filter

        if (typeof filter === 'string') {
            endpoint += '/' + filter; // send the filter through query string
        } else if (typeof filter === 'object') {
            ofilter = filter; // send the filter as filter headers
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint,
            filter: ofilter
        });
    };

    RequestOptionsBuilder[DataQuery.operations.update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.remove] = function (dataQuery) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.removeSingle] = RequestOptionsBuilder[DataQuery.operations.remove];

    RequestOptionsBuilder[DataQuery.operations.setAcl] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;

        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_acl';
        var method, data;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpoint: endpoint,
            data: data
        });
    };

    RequestOptionsBuilder[DataQuery.operations.setOwner] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_owner';

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    return RequestOptionsBuilder;
}());
},{"../Request":42,"../common":46,"./DataQuery":56}],60:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;

module.exports = (function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new Expression(exprOp || OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function () {
            return new WhereQuery(this, OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function () {
            return new WhereQuery(this, OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function () {
            return new WhereQuery(this, OperatorType.not, true);
        },
        _simple: function (operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new Expression(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function (field, value) {
            return this._simple(OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function (field, value) {
            return this._simple(OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function (field, value) {
            return this._simple(OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function (field, value) {
            return this._simple(OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function (field, value) {
            return this._simple(OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function (field, value) {
            return this._simple(OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function (field, value) {
            return this._simple(OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function (field, value) {
            return this._simple(OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function (field, value) {
            return this._simple(OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function (field, value) {
            return this._simple(OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function (field, value, flags) {
            return this._simple(OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function (field, value, flags) {
            return this._simple(OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function (field, value, flags) {
            return this._simple(OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function (field, point, distance, metrics) {
            return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function (field, pointBottomLeft, pointUpperRight) {
            return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);

         var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function (field, points) {
            return this._simple(OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function (field, center, radius, metrics) {
            return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function () {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function () {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}());
},{"../Expression":38,"../constants":47}],61:[function(require,module,exports){
var http = require('http');
module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var httpRequestOptions = {
            url: options.url,
            method: options.method,
            headers: options.headers || {}
        };

        if (options.data) {
            httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
        }

        httpRequestOptions.headers['Accept'] = 'application/json';
        httpRequestOptions.headers['Content-Type'] = 'application/json';

        var noop = function () {
        };
        var success = options.success || noop;
        var error = options.error || noop;

        var requestSuccessCallback = function (response) {
            var contentString = response.content.toString();
            if (response.statusCode < 400) {
                // Success callback calls a custom parse function
                success(contentString);
            } else {
                // Error callback relies on a JSON Object with ResponseText inside
                error({
                    responseText: contentString
                });
            }
        };

        var requestErrorCallback = function (err) {
            // error: function(jqXHR, textStatus, errorThrown)
            // when timeouting for example (i.e. no internet connectivity), we get an err with content { message: "timeout...", stack: null }
            error({
                responseText: err
            });
        };

        http.request(httpRequestOptions).then(requestSuccessCallback, requestErrorCallback);
    }

    return reqwest;
}());
},{"http":"http"}],62:[function(require,module,exports){
(function (Buffer){
var url = require('url');
var http = require('http');
var https = require('https');
var rsvp = require('rsvp');
var zlib = require('zlib');
var _ = require('underscore');

module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var urlParts = url.parse(options.url);
        var request;
        if (urlParts.protocol === 'https:') {
            request = https.request;
        }
        else {
            request = http.request;
        }
        var headers = options.headers || {};
        options.success = options.success || _.noop;
        options.error = options.error || _.noop;

        headers['Content-Type'] = options.contentType;
        var req = request({
            method: options.method,
            hostname: urlParts.hostname,
            port: urlParts.port,
            path: urlParts.path,
            headers: headers
        }, function (res) {
            var json = '';
            var contentEncoding = res.headers['content-encoding'];
            var responseProxy;
            switch (contentEncoding){
                case 'gzip':
                    responseProxy = zlib.createGunzip();
                    res.pipe(responseProxy);
                    break;
                default:
                    responseProxy = res;
                    responseProxy.setEncoding('utf8');
                    break;
            }

            responseProxy.on('data', function (data) {
                json += data.toString();
            });

            responseProxy.on('end', function () {
                // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
                if (res.statusCode >= 200 && res.statusCode < 400) {
                    options.success(json, res);
                } else {
                    if (json) {
                        options.error({ responseText: json });
                    }
                    else { // empty response
                        var error = new Error('Response error.');
                        error.statusCode = res.statusCode;
                        options.error({ responseText: error });
                    }
                }
            });
        });

        req.on('error', function (e) {
            options.error({ responseText: e }); // TODO
        });

        if (options.data) {
            var contentEncoding = headers['content-encoding'];
            switch (contentEncoding){
                case 'gzip':
                    var buf = new Buffer(options.data, 'utf-8');
                    zlib.gzip(buf, function (err, result) {
                        req.end(result);
                    });
                    break;
                default:
                    req.end(options.data);
                    break;
            }
        }
        else {
            req.end();
        }
    }

    return reqwest;
}());
}).call(this,require("buffer").Buffer)

},{"buffer":"buffer","http":"http","https":"https","rsvp":1,"underscore":1,"url":"url","zlib":"zlib"}],63:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var rsvp = require('../common').rsvp;
var Request = require('../Request');
var idField = require('../constants').idField;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;
var _ = require('../common')._;

module.exports = (function () {
    function mergeResultData(data, success) {
        return function (res, response) {
            var attrs = res.result;
            // support for kendo observable array
            if (_.isArray(data) || typeof data.length === 'number') {
                _.each(data, function (item, index) {
                    _.extend(item, attrs[index]);
                });
            }
            else {
                _.extend(data, attrs);
            }

            success(res, response);
        };
    }

    function mergeUpdateResultData(data, success) {
        return function (res) {
            var modifiedAt = res.ModifiedAt;
            data.ModifiedAt = modifiedAt;
            success(res);
        };
    }

    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} setup
     * @param {string} collectionName
     * @protected
     */
    function Data(setup, collectionName, offlineStorage, everlive) {
        this.setup = setup;
        this.collectionName = collectionName;
        this.options = null;
        this.offlineStorage = offlineStorage;
        this.everlive = everlive;
    }


    Data.prototype = {
        _isOnline: function () {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        },

        _getOfflineCreateData: function (query, requestResponse) {
            var createData;
            if (_.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _.extend(query.data[i], requestResponse.result[i]);
                    createData.push(objectToCreate)
                }
            } else {
                createData = _.extend(query.data, requestResponse.result);
            }

            return createData;
        },
        _applyOffline: function (query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.setup.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case DataQuery.operations.read:
                    case DataQuery.operations.readById:
                        var syncReadQuery = new DataQuery(_.defaults({
                            data: requestResponse.result,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(syncReadQuery);
                    case DataQuery.operations.create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new DataQuery(_.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(createQuery);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new rsvp.Promise(function (resolve, reject) {
                resolve();
            });
        },

        _setOption: function (key, value) {
            this.options = this.options || {};
            if (_.isObject(value)) {
                this.options[key] = _.extend({}, this.options[key], value);
            } else {
                this.options[key] = value;
            }
            return this;
        },

        /**@memberOf Data.prototype
         * @method
         * Modifies whether the query should be invoked on the offline storage.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @param workOffline
         * @returns {Data}
         * */
        useOffline: function (useOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in useOffline() query modifier');
            }
            return this._setOption('useOffline', useOffline);
        },

        isSync: function (isSync) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in isSync() query modifier');
            }
            return this._setOption('isSync', isSync);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should invoke the {{@link Authentication.prototype.hasAuthenticationRequirement}}.
         * Default is false.
         * Only valid when authentication module has an onAuthenticationRequired function .
         * @param skipAuth
         * @returns {Data}
         * */
        skipAuth: function (skipAuth) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in skipAuth() query modifier');
            }
            return this._setOption('skipAuth', skipAuth);
        },

        /**
         * Modifies whether the query should be applied offline, if the sdk is currenty working online.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @memberOf Data.prototype
         * @method
         * @param applyOffline
         * @returns {Data}
         * */
        applyOffline: function (applyOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in applyOffline() query modifier');
            }
            return this._setOption('applyOffline', applyOffline);
        },

        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Non-Standard HTTP Headers]{{% slug rest-api-headers}} for more information.
         * @memberOf Data.prototype
         * @method
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */
        withHeaders: function (headers) {
            return this._setOption('headers', headers);
        },
        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Data}
         */
        expand: function (expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        },

        /**
         * Processes a query with all of its options. Applies the operation online/offline
         * @param {DataQuery} query The query to process
         * @private
         * @param {DataQuery} query
         * @returns {Promise}
         */
        processDataQuery: function (query) {
            var self = this;

            var offlineStorageEnabled = this.everlive._isOfflineStorageEnabled();
            query.useOffline = offlineStorageEnabled ? !this.everlive.isOnline() : false;
            query.applyOffline = offlineStorageEnabled;

            if (this.options) {
                query = _.defaults(this.options, query);
            }

            this.options = null;
            if (!query.skipAuth && this.everlive.authentication && this.everlive.authentication.isAuthenticationInProgress()) {
                query.onError = _.wrap(query.onError, function (errorFunc, err) {
                    if (err.code === EverliveErrors.invalidToken.code || err.code === EverliveErrors.expiredToken.code) {
                        var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                        if (!query.noRetry) {
                            whenAuthenticatedPromise.then(function () {
                                return self.processDataQuery(query);
                            });
                        }
                    } else {
                        errorFunc.call(self, err);
                    }
                });

                //if we are currently authenticating, queue the data query after we have logged in
                if (self.everlive.authentication.isAuthenticating()) {
                    var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                    if (!query.noRetry) {
                        whenAuthenticatedPromise.then(function () {
                            return self.processDataQuery(query);
                        });
                    }
                    return whenAuthenticatedPromise
                }
            }

            if ((!query.isSync && this.offlineStorage && this.offlineStorage.isSynchronizing())) {
                query.onError.call(this, EverliveErrors.syncInProgress);
            } else if (!query.useOffline) {
                var originalSuccess = query.onSuccess;
                query.onSuccess = function () {
                    var args = arguments;
                    var data = args[0];
                    if (query.applyOffline) {
                        return self._applyOffline(query, data)
                            .then(function () {
                                originalSuccess.apply(this, args);
                            }, function () {
                                query.onError.apply(this, arguments);
                            });
                    } else {
                        return originalSuccess.apply(this, args);
                    }
                };

                var getRequestOptionsFromQuery = RequestOptionsBuilder[query.operation];
                var requestOptions = getRequestOptionsFromQuery(query);
                var request = new Request(this.setup, requestOptions);
                request.send();
            } else {
                if (!query.applyOffline) {
                    return query.onError.call(this, new EverliveError('The applyOffline must be false when working offline.'));
                }

                self.offlineStorage.processQuery(query).then(function () {
                    query.onSuccess.apply(this, arguments);
                }, function (err) {
                    if (!err.code) {
                        err = new EverliveError(err.message, EverliveErrors.generalDatabaseError.code);
                    }
                    query.onError.call(this, err);
                });
            }
        },
        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        get: function (filter, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.read,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: successCb,
                    onError: errorCb
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */
        getById: function (id, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.readById,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    additionalOptions: {
                        id: id
                    },
                    onSuccess: successCb,
                    onError: errorCb
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        count: function (filter, success, error) {
            var self = this;

            return buildPromise(function (sucessCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.count,
                    collectionName: self.collectionName,
                    filter: filter,
                    parse: Request.parsers.single,
                    onSuccess: sucessCb,
                    onError: errorCb
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        create: function (data, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.create,
                    collectionName: self.collectionName,
                    data: data,
                    parse: Request.parsers.single,
                    onSuccess: mergeResultData(data, success),
                    onError: error
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updatedObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        rawUpdate: function (attrs, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.rawUpdate,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: attrs,
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO: Check if there is a case in which replace = true is passed to this function
        _update: function (attrs, filter, single, replace, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var data = {};
                data[replace ? '$replace' : '$set'] = attrs;

                // if the update is for a single item - merge the update result and add the ModifiedAt field to the result
                var onSuccess = single ? mergeUpdateResultData(attrs, success) : success;

                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.update,
                    collectionName: self.collectionName,
                    parse: Request.parsers.update,
                    filter: filter,
                    data: data,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    },
                    onSuccess: onSuccess,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        updateSingle: function (model, success, error) {
            return this._update(model, null, true, false, success, error);
        },

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        update: function (model, filter, success, error) {
            return this._update(model, filter, false, false, success, error);
        },
        _destroy: function (attrs, filter, single, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: single ? DataQuery.operations.removeSingle : DataQuery.operations.remove,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: success,
                    onError: error,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    }
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroySingle: function (model, success, error) {
            return this._destroy(model, null, true, success, error);
        },

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroy: function (filter, success, error) {
            return this._destroy(null, filter, false, success, error);
        },

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setAcl: function (acl, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setAcl,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    filter: filter,
                    additionalOptions: {
                        acl: acl
                    },
                    onSuccess: success,
                    onError: error
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.useOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setOwner: function (ownerId, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setOwner,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: {
                        Owner: ownerId
                    },
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        save: function (model, success, error) {
            var self = this;
            var isNew = this.isNew(model);

            return buildPromise(function (success, error) {
                function saveSuccess(res) {
                    res.type = isNew ? 'create' : 'update';
                    success(res);
                }

                function saveError(err) {
                    err.type = isNew ? 'create' : 'update';
                    error(err);
                }

                if (isNew) {
                    return self.create(model, saveSuccess, saveError);
                } else {
                    return self.updateSingle(model, saveSuccess, saveError);
                }
            }, success, error);
        },
        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method
         * @param model Item to check.
         * @returns {boolean}
         */
        isNew: function (model) {
            return typeof model[idField] === 'undefined';
        }
    };

    return Data;
}());

},{"../Everlive":35,"../EverliveError":36,"../Request":42,"../common":46,"../constants":47,"../query/DataQuery":56,"../query/RequestOptionsBuilder":59,"../utils":66}],64:[function(require,module,exports){
/**
 * @class Files
 * @protected
 * @extends Data
 */

var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var utils = require('../utils');

module.exports.addFilesFunctions = function addFilesFunctions(ns) {
    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */
    ns.getUploadUrl = function () {
        return utils.buildUrl(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */
    ns.getDownloadUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    ns._getUpdateUrl = function (fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */
    ns.getUpdateUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {string} file File contents in base64 encoding.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     * @returns {Promise} The promise for the request
     */
    ns.updateContent = function (fileId, file, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesUpdateContent,
                // the passed file content is base64 encoded
                data: file,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                onSuccess: success,
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @param operationParameters
     * @returns {Promise} The promise for the request
     */
    ns.getDownloadUrlById = function (fileId, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesGetDownloadUrlById,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                parse: Request.parsers.single,
                onSuccess: function (data) {
                    success(data.result.Uri);
                },
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };
};
},{"../Request":42,"../query/DataQuery":56,"../utils":66}],65:[function(require,module,exports){
/**
 * @class Users
 * @extends Data
 * @protected
 */

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var guardUnset = utils.guardUnset;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var _ = require('../common')._;
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports.addUsersFunctions = function addUsersFunctions(ns, everlive) {

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.register = function (username, password, attrs, success, error) {
        guardUnset(username, 'username');
        guardUnset(password, 'password');
        var user = {
            Username: username,
            Password: password
        };
        _.extend(user, attrs);
        return this.create(user, success, error);
    };

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.currentUser = function (success, error) {
        var self = this;
        var id = self.everlive._isOfflineStorageEnabled() && self.everlive.isOffline() ? self.everlive.setup.principalId : 'me';
        return buildPromise(function (success, error) {
            if (id === 'me' && !self.everlive.setup.token && !self.everlive.setup.masterKey || !id) {
                return success({result: null});
            }

            self.getById(id).then(function (res) {
                    if (typeof res.result !== 'undefined') {
                        success({result: res.result});
                    } else {
                        success({result: null});
                    }
                },
                function (err) {
                    if (self.everlive.authentication && self.everlive.authentication.isAuthenticationInProgress()) {
                        success({result: null});
                    } else if (err.code === 601) { // invalid request, i.e. the access token is missing
                        success({result: null});
                    } else if (err.code === 801) {
                        error(EverliveErrors.invalidToken);
                    } else {
                        error(err);
                    }
                }
            );
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.changePassword = function (username, password, newPassword, keepTokens, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            success = _.wrap(success, function (success, data) {
                if (data && data.result) {
                    if (!keepTokens) {
                        ns.clearAuthorization();
                    }
                }
                return success(data);
            });

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userChangePassword,
                collectionName: self.collectionName,
                data: {
                    Username: username,
                    Password: password,
                    NewPassword: newPassword
                },
                additionalOptions: {
                    keepTokens: keepTokens
                },
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(dataQuery)
        }, success, error)
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.login = function (username, password, success, error) {
        return everlive.authentication.login(username, password, success, error);

    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.logout = function (success, error) {
        return everlive.authentication.logout(success, error);

    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithFacebook = function (accessToken, success, error) {
        return everlive.authentication.loginWithFacebook(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithFacebook = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromFacebook = function (userId, success, error) {
        return ns._unlinkFromProvider('Facebook', userId, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithADFS = function (accessToken, success, error) {
        return everlive.authentication.loginWithADFS(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithADFS = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromADFS = function (userId, success, error) {
        return ns._unlinkFromProvider('ADFS', userId, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithLiveID = function (accessToken, success, error) {
        return everlive.authentication.loginWithLiveID(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithLiveID = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromLiveID = function (userId, success, error) {
        return ns._unlinkFromProvider('LiveID', userId, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithGoogle = function (accessToken, success, error) {
        return everlive.authentication.loginWithGoogle(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithGoogle = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromGoogle = function (userId, success, error) {
        return ns._unlinkFromProvider('Google', userId, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithTwitter = function (token, tokenSecret, success, error) {
        return everlive.authentication.loginWithTwitter(token, tokenSecret, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithTwitter = function (userId, token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromTwitter = function (userId, success, error) {
        return ns._unlinkFromProvider('Twitter', userId, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @deprecated
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    ns.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        everlive.authentication.setAuthorization(token, tokenType, principalId)
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @deprecated
     * @memberOf Users.prototype
     */
    ns.clearAuthorization = function clearAuthorization() {
        everlive.authentication.setAuthorization(null, null, null);
    };

    ns._linkWithProvider = function (identity, userId, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    id: userId
                },
                operation: DataQuery.operations.userLinkWithProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };

    ns._unlinkFromProvider = function (providerName, userId, success, error) {
        var identity = {
            Provider: providerName
        };
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    userId: userId
                },
                operation: DataQuery.operations.userUnlinkFromProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };
};
},{"../EverliveError":36,"../Request":42,"../common":46,"../query/DataQuery":56,"../utils":66}],66:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var common = require('./common');
var _ = common._;
var rsvp = common.rsvp;
var Everlive = require('./Everlive');
var isNodejs = require('./everlive.platform').isNodejs;

var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new EverliveError(message);
    }
};

utils.parseUtilities = {
    getReviver: function (parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        }
    },

    parseIsoDateString: function (string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                }
                else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(
                Date.UTC(
                    Number(match[1]), // year
                    (Number(match[3]) - 1) || 0, // month
                    Number(match[5]) || 0, // day
                    Number(match[7]) || 0, // hour
                    Number(match[8]) || 0, // minute
                    Number(match[10]) || 0, // second
                    Number(secondParts) || 0
                )
            );

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+")
                    offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function (string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function (obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && typeof value === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
        return obj;
    },

    traverseAndRevive: function (data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        return utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function (reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return {message: error.message, code: error.errorCode};
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function (reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if (typeof data === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function (data, additionalProperties) {
        if (data) {
            var result = {result: data.Result};
            _.extend(result, additionalProperties);
            return result;
        } else {
            return data;
        }
    },

    parseResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {count: data.Count});
    },

    parseSingleResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {ModifiedAt: data.ModifiedAt});
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = utils.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.getCallbacks = function (success, error) {
    var promise;
    var createPromise = function () {
        return new rsvp.Promise(function (resolve, reject) {
            success = function (data) {
                resolve(data);
            };
            error = function (error) {
                reject(error);
            };
        });
    };

    if (isNodejs) {
        // node js style continuation
        if (typeof success === 'function' && typeof error !== 'function') {
            var callback = success;
            success = function (data, response) {
                callback(null, data, response);
            };
            error = function (error) {
                callback(error);
            };
        } else if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    } else {
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    }

    return {promise: promise, success: success, error: error};
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    }
    else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return {Authorization: authHeaderValue};
    } else {
        return null;
    }
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.cloneDate = function (date) {
    return new Date(date);
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.apiKey) {
        url += setup.apiKey + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression);
    _.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (typeof expression[key] === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};


var unsupportedDbOperators = [
    '$geoWithin',
    '$geoIntersects',
    '$near',
    '$within',
    '$nearSphere'
];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _.intersection(dbOperators, unsupportedDbOperators);
};

module.exports = utils;

},{"./Everlive":35,"./EverliveError":36,"./common":46,"./everlive.platform":49}]},{},[50])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L21vZHMuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC10eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L25vZGVfbW9kdWxlcy90eXBlLWNvbXBvbmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvbW9uZ28tZXFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L29wcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9jcnlwdG9qcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvYWVzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9jaXBoZXItY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZW5jLWJhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZXZwa2RmLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9qc29uZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9tZDUuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvQ29uc3RhbnRzLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL0V4ZWN1dGlvblRyZWUuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvRXhwYW5kRXJyb3IuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvUHJvY2Vzc29yLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL1JlbGF0aW9uTm9kZS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9SZWxhdGlvblRyZWVCdWlsZGVyLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCJzcmMvQ3VycmVudERldmljZS5qcyIsInNyYy9FdmVybGl2ZS5qcyIsInNyYy9FdmVybGl2ZUVycm9yLmpzIiwic3JjL0V4cGFuZFByb2Nlc3Nvci5qcyIsInNyYy9FeHByZXNzaW9uLmpzIiwic3JjL0dlb1BvaW50LmpzIiwic3JjL0xvY2FsU3RvcmUuanMiLCJzcmMvUHVzaC5qcyIsInNyYy9SZXF1ZXN0LmpzIiwic3JjL1NldHVwLmpzIiwic3JjL2F1dGgvQXV0aGVudGljYXRpb24uanMiLCJzcmMvYXV0aC9BdXRoZW50aWNhdGlvblNldHVwLmpzIiwic3JjL2NvbW1vbi5qcyIsInNyYy9jb25zdGFudHMuanMiLCJzcmMvZW5jcnlwdGlvbi9DcnlwdG9ncmFwaGljUHJvdmlkZXIuanMiLCJzcmMvZXZlcmxpdmUucGxhdGZvcm0uanMiLCJzcmMvaW5kZXguanMiLCJzcmMva2VuZG8va2VuZG8uZXZlcmxpdmUuanMiLCJzcmMvb2ZmbGluZS9PZmZsaW5lU3RvcmFnZU1vZHVsZS5qcyIsInNyYy9vZmZsaW5lL29mZmxpbmUuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lUGVyc2lzdGVycy5qcyIsInNyYy9vZmZsaW5lL29mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuanMiLCJzcmMvcXVlcnkvRGF0YVF1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5QnVpbGRlci5qcyIsInNyYy9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXIuanMiLCJzcmMvcXVlcnkvV2hlcmVRdWVyeS5qcyIsInNyYy9yZXF3ZXN0Lm5hdGl2ZXNjcmlwdC5qcyIsInNyYy9yZXF3ZXN0Lm5vZGVqcy5qcyIsInNyYy90eXBlcy9EYXRhLmpzIiwic3JjL3R5cGVzL0ZpbGVzLmpzIiwic3JjL3R5cGVzL1VzZXJzLmpzIiwic3JjL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG9wcyA9IHJlcXVpcmUoJy4vb3BzJyk7XG52YXIgZXFsID0gcmVxdWlyZSgnbW9uZ28tZXFsJyk7XG52YXIgZG90ID0gcmVxdWlyZSgnZG90LWNvbXBvbmVudCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vbmdvLXF1ZXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmlsdGVyO1xuZXhwb3J0cy5vcHMgPSBvcHM7XG5cbi8qKlxuICogRmlsdGVycyBhbiBgb2JqYCBieSB0aGUgZ2l2ZW4gYHF1ZXJ5YCBmb3Igc3ViZG9jdW1lbnRzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHxCb29sZWFufSBmYWxzZSBpZiBubyBtYXRjaCwgb3IgbWF0Y2hlZCBzdWJkb2NzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIHF1ZXJ5KXtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICB2YXIgcmV0ID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblxuICAgIC8vIHNlYXJjaCB2YWx1ZVxuICAgIHZhciB2YWwgPSBxdWVyeVtrZXldO1xuXG4gICAgLy8gc3BsaXQgdGhlIGtleSBpbnRvIHByZWZpeCBhbmQgc3VmZml4XG4gICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICB2YXIgdGFyZ2V0ID0gb2JqO1xuICAgIHZhciBwcmVmaXgsIHNlYXJjaDtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgd2Fsa19rZXlzOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2tleXNbaV1dO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUodGFyZ2V0KSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgLy8gaWYgaXQncyBhbiBhcnJheSBzdWJkb2N1bWVudCBzZWFyY2ggd2Ugc3RvcCBoZXJlXG4gICAgICAgICAgcHJlZml4ID0ga2V5cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgICAgICAgIHNlYXJjaCA9IGtleXMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcblxuICAgICAgICAgIGRlYnVnKCdzZWFyY2hpbmcgYXJyYXkgXCIlc1wiJywgcHJlZml4KTtcblxuICAgICAgICAgIC8vIHdlIHNwZWNpYWwgY2FzZSBvcGVyYXRvcnMgdGhhdCBkb24ndCB3YWxrIHRoZSBhcnJheVxuICAgICAgICAgIGlmICh2YWwuJHNpemUgJiYgIXNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKHZhbCwgdGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3YWxrIHN1YmRvY3NcbiAgICAgICAgICB2YXIgc3Vic2V0ID0gcmV0W3ByZWZpeF0gfHwgdGFyZ2V0O1xuXG4gICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN1YnNldC5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBxID0ge307XG4gICAgICAgICAgICAgIHFbc2VhcmNoXSA9IHZhbDtcbiAgICAgICAgICAgICAgaWYgKCdvYmplY3QnID09IHR5cGUoc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnYXR0ZW1wdGluZyBzdWJkb2Mgc2VhcmNoIHdpdGggcXVlcnkgJWonLCBxKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKHN1YnNldFtpaV0sIHEpKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBpZ25vcmUgdGhlIHJldCB2YWx1ZSBvZiBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgIGlmICghcmV0W3ByZWZpeF0gfHwgIX5yZXRbcHJlZml4XS5pbmRleE9mKHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChzdWJzZXRbaWldKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdwZXJmb3JtaW5nIHNpbXBsZSBhcnJheSBpdGVtIHNlYXJjaCcpO1xuICAgICAgICAgICAgICBpZiAoY29tcGFyZSh2YWwsIHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRbcHJlZml4XSB8fCAhfnJldFtwcmVmaXhdLmluZGV4T2Yoc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChzdWJzZXRbaWldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldFtwcmVmaXhdID0gcmV0W3ByZWZpeF0gfHwgW107XG4gICAgICAgICAgICByZXRbcHJlZml4XS5wdXNoLmFwcGx5KHJldFtwcmVmaXhdLCBtYXRjaGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjb250aW51ZSB0aGUga2V5IHNlYXJjaFxuICAgICAgICAgIGJyZWFrIHdhbGtfa2V5cztcblxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgdGhlIGtleVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmIChudWxsICE9IGtleXNbaSArIDFdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wYXJlKHZhbCwgdGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghY29tcGFyZSh2YWwsIHRhcmdldCkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBnaXZlbiBtYXRjaGVyIHdpdGggdGhlIGRvY3VtZW50IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG1hdGNoZXJcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXJlKG1hdGNoZXIsIHZhbCl7XG4gIGlmICgnb2JqZWN0JyAhPSB0eXBlKG1hdGNoZXIpKSB7XG4gICAgcmV0dXJuIGVxbChtYXRjaGVyLCB2YWwpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBvYmplY3Qua2V5cyhtYXRjaGVyKTtcbiAgaWYgKCckJyA9PSBrZXlzWzBdWzBdKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHN1Yi1vYmplY3QgbWF0Y2hpbmdcbiAgICAgIGlmICgnJGVsZW1NYXRjaCcgPT0ga2V5c1tpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2UgIT09IGZpbHRlcih2YWwsIG1hdGNoZXIuJGVsZW1NYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW9wc1trZXlzW2ldXShtYXRjaGVyW2tleXNbaV1dLCB2YWwpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlcWwobWF0Y2hlciwgdmFsKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG1vZHMgPSByZXF1aXJlKCcuL21vZHMnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIGRvdCA9IHJlcXVpcmUoJ2RvdC1jb21wb25lbnQnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb25nby1xdWVyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHF1ZXJ5O1xuXG4vKipcbiAqIEV4cG9ydCBmaWx0ZXIgaGVscGVyLlxuICovXG5cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuXG4vKipcbiAqIEV4cG9ydCBtb2RpZmllcnMuXG4gKi9cblxuZXhwb3J0cy5tb2RzID0gbW9kcztcblxuLyoqXG4gKiBFeGVjdXRlIGEgcXVlcnkuXG4gKlxuICogT3B0aW9uczpcbiAqICAtIGBzdHJpY3RgIG9ubHkgbW9kaWZ5IGlmIHF1ZXJ5IG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIGFsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnkgdG8gZmlsdGVyIG1vZGlmaWNhdGlvbnMgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGUgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5KG9iaiwgcXVlcnksIHVwZGF0ZSwgb3B0cyl7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHF1ZXJ5ID0gcXVlcnkgfHwge307XG4gIHVwZGF0ZSA9IHVwZGF0ZSB8fCB7fTtcblxuICAvLyBzdHJpY3QgbW9kZVxuICB2YXIgc3RyaWN0ID0gISFvcHRzLnN0cmljdDtcblxuICB2YXIgbWF0Y2g7XG4gIHZhciBsb2cgPSBbXTtcblxuICBpZiAob2JqZWN0Lmxlbmd0aChxdWVyeSkpIHtcbiAgICBtYXRjaCA9IGZpbHRlcihvYmosIHF1ZXJ5KTtcbiAgfVxuXG4gIGlmICghc3RyaWN0IHx8IGZhbHNlICE9PSBtYXRjaCkge1xuICAgIHZhciBrZXlzID0gb2JqZWN0LmtleXModXBkYXRlKTtcbiAgICB2YXIgdHJhbnNhY3Rpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobW9kc1trZXlzW2ldXSkge1xuICAgICAgICBkZWJ1ZygnZm91bmQgbW9kaWZpZXIgXCIlc1wiJywga2V5c1tpXSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB1cGRhdGVba2V5c1tpXV0pIHtcbiAgICAgICAgICB2YXIgcG9zID0ga2V5LmluZGV4T2YoJy4kLicpO1xuXG4gICAgICAgICAgaWYgKH5wb3MpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBrZXkuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0ga2V5LnN1YnN0cihwb3MgKyAzKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoW3ByZWZpeF0pIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2V4ZWN1dGluZyBcIiVzXCIgJXMgb24gZmlyc3QgbWF0Y2ggd2l0aGluIFwiJXNcIicsIGtleSwga2V5c1tpXSwgcHJlZml4KTtcbiAgICAgICAgICAgICAgdmFyIGZuID0gbW9kc1trZXlzW2ldXShtYXRjaFtwcmVmaXhdWzBdLCBzdWZmaXgsIHVwZGF0ZVtrZXlzW2ldXVtrZXldKTtcbiAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjZSBhIGtleSBuYW1lIHJlcGxhY2luZyAkIHdpdGggdGhlIGFjdHVhbCBpbmRleFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgdW5uZWNlc3NhcmlseSBleHBlbnNpdmVcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBkb3QuZ2V0KG9iaiwgcHJlZml4KS5pbmRleE9mKG1hdGNoW3ByZWZpeF1bMF0pO1xuICAgICAgICAgICAgICAgIGZuLmtleSA9IHByZWZpeCArICcuJyArIGluZGV4ICsgJy4nICsgc3VmZml4O1xuICAgICAgICAgICAgICAgIGZuLm9wID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMucHVzaChmbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBcIiVzXCIgJXMgLSBubyBtYXRjaGVzIHdpdGhpbiBcIiVzXCInLCBrZXksIGtleXNbaV0sIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbiA9IG1vZHNba2V5c1tpXV0ob2JqLCBrZXksIHVwZGF0ZVtrZXlzW2ldXVtrZXldKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICBmbi5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgIGZuLm9wID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2goZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3NraXBwaW5nIHVua25vd24gbW9kaWZpZXIgXCIlc1wiJywga2V5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIHdlIGdvdCBoZXJlIGVycm9yIGZyZWUgd2UgcHJvY2VzcyBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm4gPSB0cmFuc2FjdGlvbnNbaV07XG4gICAgICAgIHZhciB2YWwgPSBmbigpO1xuICAgICAgICBsb2cucHVzaCh7IG9wOiBmbi5vcCwga2V5OiBmbi5rZXksIHZhbHVlOiB2YWwgfSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdubyBtYXRjaGVzIGZvciBxdWVyeSAlaicsIHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBsb2c7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZXFsID0gcmVxdWlyZSgnbW9uZ28tZXFsJyk7XG52YXIgZG90ID0gcmVxdWlyZSgnZG90LWNvbXBvbmVudCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jykua2V5cztcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vbmdvLXF1ZXJ5Jyk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHNldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHNldCA9IGZ1bmN0aW9uICRzZXQob2JqLCBwYXRoLCB2YWwpe1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKCFlcWwob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICBpZiAoIWVxbChvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCckc2V0IG9ubHkgc3VwcG9ydHMgb2JqZWN0IG5vdCAnICsgdHlwZShvYmopKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiBgJHVuc2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kdW5zZXQgPSBmdW5jdGlvbiAkdW5zZXQob2JqLCBwYXRoKXtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gcmVtaW5kZXI6IGBkZWxldGUgYXJyWzFdYCA9PT0gYGRlbGV0ZSBhcnJbJzEnXWAgWyFdXG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgZmFpbCBzaWxlbnRseVxuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgdW5zZXQgb2YgaW5leGlzdGluZyBrZXknKTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcmVuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kcmVuYW1lID0gZnVuY3Rpb24gJHJlbmFtZShvYmosIHBhdGgsIG5ld0tleSl7XG4gIC8vIHRhcmdldCA9IHNvdXJjZVxuICBpZiAocGF0aCA9PSBuZXdLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRyZW5hbWUgc291cmNlIG11c3QgZGlmZmVyIGZyb20gdGFyZ2V0Jyk7XG4gIH1cblxuICAvLyB0YXJnZXQgaXMgcGFyZW50IG9mIHNvdXJjZVxuICBpZiAoMCA9PT0gcGF0aC5pbmRleE9mKG5ld0tleSArICcuJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRyZW5hbWUgdGFyZ2V0IG1heSBub3QgYmUgYSBwYXJlbnQgb2Ygc291cmNlJyk7XG4gIH1cblxuICB2YXIgcCA9IGRvdC5wYXJlbnQob2JqLCBwYXRoKTtcbiAgdmFyIHQgPSB0eXBlKHApO1xuXG4gIGlmICgnb2JqZWN0JyA9PSB0KSB7XG4gICAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICAgIGlmIChwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdmFsID0gcFtrZXldO1xuICAgICAgICBkZWxldGUgcFtrZXldO1xuXG4gICAgICAgIC8vIHRhcmdldCBkb2VzIGluaXRpYWxpemUgdGhlIHBhdGhcbiAgICAgICAgdmFyIG5ld3AgPSBkb3QucGFyZW50KG9iaiwgbmV3S2V5LCB0cnVlKTtcblxuICAgICAgICAvLyBhbmQgYWxzbyBmYWlscyBzaWxlbnRseSB1cG9uIHR5cGUgbWlzbWF0Y2hcbiAgICAgICAgaWYgKCdvYmplY3QnID09IHR5cGUobmV3cCkpIHtcbiAgICAgICAgICBuZXdwW25ld0tleS5zcGxpdCgnLicpLnBvcCgpXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnaW52YWxpZCAkcmVuYW1lIHRhcmdldCBwYXRoIHR5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIG5ldyBrZXlcbiAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyByZW5hbWUgZnJvbSBpbmV4aXN0aW5nIHNvdXJjZScpO1xuICAgIH1cbiAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyAhPSB0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckcmVuYW1lIHNvdXJjZSBmaWVsZCBpbnZhbGlkJyk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYCRpbmNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRpbmMgPSBmdW5jdGlvbiAkaW5jKG9iaiwgcGF0aCwgaW5jKXtcbiAgaWYgKCdudW1iZXInICE9IHR5cGUoaW5jKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kaWZpZXIgJGluYyBhbGxvd2VkIGZvciBudW1iZXJzIG9ubHknKTtcbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRpbmMgbW9kaWZpZXIgdG8gbm9uLW51bWJlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gKz0gaW5jO1xuICAgICAgICAgIHJldHVybiBpbmM7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYoJ29iamVjdCcgPT0gdHlwZShvYmopIHx8IG51bWVyaWMoa2V5KSl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gaW5jO1xuICAgICAgICAgIHJldHVybiBpbmM7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRpbmMgbW9kaWZpZXIgdG8gbm9uLW51bWJlcicpO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGFuIGAkcG9wYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kcG9wID0gZnVuY3Rpb24gJHBvcChvYmosIHBhdGgsIHZhbCl7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICAvLyB3ZSBtYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBqdXN0IHRoZSBwYXJlbnQgb2YgdGhlIG1haW4ga2V5XG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIGlmIChvYmpba2V5XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYgKC0xID09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG1vbmdvZGIgYWxsb3dzIGFueSB2YWx1ZSB0byBwb3BcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XS5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcG9wIHRvIGluZXhpc3Rpbmcga2V5Jyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcG9wIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcG9wIHRvIGluZXhpc3Rpbmcga2V5Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9wIHRvIGluZXhpc3Rpbmcga2V5Jyk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVzaGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gcHVzaFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRwdXNoID0gZnVuY3Rpb24gJHB1c2gob2JqLCBwYXRoLCB2YWwpe1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1c2gvJHB1c2hBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1c2gvJHB1c2hBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1c2hBbGxgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIHRvIHB1c2hcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kcHVzaEFsbCA9IGZ1bmN0aW9uICRwdXNoQWxsKG9iaiwgcGF0aCwgdmFsKXtcbiAgaWYgKCdhcnJheScgIT0gdHlwZSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2RpZmllciAkcHVzaEFsbC9wdWxsQWxsIGFsbG93ZWQgZm9yIGFycmF5cyBvbmx5Jyk7XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XS5wdXNoLmFwcGx5KG9ialtrZXldLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2guYXBwbHkob2JqW2tleV0sIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1c2gvJHB1c2hBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdWxsYC5cbiAqL1xuXG5leHBvcnRzLiRwdWxsID0gZnVuY3Rpb24gJHB1bGwob2JqLCBwYXRoLCB2YWwpe1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIHZhciB0ID0gdHlwZShvYmopO1xuXG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB2YXIgcHVsbGVkID0gW107XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHB1bGwob2JqW2tleV0sIFt2YWxdLCBwdWxsZWQpO1xuICAgICAgICAgIGlmIChwdWxsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc3BsaWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwdWxsZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVsbC8kcHVsbEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB2YXIgcHVsbGVkID0gW107XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHB1bGwob2JqW2tleV0sIFt2YWxdLCBwdWxsZWQpO1xuICAgICAgICAgIGlmIChwdWxsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc3BsaWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwdWxsZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVsbC8kcHVsbEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHB1bGwgdG8gbm9uIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xFRlRfU1VCRklFTEQgb25seSBzdXBwb3J0cyBPYmplY3Q6IGhlbGxvIG5vdDogJyArIHQpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdWxsQWxsYC5cbiAqL1xuXG5leHBvcnRzLiRwdWxsQWxsID0gZnVuY3Rpb24gJHB1bGxBbGwob2JqLCBwYXRoLCB2YWwpe1xuICBpZiAoJ2FycmF5JyAhPSB0eXBlKHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGlmaWVyICRwdXNoQWxsL3B1bGxBbGwgYWxsb3dlZCBmb3IgYXJyYXlzIG9ubHknKTtcbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgdmFyIHQgPSB0eXBlKG9iaik7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgdmFsLCBwdWxsZWQpO1xuICAgICAgICAgIGlmIChwdWxsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc3BsaWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwdWxsZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVsbC8kcHVsbEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB2YXIgcHVsbGVkID0gW107XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHB1bGwob2JqW2tleV0sIHZhbCwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBwdWxsIHRvIG5vbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMRUZUX1NVQkZJRUxEIG9ubHkgc3VwcG9ydHMgT2JqZWN0OiBoZWxsbyBub3Q6ICcgKyB0KTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkYWRkVG9TZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIHB1c2hcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJuYWwsIHRydWUgaWYgcmVjdXJzaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJGFkZFRvU2V0ID0gZnVuY3Rpb24gJGFkZFRvU2V0KG9iaiwgcGF0aCwgdmFsLCByZWN1cnNpbmcpe1xuICBpZiAoIXJlY3Vyc2luZyAmJiAnYXJyYXknID09IHR5cGUodmFsLiRlYWNoKSkge1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbC4kZWFjaC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBmbiA9ICRhZGRUb1NldChvYmosIHBhdGgsIHZhbC4kZWFjaFtpXSwgdHJ1ZSk7XG4gICAgICBpZiAoZm4pIGZucy5wdXNoKGZuKTtcbiAgICB9XG4gICAgaWYgKGZucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB2YWx1ZXMucHVzaChmbnNbaV0oKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIGlmICghaGFzKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGFkZFRvU2V0IG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIGlmICghaGFzKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGFkZFRvU2V0IG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgaWYgYW4gYXJyYXkgaGFzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhcyhhcnJheSwgdmFsKXtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoZXFsKHZhbCwgYXJyYXlbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQXJyYXkjZmlsdGVyIGZ1bmN0aW9uIGdlbmVyYXRvciBmb3IgYCRwdWxsYC9gJHB1bGxBbGxgIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdmFsdWVzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSB0byBwb3B1bGF0ZSB3aXRoIHJlc3VsdHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGF0IHNwbGljZXMgdGhlIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gcHVsbChhcnIsIHZhbHMsIHB1bGxlZCl7XG4gIHZhciBpbmRleGVzID0gW107XG5cbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBhcnIubGVuZ3RoOyBhKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2FdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IHZhbHNbaV07XG4gICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZShtYXRjaGVyKSkge1xuICAgICAgICAvLyB3ZSBvbmx5IGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb2JqIDwtPiBvYmogY29tcGFyaXNvbnNcbiAgICAgICAgaWYgKCdvYmplY3QnID09IHR5cGUodmFsKSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGtleXMobWF0Y2hlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG1hdGNoZXIpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGF0IGxlYXN0IG9uZSBtYXRjaGluZyBrZXkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIGlmIChlcWwobWF0Y2hlcltpXSwgdmFsW2ldKSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBhIHNpbmdsZSBrZXkgZG9lc24ndCBtYXRjaCB3ZSBtb3ZlIG9uXG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgha2V5cyh2YWwpLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcHVsbCBge31gIG1hdGNoZXMgW3t9XVxuICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGEpO1xuICAgICAgICAgICAgcHVsbGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcHVsbCBtYXRjaCBhZ2FpbnN0IG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXFsKG1hdGNoZXIsIHZhbCkpIHtcbiAgICAgICAgICBpbmRleGVzLnB1c2goYSk7XG4gICAgICAgICAgcHVsbGVkLnB1c2godmFsKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tpXTtcbiAgICAgIGFyci5zcGxpY2UoaW5kZXggLSBpLCAxKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRldGVybWluZSBpZiBhIHZhbHVlIGlzIG51bWVyaWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBudW1lcmljXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBudW1lcmljKHZhbCl7XG4gIHJldHVybiAnbnVtYmVyJyA9PSB0eXBlKHZhbCkgfHwgTnVtYmVyKHZhbCkgPT0gdmFsO1xufVxuIiwiLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzogcmV0dXJuICdkYXRlJztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzogcmV0dXJuICdhcnJheSc7XG4gICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOiByZXR1cm4gJ2Vycm9yJztcbiAgfVxuXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsICE9PSB2YWwpIHJldHVybiAnbmFuJztcbiAgaWYgKHZhbCAmJiB2YWwubm9kZVR5cGUgPT09IDEpIHJldHVybiAnZWxlbWVudCc7XG5cbiAgdmFsID0gdmFsLnZhbHVlT2ZcbiAgICA/IHZhbC52YWx1ZU9mKClcbiAgICA6IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZi5hcHBseSh2YWwpXG5cbiAgcmV0dXJuIHR5cGVvZiB2YWw7XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBVc2UgY2hyb21lLnN0b3JhZ2UubG9jYWwgaWYgd2UgYXJlIGluIGFuIGFwcFxuICovXG5cbnZhciBzdG9yYWdlO1xuXG5pZiAodHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNocm9tZS5zdG9yYWdlICE9PSAndW5kZWZpbmVkJylcbiAgc3RvcmFnZSA9IGNocm9tZS5zdG9yYWdlLmxvY2FsO1xuZWxzZVxuICBzdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBzdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWNvbXBvbmVudCcpO1xuXG4vKipcbiAqIEdldHMgYSBjZXJ0YWluIGBwYXRoYCBmcm9tIHRoZSBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9IGZvdW5kIG9iamVjdCwgb3IgYHVuZGVmaW5lZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCl7XG4gIGlmICh+cGF0aC5pbmRleE9mKCcuJykpIHtcbiAgICB2YXIgcGFyID0gcGFyZW50KG9iaiwgcGF0aCk7XG4gICAgdmFyIG1haW5LZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgdmFyIHQgPSB0eXBlKHBhcik7XG4gICAgaWYgKCdvYmplY3QnID09IHQgfHwgJ2FycmF5JyA9PSB0KSByZXR1cm4gcGFyW21haW5LZXldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpbcGF0aF07XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZ2l2ZW4gYHBhdGhgIHRvIGB2YWxgIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBQYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgdmFsKXtcbiAgaWYgKH5wYXRoLmluZGV4T2YoJy4nKSkge1xuICAgIHZhciBwYXIgPSBwYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgICB2YXIgbWFpbktleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgICBpZiAocGFyICYmICdvYmplY3QnID09IHR5cGUocGFyKSkgcGFyW21haW5LZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgb2JqZWN0IGZvciBhIGdpdmVuIGtleSAoZG90IG5vdGF0aW9uIGF3YXJlKS5cbiAqXG4gKiAtIElmIGEgcGFyZW50IG9iamVjdCBkb2Vzbid0IGV4aXN0LCBpdCdzIGluaXRpYWxpemVkLlxuICogLSBBcnJheSBpbmRleCBsb29rdXAgaXMgc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCBzaG91bGQgaW5pdGlhbGl6ZSB0aGUgcGF0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcmVudCA9IHBhcmVudDtcblxuZnVuY3Rpb24gcGFyZW50KG9iaiwga2V5LCBpbml0KXtcbiAgaWYgKH5rZXkuaW5kZXhPZignLicpKSB7XG4gICAgdmFyIHBpZWNlcyA9IGtleS5zcGxpdCgnLicpO1xuICAgIHZhciByZXQgPSBvYmo7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIC8vIGlmIHRoZSBrZXkgaXMgYSBudW1iZXIgc3RyaW5nIGFuZCBwYXJlbnQgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChOdW1iZXIocGllY2VzW2ldKSA9PSBwaWVjZXNbaV0gJiYgJ2FycmF5JyA9PSB0eXBlKHJldCkpIHtcbiAgICAgICAgcmV0ID0gcmV0W3BpZWNlc1tpXV07XG4gICAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGUocmV0KSkge1xuICAgICAgICBpZiAoaW5pdCAmJiAhcmV0Lmhhc093blByb3BlcnR5KHBpZWNlc1tpXSkpIHtcbiAgICAgICAgICByZXRbcGllY2VzW2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQpIHJldCA9IHJldFtwaWVjZXNbaV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiXG4vKipcbiAqIHRvU3RyaW5nIHJlZi5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpe1xuICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzogcmV0dXJuICdmdW5jdGlvbic7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG4gICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6IHJldHVybiAnYXJndW1lbnRzJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IE9iamVjdCh2YWwpKSByZXR1cm4gJ29iamVjdCc7XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWw7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXFsO1xuXG4vKipcbiAqIE1vbmdvREIgc3R5bGUgdmFsdWUgY29tcGFyaXNvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGNoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IG1hdGNoXG4gKi9cblxuZnVuY3Rpb24gZXFsKG1hdGNoZXIsIHZhbCl7XG4gIHN3aXRjaCAodHlwZShtYXRjaGVyKSkge1xuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAvLyB3ZSB0cmVhdCBudWxsIGFzIHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIG51bGwgPT0gdmFsO1xuXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiBtYXRjaGVyLnRlc3QodmFsKTtcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmICgnYXJyYXknID09IHR5cGUodmFsKSAmJiBtYXRjaGVyLmxlbmd0aCA9PSB2YWwubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghZXFsKHZhbFtpXSwgbWF0Y2hlcltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIC8vIG9iamVjdCBjYW4gbWF0Y2gga2V5cyBpbiBhbnkgb3JkZXJcbiAgICAgIHZhciBrZXlzID0ge307XG5cbiAgICAgIC8vIHdlIG1hdGNoIGFsbCB2YWx1ZXMgb2YgYG1hdGNoZXJgIGluIGB2YWxgXG4gICAgICBmb3IgKHZhciBpIGluIG1hdGNoZXIpIHtcbiAgICAgICAgaWYgKG1hdGNoZXIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBpZiAoIXZhbC5oYXNPd25Qcm9wZXJ0eShpKSB8fCAhZXFsKG1hdGNoZXJbaV0sIHZhbFtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5c1tpXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIG1ha2Ugc3VyZSBgdmFsYCBkb2Vzbid0IGhhdmUgZXh0cmEga2V5c1xuICAgICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgICAgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAha2V5cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbWF0Y2hlciA9PT0gdmFsO1xuICB9XG59XG4iLCJcbi8qKlxuICogSE9QIHJlZi5cbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIGtleXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMua2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iail7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBvd24gdmFsdWVzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnZhbHVlcyA9IGZ1bmN0aW9uKG9iail7XG4gIHZhciB2YWxzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWxzLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbi8qKlxuICogTWVyZ2UgYGJgIGludG8gYGFgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbihhLCBiKXtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoaGFzLmNhbGwoYiwga2V5KSkge1xuICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxlbmd0aCBvZiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIGV4cG9ydHMua2V5cyhvYmopLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgZW1wdHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIDAgPT0gZXhwb3J0cy5sZW5ndGgob2JqKTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVxbCA9IHJlcXVpcmUoJ21vbmdvLWVxbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xuXG4vKipcbiAqICRuZTogbm90IGVxdWFsLlxuICovXG5cbmV4cG9ydHMuJG5lID0gZnVuY3Rpb24gJG5lKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiAhZXFsKG1hdGNoZXIsIHZhbCk7XG59O1xuXG4vKipcbiAqICRndDogZ3JlYXRlciB0aGFuLlxuICovXG5cbmV4cG9ydHMuJGd0ID0gZnVuY3Rpb24gJGd0KG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPiBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkZ3RlOiBncmVhdGVyIHRoYW4gZXF1YWwuXG4gKi9cblxuZXhwb3J0cy4kZ3RlID0gZnVuY3Rpb24gJGd0ZShtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsID49IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRsdDogbGVzcyB0aGFuLlxuICovXG5cbmV4cG9ydHMuJGx0ID0gZnVuY3Rpb24gJGx0KG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPCBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkbHRlOiBsZXNzIHRoYW4gZXF1YWwuXG4gKi9cblxuZXhwb3J0cy4kbHRlID0gZnVuY3Rpb24gJGx0ZShtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsIDw9IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRyZWdleDogc3VwcGx5IGEgcmVndWxhciBleHByZXNzaW9uIGFzIGEgc3RyaW5nLlxuICovXG5cbmV4cG9ydHMuJHJlZ2V4ID0gZnVuY3Rpb24gJHJlZ2V4KG1hdGNoZXIsIHZhbCl7XG4gIC8vIFRPRE86IGFkZCAkb3B0aW9ucyBzdXBwb3J0XG4gIGlmICgncmVnZXhwJyAhPSB0eXBlKCdtYXRjaGVyJykpIG1hdGNoZXIgPSBuZXcgUmVnRXhwKG1hdGNoZXIpO1xuICByZXR1cm4gbWF0Y2hlci50ZXN0KHZhbCk7XG59O1xuXG4vKipcbiAqICRleGlzdHM6IGtleSBleGlzdHMuXG4gKi9cblxuZXhwb3J0cy4kZXhpc3RzID0gZnVuY3Rpb24gJGV4aXN0cyhtYXRjaGVyLCB2YWwpe1xuICBpZiAobWF0Y2hlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQgIT09IHZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkID09PSB2YWw7XG4gIH1cbn07XG5cbi8qKlxuICogJGluOiB2YWx1ZSBpbiBhcnJheS5cbiAqL1xuXG5leHBvcnRzLiRpbiA9IGZ1bmN0aW9uICRpbihtYXRjaGVyLCB2YWwpe1xuICBpZiAoJ2FycmF5JyAhPSB0eXBlKG1hdGNoZXIpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlcWwobWF0Y2hlcltpXSwgdmFsKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiAkbmluOiB2YWx1ZSBub3QgaW4gYXJyYXkuXG4gKi9cblxuZXhwb3J0cy4kbmluID0gZnVuY3Rpb24gJG5pbihtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gIWV4cG9ydHMuJGluKG1hdGNoZXIsIHZhbCk7XG59O1xuXG4vKipcbiAqIEBzaXplOiBhcnJheSBsZW5ndGhcbiAqL1xuXG5leHBvcnRzLiRzaXplID0gZnVuY3Rpb24obWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSAmJiBtYXRjaGVyID09IHZhbC5sZW5ndGg7XG59O1xuIiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9saWIvY29yZScpLkNyeXB0b0pTO1xucmVxdWlyZSgnLi9saWIvZW5jLWJhc2U2NCcpO1xucmVxdWlyZSgnLi9saWIvbWQ1Jyk7XG5yZXF1aXJlKCcuL2xpYi9ldnBrZGYnKTtcbnJlcXVpcmUoJy4vbGliL2NpcGhlci1jb3JlJyk7XG5yZXF1aXJlKCcuL2xpYi9hZXMnKTtcbnZhciBKc29uRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9saWIvanNvbmZvcm1hdHRlcicpLkpzb25Gb3JtYXR0ZXI7XG5cbmV4cG9ydHMuQ3J5cHRvSlMgPSBDcnlwdG9KUztcbmV4cG9ydHMuSnNvbkZvcm1hdHRlciA9IEpzb25Gb3JtYXR0ZXI7IiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XHJcblxyXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuXHJcbiAgICAvLyBMb29rdXAgdGFibGVzXHJcbiAgICB2YXIgU0JPWCA9IFtdO1xyXG4gICAgdmFyIElOVl9TQk9YID0gW107XHJcbiAgICB2YXIgU1VCX01JWF8wID0gW107XHJcbiAgICB2YXIgU1VCX01JWF8xID0gW107XHJcbiAgICB2YXIgU1VCX01JWF8yID0gW107XHJcbiAgICB2YXIgU1VCX01JWF8zID0gW107XHJcbiAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcclxuICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XHJcbiAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xyXG5cclxuICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxyXG4gICAgICAgIHZhciBkID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xyXG4gICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXYWxrIEdGKDJeOClcclxuICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgdmFyIHhpID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxyXG4gICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcclxuICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xyXG4gICAgICAgICAgICBTQk9YW3hdID0gc3g7XHJcbiAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XHJcbiAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xyXG4gICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcclxuICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XHJcbiAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XHJcbiAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XHJcbiAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcclxuICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XHJcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XHJcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcclxuICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcclxuICAgICAgICAgICAgaWYgKCF4KSB7XHJcbiAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcclxuICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxyXG4gICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cclxuICAgICAqL1xyXG4gICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xyXG4gICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xyXG4gICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNlxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcclxuICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcclxuICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxyXG4gICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xyXG4gICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXHJcbiAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XHJcbiAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcclxuICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xyXG4gICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XHJcbiAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxyXG4gICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRzXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XHJcbiAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBzMCA9IHQwO1xyXG4gICAgICAgICAgICAgICAgczEgPSB0MTtcclxuICAgICAgICAgICAgICAgIHMyID0gdDI7XHJcbiAgICAgICAgICAgICAgICBzMyA9IHQzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcclxuICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgb3V0cHV0XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0MztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBrZXlTaXplOiAyNTYvMzJcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xyXG4gICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xyXG4gICAgICovXHJcbiAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcclxufSgpKTtcclxuIiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XHJcblxyXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKlxyXG4gKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxyXG4gKi9cclxuQ3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG4gICAgdmFyIENfbGliID0gQy5saWI7XHJcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XHJcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG4gICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xyXG4gICAgdmFyIENfZW5jID0gQy5lbmM7XHJcbiAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XHJcbiAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxyXG4gICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxyXG4gICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xyXG4gICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gQXBwZW5kXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXHJcbiAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXHJcbiAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGtleVNpemU6IDEyOC8zMixcclxuXHJcbiAgICAgICAgaXZTaXplOiAxMjgvMzIsXHJcblxyXG4gICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcclxuXHJcbiAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KCkpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxyXG4gICAgICovXHJcbiAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XHJcbiAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xyXG4gICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmxvY2tTaXplOiAxXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGUgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcclxuICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcclxuICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxyXG4gICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xyXG4gICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcclxuICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1JcclxuICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcclxuXHJcbiAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcclxuICAgICAgICAgICAgaWYgKGl2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBpdjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENCQztcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcclxuICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcclxuICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXHJcbiAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xyXG4gICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICovXHJcbiAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIG1vZGU6IENCQyxcclxuICAgICAgICAgICAgcGFkZGluZzogUGtjczdcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXHJcbiAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcclxuICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xyXG4gICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcclxuICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluYWxpemVcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcclxuICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcclxuICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxyXG4gICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXHJcbiAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcclxuICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcclxuICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcclxuICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxyXG4gICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXHJcbiAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXHJcbiAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXHJcbiAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXHJcbiAgICAgKi9cclxuICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xyXG4gICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xyXG5cclxuICAgICAgICAgICAgLy8gRm9ybWF0XHJcbiAgICAgICAgICAgIGlmIChzYWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcclxuICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XHJcblxyXG4gICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XHJcbiAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xyXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcclxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbmNyeXB0XHJcbiAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXHJcbiAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXHJcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcclxuICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXHJcbiAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlY3J5cHRcclxuICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXHJcbiAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcclxuICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxyXG4gICAgICAgICAgICBpZiAoIXNhbHQpIHtcclxuICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxyXG4gICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXHJcbiAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcclxuICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXHJcbiAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxyXG4gICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcclxuICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xyXG4gICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xyXG5cclxuICAgICAgICAgICAgLy8gRW5jcnlwdFxyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xyXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcclxuICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcclxuICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcclxuXHJcbiAgICAgICAgICAgIC8vIERlY3J5cHRcclxuICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0oKSk7XHJcbiIsIi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqXHJcbiAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cclxuICovXHJcbnZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGF3blxyXG4gICAgICAgICAgICAgICAgRi5wcm90b3R5cGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBuZXcgRigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcclxuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcclxuICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3RcclxuICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcclxuICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cclxuICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cclxuICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxyXG4gICAgICAgICAgICAgKiAgICAgICAgIH1cclxuICAgICAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcclxuICAgICAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcclxuICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3JkcztcclxuICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3JkcztcclxuICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XHJcbiAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xyXG4gICAgICAgICAgICB0aGlzLmNsYW1wKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25jYXRcclxuICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdFdvcmRzLmxlbmd0aCA+IDB4ZmZmZikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgYWxsIHdvcmRzIGF0IG9uY2VcclxuICAgICAgICAgICAgICAgIHRoaXNXb3Jkcy5wdXNoLmFwcGx5KHRoaXNXb3JkcywgdGhhdFdvcmRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENoYWluYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGFtcFxyXG4gICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xyXG4gICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgd29yZHMucHVzaCgoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlciBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXHJcbiAgICAgKi9cclxuICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcclxuICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydFxyXG4gICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRcclxuICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXHJcbiAgICAgKi9cclxuICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcclxuICAgICAqL1xyXG4gICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcclxuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmRcclxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xyXG4gICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcclxuICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xyXG4gICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXHJcbiAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcclxuICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcclxuICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3NcclxuICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcclxuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcclxuICAgICAqL1xyXG4gICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXHJcbiAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXHJcbiAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcclxuICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gQXBwZW5kXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGFpbmFibGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcclxuICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcclxuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xyXG5cclxuICAgIHJldHVybiBDO1xyXG59KE1hdGgpKTtcclxuXHJcbmV4cG9ydHMuQ3J5cHRvSlMgPSBDcnlwdG9KUztcclxuIiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XG5cbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xuICAgIHZhciBDX2xpYiA9IEMubGliO1xuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG4gICAgdmFyIENfZW5jID0gQy5lbmM7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAgICAgKi9cbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG4gICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG4gICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcbiAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnRcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5CeXRlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRzMSA9IG1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaSAtIDEpKSA8PCAoKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0czIgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkpKSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcbiAgICB9O1xufSgpKTtcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG4gICAgdmFyIENfbGliID0gQy5saWI7XHJcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XHJcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXHJcbiAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxyXG4gICAgICovXHJcbiAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxyXG4gICAgICAgICAgICBoYXNoZXI6IE1ENSxcclxuICAgICAgICAgICAgaXRlcmF0aW9uczogMVxyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XHJcbiAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xyXG4gICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXHJcbiAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcclxuICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xyXG4gICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcclxuICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XHJcbiAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xyXG4gICAgICovXHJcbiAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcclxuICAgIH07XHJcbn0oKSk7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xuXG4vLyBjcmVhdGUgY3VzdG9tIGpzb24gc2VyaWFsaXphdGlvbiBmb3JtYXRcbnZhciBKc29uRm9ybWF0dGVyID0ge1xuXHRzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0XHQvLyBjcmVhdGUganNvbiBvYmplY3Qgd2l0aCBjaXBoZXJ0ZXh0XG5cdFx0dmFyIGpzb25PYmogPSB7XG5cdFx0XHRjdDogY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkJhc2U2NClcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG9wdGlvbmFsbHkgYWRkIGl2IGFuZCBzYWx0XG5cdFx0aWYgKGNpcGhlclBhcmFtcy5pdikge1xuXHRcdFx0anNvbk9iai5pdiA9IGNpcGhlclBhcmFtcy5pdi50b1N0cmluZygpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoY2lwaGVyUGFyYW1zLnNhbHQpIHtcblx0XHRcdGpzb25PYmoucyA9IGNpcGhlclBhcmFtcy5zYWx0LnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0Ly8gc3RyaW5naWZ5IGpzb24gb2JqZWN0XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb25PYmopXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uIChqc29uU3RyKSB7XG5cdFx0Ly8gcGFyc2UganNvbiBzdHJpbmdcblx0XHR2YXIganNvbk9iaiA9IEpTT04ucGFyc2UoanNvblN0cik7XG5cdFx0XG5cdFx0Ly8gZXh0cmFjdCBjaXBoZXJ0ZXh0IGZyb20ganNvbiBvYmplY3QsIGFuZCBjcmVhdGUgY2lwaGVyIHBhcmFtcyBvYmplY3Rcblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHRcdFx0Y2lwaGVydGV4dDogQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShqc29uT2JqLmN0KVxuXHRcdH0pO1xuXHRcdFxuXHRcdC8vIG9wdGlvbmFsbHkgZXh0cmFjdCBpdiBhbmQgc2FsdFxuXHRcdGlmIChqc29uT2JqLml2KSB7XG5cdFx0XHRjaXBoZXJQYXJhbXMuaXYgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGpzb25PYmouaXYpO1xuXHRcdH1cbiAgICAgICAgICAgIFxuXHRcdGlmIChqc29uT2JqLnMpIHtcblx0XHRcdGNpcGhlclBhcmFtcy5zYWx0ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShqc29uT2JqLnMpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY2lwaGVyUGFyYW1zO1xuXHR9XG59O1xuXG5leHBvcnRzLkpzb25Gb3JtYXR0ZXIgPSBKc29uRm9ybWF0dGVyOyIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKE1hdGgpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XHJcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuICAgIC8vIENvbnN0YW50cyB0YWJsZVxyXG4gICAgdmFyIFQgPSBbXTtcclxuXHJcbiAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcclxuICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxyXG4gICAgICovXHJcbiAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xyXG4gICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xyXG4gICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcclxuICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xyXG4gICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcclxuXHJcbiAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcclxuICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxyXG4gICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcclxuXHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XHJcblxyXG4gICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xyXG4gICAgICAgICAgICB2YXIgYSA9IEhbMF07XHJcbiAgICAgICAgICAgIHZhciBiID0gSFsxXTtcclxuICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xyXG4gICAgICAgICAgICB2YXIgZCA9IEhbM107XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRhdGlvblxyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcclxuICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XHJcbiAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xyXG4gICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcclxuICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xyXG4gICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XHJcbiAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xyXG4gICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xyXG4gICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XHJcbiAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcclxuICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xyXG4gICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XHJcbiAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcclxuXHJcbiAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcclxuICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xyXG4gICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XHJcbiAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcclxuICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xyXG4gICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XHJcbiAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcclxuICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XHJcbiAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcclxuICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xyXG4gICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XHJcbiAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcclxuXHJcbiAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcclxuICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xyXG4gICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XHJcbiAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcclxuICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xyXG4gICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XHJcbiAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcclxuICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XHJcbiAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcclxuICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xyXG4gICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XHJcbiAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcclxuXHJcbiAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcclxuICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xyXG4gICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XHJcbiAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcclxuICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xyXG4gICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XHJcbiAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcclxuICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XHJcbiAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcclxuICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xyXG4gICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XHJcbiAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXHJcbiAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcclxuICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xyXG4gICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XHJcbiAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcclxuXHJcbiAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XHJcbiAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xyXG4gICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxyXG4gICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxyXG4gICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XHJcbiAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcclxuXHJcbiAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcclxuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xyXG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcclxuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcclxuICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xyXG4gICAgICovXHJcbiAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXHJcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcclxuICAgICAqL1xyXG4gICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XHJcbn0oTWF0aCkpO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBDb25zdGFudHMgPSB7fTtcclxuQ29uc3RhbnRzLkRlZmF1bHRUYWtlSXRlbXNDb3VudCA9IDUwO1xyXG5Db25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWUgPSAnRXhwYW5kJztcclxuQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lID0gJ1JldHVybkFzJztcclxuQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lID0gJ0ZpZWxkcyc7XHJcbkNvbnN0YW50cy5TaW5nbGVGaWVsZEV4cHJlc3Npb25OYW1lID0gJ1NpbmdsZUZpZWxkJztcclxuQ29uc3RhbnRzLlNvcnRFeHByZXNzaW9uTmFtZSA9ICdTb3J0JztcclxuQ29uc3RhbnRzLkZpbHRlckV4cHJlc3Npb25OYW1lID0gJ0ZpbHRlcic7XHJcbkNvbnN0YW50cy5Ta2lwRXhwcmVzc2lvbk5hbWUgPSAnU2tpcCc7XHJcbkNvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWUgPSAnVGFrZSc7XHJcbkNvbnN0YW50cy5QYXJlbnRSZWxhdGlvbkZpZWxkTmFtZSA9ICdQYXJlbnRSZWxhdGlvbkZpZWxkJztcclxuQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50ID0gJ0lkJztcclxuQ29uc3RhbnRzLlRhcmdldFR5cGVOYW1lRmllbGROYW1lID0gJ1RhcmdldFR5cGVOYW1lJztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RhbnRzOyIsIid1c2Ugc3RyaWN0JztcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcblxyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gZ2V0IGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBwcm9jZXNzIGEgc2V0IG9mIHJlbGF0aW9ucy5cclxuICogQHBhcmFtIHBhcmVudCAtIEFuIEV4ZWN1dGlvbk5vZGUgaW5zdGFuY2UgdXNlZCB0byBzdXBwbHkgdGhlIHRyZWUgbGlrZSBkYXRhIHN0cnVjdHVyZS5cclxuICogQHBhcmFtIHJlbGF0aW9uTm9kZSAtIFRoZSByZWxhdGlvbiBub2RlIHVzZWQgdG8gY3JlYXRlZCB0aGUgRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSAoRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSBzaG91bGQgY29udGFpbiBvbmUgb3IgbWFueSByZWxhdGlvbnNcclxuICogaWYgdGhleSBjYW4gYmUgY29tYmluZWQgZm9yIGJhdGNoIGV4ZWN1dGlvbikuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCByZWxhdGlvbk5vZGUpIHtcclxuICAgIHZhciBwYXJlbnRQYXRoID0gJyc7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50UGF0aCA9IHBhcmVudC5wYXRoO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRQYXRoO1xyXG4gICAgdGhpcy5yZWxhdGlvbnMgPSBbcmVsYXRpb25Ob2RlLnBhdGhdO1xyXG4gICAgdGhpcy5uYW1lID0gcmVsYXRpb25Ob2RlLnBhdGg7XHJcbiAgICB0aGlzLnRhcmdldFR5cGVOYW1lID0gcmVsYXRpb25Ob2RlLnRhcmdldFR5cGVOYW1lO1xyXG4gICAgdGhpcy5jYW5BZGRPdGhlclJlbGF0aW9ucyA9ICFyZWxhdGlvbk5vZGUuZmlsdGVyRXhwcmVzc2lvbiAmJiAhcmVsYXRpb25Ob2RlLnNvcnRFeHByZXNzaW9uICYmICFyZWxhdGlvbk5vZGUudGFrZSAmJiAhcmVsYXRpb25Ob2RlLnNraXA7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB2YXIgcGF0aCA9ICcnO1xyXG4gICAgaWYgKHBhcmVudFBhdGgpIHtcclxuICAgICAgICBwYXRoICs9IHBhcmVudFBhdGggKyAnLic7XHJcbiAgICB9XHJcbiAgICBwYXRoICs9IHJlbGF0aW9uTm9kZS50YXJnZXRUeXBlTmFtZTtcclxuICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhIFJlbGF0aW9uTm9kZSB0byBhbiBFeGVjdXRpb25Ob2RlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxyXG4gKi9cclxuRXhlY3V0aW9uTm9kZS5wcm90b3R5cGUuaW5zZXJ0UmVsYXRpb25Ob2RlID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICB0aGlzLnJlbGF0aW9ucy5wdXNoKHJlbGF0aW9uLnBhdGgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc2VydHMgYSBjaGlsZCBub2RlICh3aGljaCByZWxhdGlvbnMpIGRlcGVuZHMgZnJvbSBwYXJlbnQgbm9kZSByZXN1bHQuXHJcbiAqIEBwYXJhbSBjaGlsZCAtIEV4ZWN1dGlvbk5vZGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIGNoaWxkIG5vZGUuXHJcbiAqL1xyXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5pbnNlcnRDaGlsZHJlbk5vZGUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZC5uYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgbWV0aG9kIHRoYXQgY2hlY2tzIGlmIHNvbWUgcmVsYXRpb25zIGNvdWxkIGJlIGNvbWJpbmVkIChmb3IgZXhhbXBsZSBoYXZlIHNhbWUgVGFyZ2V0VHlwZSkuXHJcbiAqIEBwYXJhbSByZWxhdGlvblxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkV4ZWN1dGlvbk5vZGUucHJvdG90eXBlLmNhbkNvbWJpbmVXaXRoUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIGlmICghdGhpcy5jYW5BZGRPdGhlclJlbGF0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy50YXJnZXRUeXBlTmFtZSA9PT0gcmVsYXRpb24udGFyZ2V0VHlwZU5hbWUgJiYgIXJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnNvcnRFeHByZXNzaW9uICYmICFyZWxhdGlvbi50YWtlICYmICFyZWxhdGlvbi5za2lwO1xyXG59O1xyXG5cclxuLyoqIEV4ZWN1dGlvblRyZWVcclxuICogQ2xhc3MgdGhhdCBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGFuIGV4ZWN1dGlvbiB0cmVlIGZyb20gYSByZWxhdGlvblRyZWUuIFVzZWQgdG8gcHJvY2VzcyBhbGwgcXVlcmllcyAobWFzdGVyIGFuZCBjaGlsZCkgaW4gYSBjb3JyZWN0IG9yZGVyLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25UcmVlIC0gQW4gaW5zdGFuY2Ugb2YgcmVsYXRpb24gdHJlZS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uVHJlZSA9IGZ1bmN0aW9uIChyZWxhdGlvblRyZWUpIHtcclxuICAgIHRoaXMuX3JlbGF0aW9uVHJlZSA9IHJlbGF0aW9uVHJlZTtcclxuICAgIHRoaXMuX21hcCA9IHt9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgZXhlY3V0aW9uIG5vZGUgdG8gdGhlIEV4ZWN1dGlvblRyZWUuXHJcbiAqIEBwYXJhbSBleGVjdXRpb25Ob2RlXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5hZGRFeGVjdXRpb25Ob2RlID0gZnVuY3Rpb24gKGV4ZWN1dGlvbk5vZGUpIHtcclxuICAgIHRoaXMuX21hcFtleGVjdXRpb25Ob2RlLm5hbWVdID0gZXhlY3V0aW9uTm9kZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgRXhlY3V0aW9uTm9kZSB3aGljaCBjb250YWlucyB0aGUgcmVxdWVzdGVkIHJlbGF0aW9uLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldEV4ZWN1dGlvbk5vZGVPZlJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBmb3IgKHZhciBleGVjTm9kZSBpbiB0aGlzLl9tYXApIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFwLmhhc093blByb3BlcnR5KGV4ZWNOb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwW2V4ZWNOb2RlXS5yZWxhdGlvbnMuaW5kZXhPZihyZWxhdGlvbikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtleGVjTm9kZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kcyBhIFJlbGF0aW9uTm9kZSB3aXRoaW4gdGhlIFJlbGF0aW9uVHJlZS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVsYXRpb24gd2l0aGluIHRoZSBSZWxhdGlvblRyZWUgKGZvciBleGFtcGxlOiBBY3Rpdml0aWVzLkxpa2VzLlJvbGUpLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJlbGF0aW9uTm9kZSA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgaWYgKHJlbGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uVHJlZVtyZWxhdGlvbl0gfHwgbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRSb290UmVsYXRpb25Ob2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uVHJlZVt0aGlzLl9yZWxhdGlvblRyZWUuJHJvb3RdIHx8IG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIEV4ZWN1dGlvblRyZWUgZnJvbSBhIFJlbGF0aW9uVHJlZS5cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy9idWlsZCBiZWdpbm5pbmcgZnJvbSB0aGUgcm9vdFxyXG4gICAgdmFyIHJlbGF0aW9uUm9vdCA9IHRoaXMuZ2V0UmVsYXRpb25Ob2RlKHRoaXMuX3JlbGF0aW9uVHJlZS4kcm9vdCk7XHJcbiAgICAvL1NldHVwIHRoZSByb290IG9mIHRoZSBleGVjdXRpb24gdHJlZS5cclxuICAgIHZhciByb290RXhlY3V0aW9uTm9kZSA9IG5ldyBFeGVjdXRpb25Ob2RlKG51bGwsIHJlbGF0aW9uUm9vdCk7Ly9ubyBwYXJlbnQgbm9kZVxyXG4gICAgdGhpcy5hZGRFeGVjdXRpb25Ob2RlKHJvb3RFeGVjdXRpb25Ob2RlKTtcclxuICAgIHRoaXMuYnVpbGRJbnRlcm5hbChyZWxhdGlvblJvb3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYXZlcnNlIHRoZSByZWxhdGlvbiB0cmVlIGFuZCBidWlsZCB0aGUgZXhlY3V0aW9uIHRyZWUuXHJcbiAqIEBwYXJhbSByZWxhdGlvblJvb3QgLSBUaGUgcm9vdCBub2RlIG9mIHRoZSBSZWxhdGlvblRyZWUuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5idWlsZEludGVybmFsID0gZnVuY3Rpb24gKHJlbGF0aW9uUm9vdCkge1xyXG4gICAgcmVsYXRpb25Sb290LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkUmVsYXRpb25Ob2RlID0gdGhpcy5nZXRSZWxhdGlvbk5vZGUoY2hpbGQpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0UmVsYXRpb25Ob2RlSW5FeGVjdXRpb25UcmVlKGNoaWxkUmVsYXRpb25Ob2RlKTtcclxuICAgICAgICB0aGlzLmJ1aWxkSW50ZXJuYWwoY2hpbGRSZWxhdGlvbk5vZGUpO1xyXG4gICAgfSwgdGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhIHJlbGF0aW9uIG5vZGUgd2l0aGluIHRoZSBleGVjdXRpb24gdHJlZSAoYmFzZWQgb24gaXRzIGRlcGVuZGVuY2llcykuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWQuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGVJbkV4ZWN1dGlvblRyZWUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHZhciByb290RXhlY3V0aW9uTm9kZSA9IHRoaXMuZ2V0RXhlY3V0aW9uTm9kZU9mUmVsYXRpb24ocmVsYXRpb24ucGFyZW50KTtcclxuICAgIHZhciBjaGlsZFRvQ29tYmluZSA9IHRoaXMudHJ5R2V0Q2hpbGROb2RlVG9Db21iaW5lKHJvb3RFeGVjdXRpb25Ob2RlLCByZWxhdGlvbik7XHJcbiAgICBpZiAoY2hpbGRUb0NvbWJpbmUpIHsvL2lmIHRoZXJlIGlzIGEgY2hpbGQgdGhhdCB3ZSBjb21iaW5lIHRoZSByZWxhdGlvblxyXG4gICAgICAgIGNoaWxkVG9Db21iaW5lLmluc2VydFJlbGF0aW9uTm9kZShyZWxhdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBuZXdFeGVjdXRpb25Ob2RlID0gbmV3IEV4ZWN1dGlvbk5vZGUocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKTsvL2NyZWF0ZSBhIHNlcGFyYXRlIGV4ZWN1dGlvbiBub2RlIHRoYXQgd2lsbCBob3N0IHRoZSByZWxhdGlvblxyXG4gICAgICAgIHJvb3RFeGVjdXRpb25Ob2RlLmluc2VydENoaWxkcmVuTm9kZShuZXdFeGVjdXRpb25Ob2RlKTtcclxuICAgICAgICB0aGlzLmFkZEV4ZWN1dGlvbk5vZGUobmV3RXhlY3V0aW9uTm9kZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gZmluZCBhbiBFeGVjdXRpb25Ob2RlIHdoaWNoIGNvdWxkIGJlIGNvbWJpbmVkIHdpdGggYSByZWxhdGlvbi5cclxuICogQHBhcmFtIHJvb3RFeGVjdXRpb25Ob2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgRXhlY3V0aW9uVHJlZS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gUmVsYXRpb24gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBFeGVjdXRpb25UcmVlLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLnRyeUdldENoaWxkTm9kZVRvQ29tYmluZSA9IGZ1bmN0aW9uIChyb290RXhlY3V0aW9uTm9kZSwgcmVsYXRpb24pIHtcclxuICAgIGlmIChyb290RXhlY3V0aW9uTm9kZS5jYW5Db21iaW5lV2l0aFJlbGF0aW9uKHJlbGF0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiByb290RXhlY3V0aW9uTm9kZTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZHJlbiA9IHJvb3RFeGVjdXRpb25Ob2RlLmNoaWxkcmVuO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX21hcFtjaGlsZHJlbltpXV07XHJcbiAgICAgICAgdmFyIGNoaWxkVG9Db21iaW5lID0gdGhpcy50cnlHZXRDaGlsZE5vZGVUb0NvbWJpbmUoY2hpbGQsIHJlbGF0aW9uKTtcclxuICAgICAgICBpZiAoY2hpbGRUb0NvbWJpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkVG9Db21iaW5lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGZpbHRlciBleHByZXNzaW9uIGZyb20gYWxsIHJlbGF0aW9ucyBpbnNpZGUgYW4gRXhlY3V0aW9uTm9kZS5cclxuICogQHBhcmFtIGV4ZWN1dGlvbk5vZGUgLSBUaGUgRXhlY3V0aW9uTm9kZSBpbnN0YW5jZS5cclxuICogQHJldHVybnMge3t9fVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RmlsdGVyRnJvbUV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAoZXhlY3V0aW9uTm9kZSwgaW5jbHVkZUFycmF5cykge1xyXG4gICAgdmFyIGZpbHRlciA9IHt9O1xyXG4gICAgdmFyIHN1YlJlbGF0aW9uc0ZpbHRlciA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25Ob2RlLnJlbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBpbm5lckZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyRnJvbVNpbmdsZVJlbGF0aW9uKHRoaXMuX3JlbGF0aW9uVHJlZVtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV0sIGluY2x1ZGVBcnJheXMpO1xyXG4gICAgICAgIGlmIChpbm5lckZpbHRlcikge1xyXG4gICAgICAgICAgICBzdWJSZWxhdGlvbnNGaWx0ZXIucHVzaChpbm5lckZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdWJSZWxhdGlvbnNGaWx0ZXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGZpbHRlci4kb3IgPSBzdWJSZWxhdGlvbnNGaWx0ZXI7XHJcbiAgICB9IGVsc2UgaWYgKHN1YlJlbGF0aW9uc0ZpbHRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyID0gc3ViUmVsYXRpb25zRmlsdGVyWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmaWx0ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbHRlcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGZpbHRlciBleHByZXNzaW9uIGZyb20gYSBzaW5nbGUgcmVsYXRpb24uIFRyYXZlcnNlIHRoZSByZWxhdGlvbiB0cmVlIGluIG9yZGVyIHRvIGdldCB0aGUgXCJJZFwicyBmcm9tIHRoZSByZXN1bHQgb2YgcGFyZW50IHJlbGF0aW9uXHJcbiAqIGFsb25nIHdpdGggdXNlciBkZWZpbmVkIGZpbHRlcnMuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RmlsdGVyRnJvbVNpbmdsZVJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKSB7XHJcbiAgICB2YXIgdXNlckRlZmluZWRGaWx0ZXIgPSByZWxhdGlvbi5maWx0ZXJFeHByZXNzaW9uO1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uRmlsdGVyID0ge307XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25JZHMgPSB0aGlzLmdldFJlbGF0aW9uRmllbGRWYWx1ZXMocmVsYXRpb24sIGluY2x1ZGVBcnJheXMpO1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGROYW1lID0gKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbiA/IHJlbGF0aW9uLnJlbGF0aW9uRmllbGQgOiBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQpO1xyXG5cclxuICAgIGlmIChwYXJlbnRSZWxhdGlvbklkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcGFyZW50UmVsYXRpb25GaWx0ZXJbcGFyZW50UmVsYXRpb25GaWVsZE5hbWVdID0geyckaW4nOiBwYXJlbnRSZWxhdGlvbklkc307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VyRGVmaW5lZEZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcclxuICAgICAgICBmaWx0ZXJzLnB1c2gocGFyZW50UmVsYXRpb25GaWx0ZXIpO1xyXG4gICAgICAgIGZpbHRlcnMucHVzaCh1c2VyRGVmaW5lZEZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIHsnJGFuZCc6IGZpbHRlcnN9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50UmVsYXRpb25GaWx0ZXI7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHJlbGF0aW9uIGZpZWxkIHZhbHVlcyBvZiBwYXJlbnQgcmVsYXRpb24gaW4gb3JkZXIgdG8gY29uc3RydWN0IGEgcHJvcGVyIGZpbHRlciAodG8gY3JlYXRlIGEgcmVsYXRpb24pLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIGluc3RhbmNlIHdoaWNoIHdpbGwgZ2V0IHRoZSBmaWx0ZXIuXHJcbiAqIEBwYXJhbSBpbmNsdWRlQXJyYXlzIC0gV2hldGhlciB0byBpbmNsdWRlIGFycmF5IHZhbHVzIG9mIHRoZSBwYXJlbnQgaXRlbXMgd2hlbiBjYWxjdWxhdGluZyB0aGUgaXRlbXMgdGhhdCB3aWxsIGJlIGV4cGFuZGVkIG9uIHRoZSBjdXJyZW50IGxldmVsLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgcmVsYXRpb24gZmllbGQgdmFsdWVzLlxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0UmVsYXRpb25GaWVsZFZhbHVlcyA9IGZ1bmN0aW9uIChyZWxhdGlvbiwgaW5jbHVkZUFycmF5cykge1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uSWRzID0gW107XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb24gPSB0aGlzLl9yZWxhdGlvblRyZWVbcmVsYXRpb24ucGFyZW50XTtcclxuICAgIC8vIHBhcmVudFJlbGF0aW9uUmVzdWx0IGFjdHVhbGx5IGlzIGFuIEFjdGl2aXR5IG9yIEFycmF5IG9mIEFjdGl2aXRpZXNcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvblJlc3VsdCA9IEFycmF5LmlzQXJyYXkocGFyZW50UmVsYXRpb24ucmVzdWx0KSA/IHBhcmVudFJlbGF0aW9uLnJlc3VsdCA6IFtwYXJlbnRSZWxhdGlvbi5yZXN1bHRdO1xyXG4gICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGFyZW50UmVsYXRpb25SZXN1bHQubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChwYXJlbnRSZWxhdGlvblJlc3VsdFtwXVtyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbkZpZWxkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhbGwgY29tbWVudHMgYXJlIHJlbGF0ZWQgdG8gZXhwYW5kIG9mIHR5cGUgY29udGVudCB0eXBlIEFjdGl2aXRpZXMgZXhwYW5kOiB7XCJMaWtlc1wiOiB0cnVlfVxyXG4gICAgICAgIGlmIChwYXJlbnRSZWxhdGlvbiAmJiBwYXJlbnRSZWxhdGlvbi5yZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMgPSByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcyB8fCB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWxhdGlvblJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gaXRlbUZyb21QYXJlbnRSZWxhdGlvbiBpcyBzaW5nbGUgQWN0aXZpdHlcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtRnJvbVBhcmVudFJlbGF0aW9uID0gcGFyZW50UmVsYXRpb25SZXN1bHRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlIGlzIEFjdGl2aXR5Lkxpa2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlID0gaXRlbUZyb21QYXJlbnRSZWxhdGlvbltyZWxhdGlvbi5yZWxhdGlvbkZpZWxkXTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5oYXNBcnJheVZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVBcnJheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW1Ub0V4cGFuZElkIGlzIGN1cnJlbnQgdmFsdWUgaW4gQWN0aXZpdHkuTGlrZXMgYXJyYXkgb3IganVzdCBhIHNpbmdsZSBcIklkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9FeHBhbmRJZCA9IHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW1Ub0V4cGFuZElkICE9PSB1bmRlZmluZWQgJiYgaXRlbVRvRXhwYW5kSWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKGl0ZW1Ub0V4cGFuZElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZXQgYW55IHZhbHVlIGp1c3QgdG8gY3JlYXRlIGEgbWFwIG9mIElkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzW2l0ZW1Ub0V4cGFuZElkXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzW3BhcmVudFJlbGF0aW9uRmllbGRWYWx1ZV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50UmVsYXRpb25JZHM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvblRyZWU7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gRXhwYW5kRXJyb3IobWVzc2FnZSkge1xyXG4gICAgdGhpcy5uYW1lID0gJ0V4cGFuZEVycm9yJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxufVxyXG5FeHBhbmRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XHJcbm1vZHVsZS5leHBvcnRzID0gRXhwYW5kRXJyb3I7IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xyXG52YXIgUmVsYXRpb25UcmVlQnVpbGRlciA9IHJlcXVpcmUoJy4vUmVsYXRpb25UcmVlQnVpbGRlcicpO1xyXG52YXIgRXhlY3V0aW9uVHJlZSA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uVHJlZScpO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxudmFyIEV4cGFuZEVycm9yID0gcmVxdWlyZSgnLi9FeHBhbmRFcnJvcicpO1xyXG5cclxuZnVuY3Rpb24gUHJvY2Vzc29yKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX2V4ZWN1dGlvbk5vZGVGdW5jdGlvbiA9IG9wdGlvbnMuZXhlY3V0aW9uTm9kZUZ1bmN0aW9uO1xyXG4gICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uID0gb3B0aW9ucy5tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb247XHJcbn1cclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2dldEV4ZWN1dGlvblRyZWVSb290ID0gZnVuY3Rpb24gKGV4ZWN1dGlvblRyZWUpIHtcclxuICAgIHZhciBleGVjdXRpb25UcmVlUm9vdCA9IG51bGw7XHJcbiAgICBmb3IgKHZhciBleE5vZGUgaW4gZXhlY3V0aW9uVHJlZSkge1xyXG4gICAgICAgIGlmIChleGVjdXRpb25UcmVlLmhhc093blByb3BlcnR5KGV4Tm9kZSkpIHtcclxuICAgICAgICAgICAgaWYgKGV4ZWN1dGlvblRyZWVbZXhOb2RlXS5wYXJlbnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UcmVlUm9vdCA9IGV4ZWN1dGlvblRyZWVbZXhOb2RlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4ZWN1dGlvblRyZWVSb290O1xyXG59O1xyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fY3JlYXRlRXhlY3V0ZU5vZGVFeGVjdXRvciA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCBleGVjdXRpb25UcmVlLCBleGVjdXRpb25Ob2RlLCBleHBhbmRDb250ZXh0KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgcmVsYXRpb25zVHJlZU1hcCA9IHJlbGF0aW9uc1RyZWUubWFwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IGV4ZWN1dGlvblRyZWUuZ2V0UmVsYXRpb25Ob2RlKGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zWzBdKTsvL2dldCB0aGUgcmVsYXRpb24gbm9kZSBmb3IgdGhlIG9ubHkgcmVsYXRpb24gb2YgdGhlIGV4ZWN1dGlvbiBub2RlLlxyXG4gICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbk5vZGUgPSBleGVjdXRpb25UcmVlLmdldFJlbGF0aW9uTm9kZShyZWxhdGlvbk5vZGUucGFyZW50KTtcclxuICAgICAgICB2YXIgaW5jbHVkZUFycmF5cyA9ICEocGFyZW50UmVsYXRpb25Ob2RlLnBhcmVudCAmJiBwYXJlbnRSZWxhdGlvbk5vZGUuaGFzQXJyYXlWYWx1ZXMpOyAvL29ubHkgZXhwYW5kIGFycmF5IGZpZWxkcyBpZiB0aGUgcGFyZW50IHJlbGF0aW9uIGlzIG5vdCBhbiBhcnJheS4gVGhpcyBtZWFucyB0aGF0IGlmIHdlIGhhdmUgZXhwYW5kZWQgYSBMaWtlcyAobXVsdGlwbGUgdG8gVXNlcnMpLCB3ZSB3b24ndCBleHBhbmQgYW55IGFycmF5IHJlbGF0aW9ucyB0aGF0IGFyZSBuZXN0ZWQgaW4gaXQgc3VjaCBhcyB0aGUgVXNlckNvbW1lbnRzIChtdWx0aXBsZSByZWxhdGlvbiB0byBDb21tZW50cykuXHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGV4ZWN1dGlvblRyZWUuZ2V0RmlsdGVyRnJvbUV4ZWN1dGlvbk5vZGUoZXhlY3V0aW9uTm9kZSwgaW5jbHVkZUFycmF5cyk7XHJcblxyXG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSByZWxhdGlvbnNUcmVlLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24ocmVsYXRpb25Ob2RlKTtcclxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFeHBhbmRFcnJvcihlcnJvck1lc3NhZ2UpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc3VjaCBvcHRpb25zIGV4ZWN1dGlvbk5vZGUgc2hvdWxkIGhhdmUgb25seSBvbmUgcmVsYXRpb24uXHJcbiAgICAgICAgdmFyIG5vZGUgPSB7fTtcclxuICAgICAgICBub2RlLnNlbGVjdCA9IHJlbGF0aW9uTm9kZS5maWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgIG5vZGUuc29ydCA9IHJlbGF0aW9uTm9kZS5zb3J0RXhwcmVzc2lvbjtcclxuICAgICAgICBub2RlLnNraXAgPSByZWxhdGlvbk5vZGUuc2tpcDtcclxuICAgICAgICBub2RlLnRha2UgPSByZWxhdGlvbk5vZGUudGFrZTtcclxuICAgICAgICBub2RlLmZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICBub2RlLnRhcmdldFR5cGVOYW1lID0gcmVsYXRpb25Ob2RlLnRhcmdldFR5cGVOYW1lO1xyXG5cclxuICAgICAgICBzZWxmLl9leGVjdXRpb25Ob2RlRnVuY3Rpb24uY2FsbChudWxsLCBub2RlLCBleHBhbmRDb250ZXh0LCBmdW5jdGlvbiBvblByb2Nlc3NFeGVjdXRpb25Ob2RlKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZU1hcFtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV07XHJcbiAgICAgICAgICAgICAgICBjaGlsZFJlbGF0aW9uLnJlc3VsdCA9IHNlbGYuX2V4dHJhY3RSZXN1bHRGb3JSZWxhdGlvbihyZWxhdGlvbnNUcmVlTWFwW2V4ZWN1dGlvbk5vZGUucmVsYXRpb25zW2ldXSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleGVjdXRpb25Ob2RlLnJlc3VsdCA9IGNoaWxkUmVsYXRpb24ucmVzdWx0O1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXhlY3V0aW9uTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4ZWN1dGlvblRyZWVNYXAgPSBleGVjdXRpb25UcmVlLl9tYXA7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChzZWxmLl9jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvblRyZWVNYXBbZXhlY3V0aW9uTm9kZS5jaGlsZHJlbltqXV0sIGV4cGFuZENvbnRleHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3luYy5wYXJhbGxlbChhcnIsIGRvbmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufTtcclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2dldFNpbmdsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCByZWxhdGlvbiwgc2luZ2xlT2JqZWN0KSB7XHJcbiAgICBpZiAoIXNpbmdsZU9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZFJlbGF0aW9uO1xyXG4gICAgdmFyIGNoaWxkSXRlbTtcclxuXHJcbiAgICAvLyBpZiByZWxhdGlvbiBoYXMgc2luZ2xlRmllbGROYW1lIG9wdGlvbiB3ZSBqdXN0IHJlcGxhY2UgdGhlIHBhcmVudCBpZCB3aXRoIGEgc2luZ2xlIHZhbHVlXHJcbiAgICBpZiAocmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuICYmIHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY2hpbGRSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVbcmVsYXRpb24uY2hpbGRyZW5bMF1dO1xyXG4gICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLl9nZXRPYmplY3RCeUlkRnJvbUFycmF5KGNoaWxkUmVsYXRpb24ucmVzdWx0LCBzaW5nbGVPYmplY3RbcmVsYXRpb24uc2luZ2xlRmllbGROYW1lXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpbmdsZU9iamVjdFtyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBwYXNzZWRQcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuICYmIHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkUmVsYXRpb24gPSByZWxhdGlvbnNUcmVlW3JlbGF0aW9uLmNoaWxkcmVuW2pdXTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkUmVsYXRpb25GaWVsZCA9IGNoaWxkUmVsYXRpb24ucmVsYXRpb25GaWVsZDtcclxuICAgICAgICAgICAgdmFyIHVzZXJEZWZpbmVkUmVsTmFtZSA9IGNoaWxkUmVsYXRpb24udXNlckRlZmluZWROYW1lO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkUmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwYXNzZWRQcm9wZXJ0aWVzW2NoaWxkUmVsYXRpb25GaWVsZF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5uZXJSZWxhdGlvblJlc3VsdCA9IGNoaWxkUmVsYXRpb24ucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkUmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGlubmVyUmVsYXRpb25SZXN1bHQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGlubmVyUmVsYXRpb25SZXN1bHRba10sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdID0gY2hpbGRSZWxhdGlvbi5pc0FycmF5KCkgPyBbXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFJlbGF0aW9uLnNvcnRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNvcnRpbmcgd2UgcmVwbGFjZSBpdGVtcyB1c2luZyBvcmRlciBvZiB0aGUgcXVlcnkgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGlubmVyUmVsYXRpb25SZXN1bHQubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0uaW5kZXhPZihpbm5lclJlbGF0aW9uUmVzdWx0W3BdLklkKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IGlubmVyUmVsYXRpb25SZXN1bHRbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCByZXBsYWNlIGl0ZW1zIGdldHRpbmcgdGhlbSBieSBpZCB3aGljaCB3ZSBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gdGhpcy5fZ2V0T2JqZWN0QnlJZEZyb21BcnJheShpbm5lclJlbGF0aW9uUmVzdWx0LCBzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkoaW5uZXJSZWxhdGlvblJlc3VsdCwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IHRoaXMuX2dldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGQgYWxsIG90aGVyIGZpZWxkcyB0byB0aGUgcmVzdWx0IChleGNlcHQgdGhlIHJlbGF0aW9uIGZpZWxkcyB3aGljaCB3ZSBoYXZlIGFscmVhZHkgcmVwbGFjZWQpLlxyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzaW5nbGVPYmplY3QpIHtcclxuICAgICAgICB2YXIgcHJvcGVydHlTaG91bGRCZUFkZGVkVG9SZXN1bHQgPSBzaW5nbGVPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgIXBhc3NlZFByb3BlcnRpZXNbcHJvcF0gJiZcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRFeGlzdEluRmllbGRzRXhwcmVzc2lvbihwcm9wLCByZWxhdGlvbi5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24pO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eVNob3VsZEJlQWRkZWRUb1Jlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBzaW5nbGVPYmplY3RbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5ID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpIHtcclxuICAgIHZhciBzaW5nbGVSZXN1bHQgPSB0aGlzLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcclxuICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdID0gcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gfHwgW107XHJcbiAgICBpZiAoc2luZ2xlUmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0ucHVzaChzaW5nbGVSZXN1bHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGZpZWxkIHdpbGwgYmUgcmV0dXJuZWQgdmlhIGdpdmVuIGZpZWxkcyBleHByZXNzaW9uLlxyXG4gKiBAcGFyYW0gZmllbGQgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQuXHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gVGhlIEZpZWxkcyBleHByZXNzaW9uIHdoaWNoIGlzIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fZmllbGRFeGlzdEluRmllbGRzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWVsZCwgZmllbGRzRXhwcmVzc2lvbikge1xyXG4gICAgaWYgKGZpZWxkc0V4cHJlc3Npb24gPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhmaWVsZHNFeHByZXNzaW9uKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmllbGQgPT09IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCkge1xyXG4gICAgICAgIGlmIChmaWVsZHNFeHByZXNzaW9uW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmllbGRzRXhwcmVzc2lvbltmaWVsZF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzRXhjbHVzaXZlID0gUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUoZmllbGRzRXhwcmVzc2lvbik7XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gIWZpZWxkc0V4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoZmllbGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgdGhlIHJlc3VsdCBmb3IgYSBzaW5nbGUgcmVsYXRpb24gKGluIGNhc2VzIHdoZW4gRXhlY3V0aW9uTm9kZSBjb250YWlucyBtb3JlIHRoYW4gb25lIHJlbGF0aW9ucykuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSByZWxhdGlvbiBvYmplY3QuXHJcbiAqIEBwYXJhbSBxdWVyeVJlc3VsdCAtIFJlc3VsdCBvZiB0aGUgY29tYmluZWQgcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2V4dHJhY3RSZXN1bHRGb3JSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbiwgcXVlcnlSZXN1bHQpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlSZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMpIHtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzLmhhc093blByb3BlcnR5KHF1ZXJ5UmVzdWx0W2ldLklkKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocXVlcnlSZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocXVlcnlSZXN1bHRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBhbiBvYmplY3Qgd2l0aCBhIGdpdmVuIElkIGZyb20gQXJyYXkuXHJcbiAqIEBwYXJhbSBhcnJheVxyXG4gKiBAcGFyYW0gaWRcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9nZXRPYmplY3RCeUlkRnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBpZCkge1xyXG4gICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0uSWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uXHJcbiAqIEBwYXJhbSBtYWluVHlwZU5hbWVcclxuICogQHBhcmFtIGlzQXJyYXlcclxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb25cclxuICogQHBhcmFtIG1heFRha2VWYWx1ZVxyXG4gKiBAcGFyYW0gcHJlcGFyZUNvbnRleHRcclxuICogQHBhcmFtIGRvbmVcclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uLCBtYWluVHlwZU5hbWUsIGlzQXJyYXksIGZpZWxkc0V4cHJlc3Npb24sIG1heFRha2VWYWx1ZSwgcHJlcGFyZUNvbnRleHQsIGRvbmUpIHtcclxuICAgIHZhciBydGIgPSBuZXcgUmVsYXRpb25UcmVlQnVpbGRlcihleHBhbmRFeHByZXNzaW9uLCBtYWluVHlwZU5hbWUsIGlzQXJyYXksIGZpZWxkc0V4cHJlc3Npb24sIG1heFRha2VWYWx1ZSwgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uLCBwcmVwYXJlQ29udGV4dCk7XHJcbiAgICBydGIuYnVpbGQoZnVuY3Rpb24gKGVyciwgbWFwKSB7XHJcbiAgICAgICAgdmFyIG1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgaWYgKG1hcCkge1xyXG4gICAgICAgICAgICBtYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uID0gbWFwW21hcC4kcm9vdF0uZmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgdmFyIHByZXBhcmVSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNUcmVlOiBydGIsXHJcbiAgICAgICAgICAgICAgICBtYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uOiBtYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZG9uZShlcnIsIHByZXBhcmVSZXN1bHQpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVsYXRpb25zVHJlZVxyXG4gKiBAcGFyYW0gbWFpblF1ZXJ5UmVzdWx0XHJcbiAqIEBwYXJhbSBleHBhbmRDb250ZXh0XHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqL1xyXG5Qcm9jZXNzb3IucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCBtYWluUXVlcnlSZXN1bHQsIGV4cGFuZENvbnRleHQsIGRvbmUpIHtcclxuICAgIHZhciByZWxhdGlvbnNUcmVlTWFwID0gcmVsYXRpb25zVHJlZS5tYXA7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgZXhlY3V0aW9uVHJlZSA9IG5ldyBFeGVjdXRpb25UcmVlKHJlbGF0aW9uc1RyZWVNYXApO1xyXG4gICAgZXhlY3V0aW9uVHJlZS5idWlsZCgpO1xyXG4gICAgcmVsYXRpb25zVHJlZU1hcFtyZWxhdGlvbnNUcmVlTWFwLiRyb290XS5yZXN1bHQgPSBtYWluUXVlcnlSZXN1bHQ7XHJcbiAgICB2YXIgZXhlY3V0aW9uVHJlZU1hcCA9IGV4ZWN1dGlvblRyZWUuX21hcDtcclxuXHJcbiAgICB2YXIgZXhlY3V0aW9uVHJlZVJvb3QgPSB0aGlzLl9nZXRFeGVjdXRpb25UcmVlUm9vdChleGVjdXRpb25UcmVlTWFwKTtcclxuXHJcbiAgICB2YXIgbWF4UXVlcmllc0NvdW50ID0gMjA7XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoZXhlY3V0aW9uVHJlZU1hcCkubGVuZ3RoID4gbWF4UXVlcmllc0NvdW50KSB7XHJcbiAgICAgICAgZG9uZShuZXcgRXhwYW5kRXJyb3IoJ0V4cGFuZCBleHByZXNzaW9uIHJlc3VsdHMgaW4gbW9yZSB0aGFuICcgKyBtYXhRdWVyaWVzQ291bnQgKyAnIGlubmVyIHF1ZXJpZXMhJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChleGVjdXRpb25UcmVlUm9vdCkge1xyXG4gICAgICAgIHZhciBleGVjRnVuY3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvblRyZWVSb290LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4ZWNGdW5jcy5wdXNoKHRoaXMuX2NyZWF0ZUV4ZWN1dGVOb2RlRXhlY3V0b3IocmVsYXRpb25zVHJlZSwgZXhlY3V0aW9uVHJlZSwgZXhlY3V0aW9uVHJlZU1hcFtleGVjdXRpb25UcmVlUm9vdC5jaGlsZHJlbltpXV0sIGV4cGFuZENvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhlY0Z1bmNzIGFyZSBmdW5jdGlvbnMgY3JlYXRlZCBmb3IgZXZlcnkgc2luZ2xlIGV4ZWN1dGlvbiBub3RlXHJcbiAgICAgICAgLy8gd2UgZXhlY3V0ZSB0aGVtIGluIGFzeW5jLCBzaW5jZSB0aGUgcmVzdWx0IG9mIHRoZSBwYXJlbnQgcmVsYXRpb24gaXMgdXNlZCB0byBnZXQgY29ycmVjdCBmaWx0ZXIuXHJcbiAgICAgICAgYXN5bmMuc2VyaWVzKGV4ZWNGdW5jcywgZnVuY3Rpb24gb25Qcm9jZXNzRXhlY3V0aW9uVHJlZShlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgZG9uZShlcnIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dDtcclxuICAgICAgICAgICAgICAgIHZhciByb290UmVsYXRpb24gPSByZWxhdGlvbnNUcmVlTWFwW3JlbGF0aW9uc1RyZWVNYXAuJHJvb3RdO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFpblF1ZXJ5UmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpblF1ZXJ5UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVSZXN1bHQgPSBzZWxmLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZU1hcCwgcm9vdFJlbGF0aW9uLCBtYWluUXVlcnlSZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzaW5nbGVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzZWxmLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZU1hcCwgcm9vdFJlbGF0aW9uLCBtYWluUXVlcnlSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCBvdXRwdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IuQ29uc3RhbnRzID0gQ29uc3RhbnRzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9jZXNzb3I7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgRXhwYW5kRXJyb3IgPSByZXF1aXJlKCcuL0V4cGFuZEVycm9yJyk7XHJcblxyXG5mdW5jdGlvbiBSZWxhdGlvbk5vZGUob3B0aW9ucykge1xyXG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIHRoaXMucmVsYXRpb25GaWVsZCA9IG9wdGlvbnMucmVsYXRpb25GaWVsZDtcclxuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCBvcHRpb25zLnBhcmVudCArICcuJyArIG9wdGlvbnMucmVsYXRpb25GaWVsZDtcclxuICAgIHRoaXMuZmllbGRzRXhwcmVzc2lvbiA9IG9wdGlvbnMuZmllbGRzRXhwcmVzc2lvbiB8fCB7fTtcclxuICAgIHRoaXMudGFyZ2V0VHlwZU5hbWUgPSBvcHRpb25zLnRhcmdldFR5cGVOYW1lO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdGhpcy5pc0ludmVydGVkUmVsYXRpb24gPSBvcHRpb25zLmlzSW52ZXJ0ZWRSZWxhdGlvbjtcclxuICAgIHRoaXMuaXNBcnJheVJvb3QgPSBvcHRpb25zLmlzQXJyYXlSb290OyAvL3VzZWQgZm9yIHZhbGlkYXRpb24gb2YgY2FzZXMgd2hlcmUgdmFyaW91cyBleHBhbmQgZmVhdHVyZXMgYXJlIGRpc2FibGVkIGZvciBhIEdldEFsbCBzY2VuYXJpby5cclxuICAgIHRoaXMuaGFzQXJyYXlWYWx1ZXMgPSBmYWxzZTsvL3NldCB3aGVuIHdlIGhhdmUgZXhlY3V0ZWQgdGhlIHF1ZXJ5LiBVc2VkIGluIHZhbGlkYXRpb24gc2NlbmFyaW9zIHdoZXJlIHdlIGRvIG5vdCBoYXZlIG1ldGFkYXRhIGFib3V0IHdoZXRoZXIgdGhlIHJlbGF0aW9uIGlzIGFuIGFycmF5IG9yIG5vdC5cclxuXHJcbiAgICB2YXIgZXhwYW5kRXhwcmVzc2lvbiA9IG9wdGlvbnMuZXhwYW5kRXhwcmVzc2lvbiB8fCB7fTtcclxuXHJcbiAgICB0aGlzLnBhcmVudFJlbGF0aW9uRmllbGQgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5QYXJlbnRSZWxhdGlvbkZpZWxkTmFtZV0gfHwgQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50O1xyXG4gICAgdmFyIHJlbGF0aW9uRmllbGQgPSB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiA/IHRoaXMucGF0aCA6IHRoaXMucmVsYXRpb25GaWVsZDsgLy9pbnZlcnRlZCByZWxhdGlvbnMgYXBwZWFyIHdpdGggdGhlIGZ1bGwgcGF0aCAtIENvbnRlbnRUeXBlLkZpZWxkIC0gaW4gdGhlIHJlc3VsdCB3aGVuIGV4cGFuZGluZy5cclxuICAgIHRoaXMudXNlckRlZmluZWROYW1lID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWVdIHx8IHJlbGF0aW9uRmllbGQ7XHJcbiAgICBfLmV4dGVuZCh0aGlzLmZpZWxkc0V4cHJlc3Npb24sIGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lXSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgXy5leHRlbmQodGhpcy5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24sIHRoaXMuZmllbGRzRXhwcmVzc2lvbik7XHJcbiAgICB0aGlzLnNpbmdsZUZpZWxkTmFtZSA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy5maWx0ZXJFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuRmlsdGVyRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy5zb3J0RXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNvcnRFeHByZXNzaW9uTmFtZV07XHJcbiAgICB0aGlzLnNraXAgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5Ta2lwRXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy50YWtlID0gdGhpcy5fZ2V0VGFrZUxpbWl0KGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlRha2VFeHByZXNzaW9uTmFtZV0sIG9wdGlvbnMubWF4VGFrZVZhbHVlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB0YWtlIGxpbWl0IGRlcGVuZGluZyBvbiB0aGUgYXBwbGljYXRpb24gYW5kIHRoZSB0YWtlIHZhbHVlIHRoYXQgdGhlIHVzZXIgaGFzIHByb3ZpZGVkLlxyXG4gKiBAcGFyYW0gY2xpZW50VGFrZVZhbHVlXHJcbiAqIEBwYXJhbSBtYXhUYWtlVmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcblJlbGF0aW9uTm9kZS5wcm90b3R5cGUuX2dldFRha2VMaW1pdCA9IGZ1bmN0aW9uIChjbGllbnRUYWtlVmFsdWUsIG1heFRha2VWYWx1ZSkge1xyXG4gICAgbWF4VGFrZVZhbHVlID0gbWF4VGFrZVZhbHVlIHx8IENvbnN0YW50cy5EZWZhdWx0VGFrZUl0ZW1zQ291bnQ7XHJcbiAgICBpZiAoY2xpZW50VGFrZVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudFRha2VWYWx1ZSA+IG1heFRha2VWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhwYW5kRXJyb3IoJ1RoZSBtYXhpbXVtIGFsbG93ZWQgdGFrZSB2YWx1ZSB3aGVuIGV4cGFuZGluZyByZWxhdGlvbnMgaXMgJyArIG1heFRha2VWYWx1ZSArICchJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGllbnRUYWtlVmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXhUYWtlVmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQW55b25lIHVzaW5nIHRoZSBicy1leHBhbmQtcHJvY2Vzc29yIG1vZHVsZSBjYW4gc2V0IHdoZXRoZXIgdGhlIHJlbGF0aW9uIGlzIGEgbXVsdGlwbGUgcmVsYXRpb24gaW4gdGhlIHByZXBhcmUgcGhhc2UuXHJcbiAqIFRoaXMgd2lsbCBhbGxvdyBmb3IgY2VydGFpbiByZXN0cmljdGlvbnMgdG8gYmUgZW5mb3JjZWQgZGlyZWN0bHkgb24gdGhlIHByZXBhcmUgcGhhc2UgaW5zdGVhZCBvZiB0aGUgZXhlY3V0aW9uIHBoYXNlLlxyXG4gKi9cclxuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5zZXRJc0FycmF5RnJvbU1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5pc0FycmF5RnJvbU1ldGFkYXRhID0gdHJ1ZTtcclxufTtcclxuXHJcblJlbGF0aW9uTm9kZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFdlIGNhbiBmaW5kIG91dCBpZiBhIHJlbGF0aW9uIGlzIGFuIGFycmF5IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcbiAgICAvLyBGcm9tIG1ldGFkYXRhIGluIHRoZSBBUEkgU2VydmVyLlxyXG4gICAgLy8gQWxsIGludmVydGVkIHJlbGF0aW9ucyBhcmUgYXJyYXkuXHJcbiAgICAvLyBPbmNlIHZhbHVlcyBoYXZlIGJlZW4gcmVjZWl2ZWQgd2UgY2FuIGZpbmQgb3V0LiBUaGlzIGlzIHVzZWQgZm9yIHNjZW5hcmlvcyB3aGVyZSB3ZSBkbyBub3QgaGF2ZSBtZXRhZGF0YSBhYm91dCB0aGUgcmVsYXRpb24gKG9mZmxpbmUgc3RvcmFnZSBpbiBTREspLlxyXG4gICAgcmV0dXJuIHRoaXMuaXNBcnJheUZyb21NZXRhZGF0YSB8fCB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiB8fCB0aGlzLmhhc0FycmF5VmFsdWVzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvbk5vZGU7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIFJlbGF0aW9uTm9kZSA9IHJlcXVpcmUoJy4vUmVsYXRpb25Ob2RlJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxudmFyIEV4cGFuZEVycm9yID0gcmVxdWlyZSgnLi9FeHBhbmRFcnJvcicpO1xyXG5cclxuLy92YXIgcmVsYXRpb25GaWVsZFByb3BlcnR5TmFtZSA9IENvbnN0YW50cy5SZWxhdGlvbkV4cHJlc3Npb25OYW1lO1xyXG5cclxudmFyIHBvc3NpYmxlRXhwYW5kT3B0aW9ucyA9IFtcclxuICAgIENvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZSxcclxuICAgIENvbnN0YW50cy5GaWVsZHNFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5TaW5nbGVGaWVsZEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlNvcnRFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5GaWx0ZXJFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5Ta2lwRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuVGFrZUV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlBhcmVudFJlbGF0aW9uRmllbGROYW1lLFxyXG4gICAgQ29uc3RhbnRzLlRhcmdldFR5cGVOYW1lRmllbGROYW1lXHJcbl07XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdXNlZCB0byBwYXJzZSBFeHBhbmQgZXhwcmVzc2lvbiBhbmQgYnVpbGQgYSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIHRyZWUuXHJcbiAqIEluIGEgcHJvY2VzcyBvZiBjcmVhdGluZyB0aGUgcmVsYXRpb24gdHJlZSBhcmUgcGVyZm9ybWVkIHNldmVyYWwgY2hlY2tzIGluIG9yZGVyIHRvIGZvcmNlIHNvbWUgbGltaXRhdGlvbnMgLVxyXG4gKiA1MCBpdGVtcyBib3RoIGZvciBtYXN0ZXIgYW5kIGNoaWxkIHF1ZXJpZXMgYW5kIGVudGlyZSBhbW91bnQgb2YgYWxsIHF1ZXJpZXMgbGltaXRlZCB0byAyMC5cclxuICogQ2hlY2tzIGlmIHRoZSByZWxhdGlvbiBmaWVsZCBnaXZlbiBieSB0aGUgY3VzdG9tZXIgaXMgdmFsaWQgKGZvciBleGFtcGxlOiB1c2VyIGdpdmVzIFwiTGlrZVwiIHdoaWxlIHRoZSByZWxhdGlvbiBmaWVsZCBpcyBcIkxpa2VzXCIpLlxyXG4gKiBDaGVja3MgZm9yIHBvc3NpYmxlIGV4cGFuZCBvcHRpb25zLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBSZWxhdGlvblRyZWVCdWlsZGVyID0gZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24sIG1haW5UeXBlTmFtZSwgaXNBcnJheSwgZmllbGRzRXhwcmVzc2lvbiwgbWF4VGFrZVZhbHVlLCBtZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24sIGNvbnRleHQpIHtcclxuICAgIHRoaXMubWF4VGFrZVZhbHVlID0gbWF4VGFrZVZhbHVlO1xyXG4gICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uID0gbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMuZXhwYW5kRXhwcmVzc2lvbiA9IHRoaXMucHJvY2Vzc0V4cGFuZEV4cHJlc3Npb24oZXhwYW5kRXhwcmVzc2lvbik7XHJcbiAgICAvLyBtYXJrIHRoZSBtYWluIHF1ZXJ5IGluIG9yZGVyIHRvIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gaXNzdWVzLlxyXG4gICAgdGhpcy5tYXAgPSB7fTtcclxuICAgIHRoaXMubWFwW21haW5UeXBlTmFtZV0gPSBuZXcgUmVsYXRpb25Ob2RlKHtcclxuICAgICAgICB0YXJnZXRUeXBlTmFtZTogbWFpblR5cGVOYW1lLFxyXG4gICAgICAgIGlzQXJyYXlSb290OiBpc0FycmF5LFxyXG4gICAgICAgIGZpZWxkc0V4cHJlc3Npb246IGZpZWxkc0V4cHJlc3Npb24sXHJcbiAgICAgICAgdmFsaWRhdGVkOiB0cnVlLFxyXG4gICAgICAgIHBhdGg6IG1haW5UeXBlTmFtZSxcclxuICAgICAgICBtYXhUYWtlVmFsdWU6IG1heFRha2VWYWx1ZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1hcFttYWluVHlwZU5hbWVdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgXy5leHRlbmQodGhpcy5tYXBbbWFpblR5cGVOYW1lXS5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24sIGZpZWxkc0V4cHJlc3Npb24pO1xyXG4gICAgdGhpcy5tYXAuJHJvb3QgPSBtYWluVHlwZU5hbWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBmdWxseSBxdWFsaWZpZWQgZXhwYW5kIGV4cHJlc3Npb24gZnJvbSBzaG9ydGhhbmQgdXNhZ2VzOlxyXG4gKiB7XCJMaWtlc1wiOiB0cnVlfSAtPiB7XCJMaWtlc1wiOiB7XCJSZXR1cm5Bc1wiOiBcIkxpa2VzXCJ9fVxyXG4gKiB7XCJMaWtlc1wiOiBcIkxpa2VzRXhwYW5kZWRcIn0gLT4ge1wiTGlrZXNcIjoge1wiUmV0dXJuQXNcIjogXCJMaWtlc0V4cGFuZGVkXCJ9fVxyXG4gKiBAcGFyYW0gZXhwYW5kRXhwcmVzc2lvblxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLnByb2Nlc3NFeHBhbmRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24pIHtcclxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4cGFuZEV4cHJlc3Npb24pIHtcclxuICAgICAgICBpZiAoZXhwYW5kRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV1bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSA9IHByb3BlcnR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25GaWVsZCA9IGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldW0NvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZV0gPSByZWxhdGlvbkZpZWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cGFuZEV4cHJlc3Npb247XHJcbn07XHJcblxyXG4vKipcclxuICogQnVpbGRzIHRoZSByZWxhdGlvbiB0cmVlLlxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoZG9uZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmJ1aWxkTWFwSW50ZXJuYWwodGhpcy5leHBhbmRFeHByZXNzaW9uLCB0aGlzLm1hcC4kcm9vdCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUoZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXF1aXJlKCdhc3luYycpLnNlcmllcyhbXHJcbiAgICAgICAgdGhpcy5jb25maWd1cmVSZWxhdGlvblRyZWUuYmluZCh0aGlzKSxcclxuICAgICAgICB0aGlzLnZhbGlkYXRlUmVsYXRpb25UcmVlLmJpbmQodGhpcylcclxuICAgIF0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBkb25lKGVyciwgc2VsZi5tYXApO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHJlbGF0aW9uTmFtZSAtIEEgcGF0aCB0byB0aGUgZXh0ZXJuYWwgcmVsYXRpb24gY29sbGVjdGlvbiAoQ29tbWVudHMuQWN0aXZpdHlJZClcclxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb24gLSBUaGUgZXhwYW5kIGV4cHJlc3Npb24gdGhhdCBjb250YWlucyBhbGwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbGF0aW9uXHJcbiAqIEBwYXJhbSByb290TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCByZWxhdGlvbi5cclxuICogQHJldHVybnMge1JlbGF0aW9uTm9kZX1cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUludmVydGVkUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb25OYW1lLCBleHBhbmRFeHByZXNzaW9uLCByb290TmFtZSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgIHZhciByZWxhdGlvbk5hbWVQYXJ0cyA9IHJlbGF0aW9uTmFtZS5zcGxpdCgnLicpO1xyXG4gICAgb3B0aW9ucy5wYXJlbnQgPSByb290TmFtZTtcclxuICAgIG9wdGlvbnMucmVsYXRpb25GaWVsZCA9IHJlbGF0aW9uTmFtZVBhcnRzWzFdO1xyXG4gICAgb3B0aW9ucy5pc0ludmVydGVkUmVsYXRpb24gPSB0cnVlO1xyXG4gICAgb3B0aW9ucy50YXJnZXRUeXBlTmFtZSA9IHJlbGF0aW9uTmFtZVBhcnRzWzBdO1xyXG4gICAgb3B0aW9ucy5leHBhbmRFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbjtcclxuICAgIG9wdGlvbnMucGF0aCA9IHJlbGF0aW9uTmFtZTtcclxuICAgIG9wdGlvbnMubWF4VGFrZVZhbHVlID0gdGhpcy5tYXhUYWtlVmFsdWU7XHJcbiAgICBvcHRpb25zLnZhbGlkYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBuZXcgUmVsYXRpb25Ob2RlKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFuIGludGVybmFsIG1ldGhvZCB3aGljaCBwYXJzZXMgdGhlIGV4cGFuZCBleHByZXNzaW9uIGFuZCBwcm9kdWNlcyBhIGJhc2ljIHJlbGF0aW9uIHRyZWUgKG9ubHkgbmFtZXMgYW5kIHBhcmVudCByZWxhdGlvbnMpLlxyXG4gKiBAcGFyYW0gZXhwYW5kRXhwcmVzc2lvbiAtIFRoZSBleHBhbmQgZXhwcmVzc2lvbiB3aGljaCB3aWxsIGJlIHByb2Nlc3NlZC5cclxuICogQHBhcmFtIHJvb3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHJvb3QgcmVsYXRpb24gKG1hc3RlciBxdWVyeSkgdXN1YWxseSB0aGUgbmFtZSBvZiB0aGUgcmVxdWVzdGVkIGNvbnRlbnQgdHlwZSAoQWN0aXZpdGllcykuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5idWlsZE1hcEludGVybmFsID0gZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24sIHJvb3ROYW1lKSB7XHJcbiAgICBmb3IgKHZhciByZWxhdGlvbk5hbWUgaW4gZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KHJlbGF0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbltyZWxhdGlvbk5hbWVdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIGN1cnJlbnRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiBwb3NzaWJsZUV4cGFuZE9wdGlvbnMuaW5kZXhPZihvcHRpb24pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHBhbmRFcnJvcignXFxcIicgKyBvcHRpb24gKyAnXFxcIicgKyAnIGlzIG5vdCBhIHZhbGlkIG9wdGlvbiBmb3IgRXhwYW5kIGV4cHJlc3Npb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uTmFtZS5pbmRleE9mKCcuJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGludmVydGVkUmVsYXRpb24gPSB0aGlzLmNyZWF0ZUludmVydGVkUmVsYXRpb24ocmVsYXRpb25OYW1lLCBjdXJyZW50RXhwcmVzc2lvbiwgcm9vdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbaW52ZXJ0ZWRSZWxhdGlvbi5wYXRoXSA9IGludmVydGVkUmVsYXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhcmVudF0uY2hpbGRyZW4ucHVzaChpbnZlcnRlZFJlbGF0aW9uLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIGZpZWxkIGV4cHJlc3Npb24gaW4gdGhlIG9yaWdpbmFsIGZpZWxkcyBleHByZXNzaW9uIGluIG9yZGVyIHRvIGdldCB0aGUgcmVzdWx0IGZvciB0aGF0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHRoaXMubWFwW2ludmVydGVkUmVsYXRpb24ucGFyZW50XS5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24sIGludmVydGVkUmVsYXRpb24udXNlckRlZmluZWROYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kRXhwcmVzc2lvbltyZWxhdGlvbk5hbWVdW0NvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkRXhwYW5kRXhwcmVzc2lvbiA9IHRoaXMucHJvY2Vzc0V4cGFuZEV4cHJlc3Npb24oZXhwYW5kRXhwcmVzc2lvbltyZWxhdGlvbk5hbWVdW0NvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbChwcm9jZXNzZWRFeHBhbmRFeHByZXNzaW9uLCBpbnZlcnRlZFJlbGF0aW9uLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVsYXRpb25GaWVsZCA9IHJlbGF0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50ID0gcm9vdE5hbWU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gPSBjdXJyZW50RXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4VGFrZVZhbHVlID0gdGhpcy5tYXhUYWtlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhcmdldFR5cGVOYW1lID0gY3VycmVudEV4cHJlc3Npb25bQ29uc3RhbnRzLlRhcmdldFR5cGVOYW1lRmllbGROYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbk5vZGUgPSBuZXcgUmVsYXRpb25Ob2RlKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLm1hcFtvcHRpb25zLnBhcmVudF07XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gocmVsYXRpb25Ob2RlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbcmVsYXRpb25Ob2RlLnBhdGhdID0gcmVsYXRpb25Ob2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdXJyZW50RXhwcmVzc2lvbltDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWVdKSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZE1hcEludGVybmFsKHRoaXMucHJvY2Vzc0V4cGFuZEV4cHJlc3Npb24oY3VycmVudEV4cHJlc3Npb24uRXhwYW5kKSwgcmVsYXRpb25Ob2RlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHBhbmRFcnJvcihyZWxhdGlvbk5vZGUucGF0aCArICcuRXhwYW5kIG11c3QgYmUgYSB2YWxpZCBleHBhbmQgZXhwcmVzc2lvbiEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhZGRpdGlvbmFsIG1ldGFkYXRhIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBleGVjdXRlIGEgcXVlcnkuXHJcbiAqIE5hbWUgb2YgdGhlIGNvbnRlbnQgdHlwZSBvZiB0aGUgY2hpbGQgcmVsYXRpb24gZ2V0IHZpYSByZWxhdGlvbiBmaWVsZC5cclxuICogQHBhcmFtIGRvbmVcclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNvbmZpZ3VyZVJlbGF0aW9uVHJlZSA9IGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICBpZiAodGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aW9uTmFtZXMgPSBbXTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHJlbCBpbiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkocmVsKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwW3JlbF0ucGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25OYW1lcy5wdXNoKHRoaXMubWFwW3JlbF0ucmVsYXRpb25GaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbihyZWxhdGlvbk5hbWVzLCB0aGlzLm1hcCwgdGhpcy5jb250ZXh0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgZG9uZShlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZG9uZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIHNldmVyYWwgY2hlY2tzIGxpa2U6XHJcbiAqIFZhbGlkaXR5IG9mIHRoZSByZWxhdGlvbiBmaWVsZC5cclxuICogVG8gbm90IHVzZSBmaWx0ZXIgb3Igc29ydGluZyBleHByZXNzaW9uIHdpdGhpbiBhIFwiR2V0QnlGaWx0ZXJcIiBzY2VuYXJpby5cclxuICogRG9lcyBub3QgYWxsb3cgdG8gbmVzdCAoZXhwYW5kIG11bHRpcGxlIHJlbGF0aW9uIGZpZWxkKSBhZnRlciBhIG11bHRpcGxlIHJlbGF0aW9uLlxyXG4gKiBEb2VzIG5vdCBhbGxvdyB0byB1c2UgYm90aCBcIkZpZWxkc1wiIGFuZCBcIlNpbmdsZUZpZWxkXCIgb3B0aW9ucy5cclxuICogQHBhcmFtIGRvbmVcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS52YWxpZGF0ZVJlbGF0aW9uVHJlZSA9IGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICB2YXIgRU9MID0gJ1xcclxcbic7XHJcbiAgICBmb3IgKHZhciByZWxhdGlvblBhdGggaW4gdGhpcy5tYXApIHtcclxuICAgICAgICBpZiAocmVsYXRpb25QYXRoICE9PSAnJHJvb3QnICYmIHRoaXMubWFwLmhhc093blByb3BlcnR5KHJlbGF0aW9uUGF0aCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5tYXBbcmVsYXRpb25QYXRoXTtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IHRoaXMudmFsaWRhdGVTaW5nbGVSZWxhdGlvbihyZWxhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlRmllbGRzRXhwcmVzc2lvbnNGb3JSZWxhdGlvbihyZWxhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGVycm9yTWVzc2FnZSAhPT0gJycpIHtcclxuICAgICAgICB2YXIgZmluYWxFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2Uuc3Vic3RyKDAsIGVycm9yTWVzc2FnZS5sYXN0SW5kZXhPZihFT0wpKTtcclxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXhwYW5kRXJyb3IoZmluYWxFcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBkb25lKGVycm9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCByZWxhdGlvbiBmaWVsZHMgdG8gcGFyZW50IHJlbGF0aW9uIGZpZWxkcyBleHByZXNzaW9uIGlmIG5lZWRlZCAob3RoZXJ3aXNlIHJlbGF0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZCkuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgcmVsYXRpb24gd2hpY2ggd2lsbCBiZSBjb25maWd1cmVkLlxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY29uZmlndXJlRmllbGRzRXhwcmVzc2lvbnNGb3JSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgaWYgKHJlbGF0aW9uLnBhcmVudCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24gPSB0aGlzLm1hcFtyZWxhdGlvbi5wYXJlbnRdLmZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb24ucGFyZW50UmVsYXRpb25GaWVsZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihwYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uLnJlbGF0aW9uRmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uLnJlbGF0aW9uRmllbGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24sIENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCk7XHJcbiAgICB9XHJcbiAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkanVzdFBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbih0aGlzLm1hcFtyZWxhdGlvbi5wYXJlbnRdLCByZWxhdGlvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGEgc2luZ2xlIHJlbGF0aW9uIGZvciBhbGwgYnVpbGQtaW4gbGltaXRhdGlvbnMuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgcmVsYXRpb24gd2hpY2ggd2lsbCBiZSB2YWxpZGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIHdpdGggYWxsIGVycm9ycyBvciBlbXB0eSBzdHJpbmcgaWYgdGhlcmUgaXMgbm8gZXJyb3JzLlxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUudmFsaWRhdGVTaW5nbGVSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgdmFyIGVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgdmFyIEVPTCA9ICdcXHJcXG4nO1xyXG4gICAgdmFyIGlzR2V0QnlGaWx0ZXJRdWVyeSA9IHRoaXMubWFwW3RoaXMubWFwLiRyb290XS5pc0FycmF5Um9vdDtcclxuXHJcbiAgICBpZiAocmVsYXRpb24ucGF0aCA9PT0gcmVsYXRpb24ucGFyZW50KSB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IHJlbGF0aW9uLnBhdGggKyAnIGhhcyBzYW1lIHBhcmVudCB3aGljaCB3aWxsIGNhdXNlIGFuIGluZmluaXRlIGxvb3AuJyArIEVPTDtcclxuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZWxhdGlvbi5pc0FycmF5KCkpIHtcclxuICAgICAgICB2YXIgbXVsdGlwbGVRdWVyaWVzQ291bnQgPSB0aGlzLmdldFBhcmVudE11bHRpcGxlUmVsYXRpb25zQ291bnQocmVsYXRpb24pO1xyXG4gICAgICAgIGlmIChtdWx0aXBsZVF1ZXJpZXNDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdFeHBhbmQgZXhwcmVzc2lvbiBoYXMgbXVsdGlwbGUgcmVsYXRpb24gXFxcIicgKyByZWxhdGlvbi5wYXRoICsgJ1xcXCIgaW5zaWRlIGEgbXVsdGlwbGUgcmVsYXRpb24uJztcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1hcFtyZWxhdGlvbi5wYXJlbnRdID09PSB0aGlzLm1hcFt0aGlzLm1hcC4kcm9vdF0gJiZcclxuICAgICAgICAgICAgaXNHZXRCeUZpbHRlclF1ZXJ5ICYmXHJcbiAgICAgICAgICAgIChyZWxhdGlvbi5maWx0ZXJFeHByZXNzaW9uIHx8IHJlbGF0aW9uLnNvcnRFeHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0ZpbHRlciBhbmQgU29ydCBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aCBHZXRCeUZpbHRlciBzY2VuYXJpby4nO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzR2V0QnlGaWx0ZXJRdWVyeSAmJiByZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdFeHBhbmRpbmcgYW4gZXh0ZXJuYWwgY29udGVudCB0eXBlIGlzIG5vdCBhbGxvd2VkIHdpdGggR2V0QnlGaWx0ZXIgc2NlbmFyaW8uJztcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlbGF0aW9uLnRhcmdldFR5cGVOYW1lKSB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdFeHBhbmRpbmcgcmVsYXRpb24gXFxcIicgKyByZWxhdGlvbi5yZWxhdGlvbkZpZWxkICsgJ1xcXCIgaGFzIG5vIHRhcmdldCB0eXBlIG5hbWUgc3BlY2lmaWVkLiBZb3Ugc2hvdWxkIHVzZSBcXFwiVGFyZ2V0VHlwZU5hbWVcXFwiIHRvIHNwZWNpZnkgaXQuJztcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24gJiYgT2JqZWN0LmtleXMocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbikubGVuZ3RoICYmIHJlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZSkge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSByZWxhdGlvbi5wYXRoICsgJyAnO1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSAnZXhwYW5kIGV4cHJlc3Npb24gY29udGFpbnMgYm90aCBcXFwiRmllbGRzXFxcIiBhbmQgXFxcIlNpbmdsZUZpZWxkXFxcIiBleHByZXNzaW9ucy4nO1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICB9XHJcbiAgICBpZiAocmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gcmVsYXRpb24ucGF0aCArICcgaGFzIG11bHRpcGxlIGV4cGFuZCBleHByZXNzaW9ucyB3aXRoIGEgc2luZ2xlIGZpZWxkIG9wdGlvbi4nICsgRU9MO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdGhpcy5tYXBbcmVsYXRpb24uY2hpbGRyZW5bMF1dLnJlbGF0aW9uRmllbGQgIT09IHJlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdFeHBhbmQgZXhwcmVzc2lvbiAnICsgcmVsYXRpb24ucGF0aDtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnIHNpbmdsZSBmaWVsZCBcXFwiJyArIHJlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZSArICdcXFwiJztcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnIGRvZXMgbm90IG1hdGNoIGNoaWxkIHJlbGF0aW9uIGZpZWxkIFxcXCInICsgdGhpcy5tYXBbcmVsYXRpb24uY2hpbGRyZW5bMF1dLnJlbGF0aW9uRmllbGQgKyAnXFxcIi4nO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGNvdW50IG9mIHBhcmVudCBtdWx0aXBsZSByZWxhdGlvbnMuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFN0YXJ0aW5nIHJlbGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGNvdW50IG9mIGFsbCBwYXJlbnQgbXVsdGlwbGUgcmVsYXRpb25zXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRQYXJlbnRNdWx0aXBsZVJlbGF0aW9uc0NvdW50ID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gMDtcclxuICAgIHZhciByZWxhdGlvbkZvckxvb3AgPSByZWxhdGlvbjtcclxuICAgIHdoaWxlIChyZWxhdGlvbkZvckxvb3AucGFyZW50KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uID0gdGhpcy5tYXBbcmVsYXRpb25Gb3JMb29wLnBhcmVudF07XHJcbiAgICAgICAgaWYgKHBhcmVudFJlbGF0aW9uLmlzQXJyYXkoKSAmJiBwYXJlbnRSZWxhdGlvbi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbGF0aW9uRm9yTG9vcCA9IHBhcmVudFJlbGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQWRqdXN0cyBmaWVsZHMgZXhwcmVzc2lvbiBvZiB0aGUgcGFyZW50IHJlbGF0aW9uIGJhc2VkIG9uIHBhZ2luZyBzZXR0aW5nIG9mIGEgcmVsYXRpb24gKHNraXAsIHRha2UpLlxyXG4gKiBJbiB0aGF0IGNhc2Ugd2UgcHV0IGEgXCIkc2xpY2VcIiBvcHRpb24gd2l0aGluIHRoZSBwYXJlbnQgcmVsYXRpb24gZmllbGRzIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSBwYXJlbnRSZWxhdGlvblxyXG4gKiBAcGFyYW0gcmVsYXRpb25cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRqdXN0UGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBhcmVudFJlbGF0aW9uLCByZWxhdGlvbikge1xyXG4gICAgaWYgKCFyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24gJiYgcmVsYXRpb24udGFrZSAmJiB0eXBlb2YgcmVsYXRpb24udGFrZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyB3aGVuIHJlbGF0aW9uIGhhcyBmaWx0ZXIgb3Igc29ydGluZyBza2lwIGFuZCB0YWtlIHNob3VsZCBub3QgYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBhcmVudCByZWxhdGlvbiBhcyAkc2xpY2UuXHJcbiAgICAgICAgdmFyIHNob3VsZFRyYW5zZmVyUGFnaW5nVG9QYXJlbnRSZWxhdGlvbiA9IHJlbGF0aW9uLmlzQXJyYXkoKSAmJiAhcmVsYXRpb24uZmlsdGVyRXhwcmVzc2lvbiAmJiAhcmVsYXRpb24uc29ydEV4cHJlc3Npb24gJiYgcGFyZW50UmVsYXRpb247XHJcbiAgICAgICAgaWYgKHNob3VsZFRyYW5zZmVyUGFnaW5nVG9QYXJlbnRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50UmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uID0ge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZWxhdGlvbi5za2lwICYmIHR5cGVvZiByZWxhdGlvbi5za2lwID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbltyZWxhdGlvbi5yZWxhdGlvbkZpZWxkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnJHNsaWNlJzogW3JlbGF0aW9uLnNraXAsIHJlbGF0aW9uLnRha2VdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbltyZWxhdGlvbi5yZWxhdGlvbkZpZWxkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnJHNsaWNlJzogcmVsYXRpb24udGFrZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWxhdGlvbi50YWtlID0gbnVsbDtcclxuICAgICAgICAgICAgcmVsYXRpb24uc2tpcCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uLm1vdmVkU2tpcFRha2VBc1NsaWNlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBmaWVsZCB0byBwYXJlbnQgcmVsYXRpb24gZmllbGRzIGV4cHJlc3Npb24uIEZvciBleGFtcGxlIGlmIHRoZSByZWxhdGlvbiBmaWVsZCBpcyBleGNsdWRlZCBmcm9tIHRoZSBtYXN0ZXIgcmVxdWVzdC5cclxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb24gLSBGaWVsZHMgZXhwcmVzc2lvbiBvZiB0aGUgcGFyZW50IHJlbGF0aW9uLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25GaWVsZCAtIE5hbWUgb2YgdGhlIGZpZWxkIHdoaWNoIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoZmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb25GaWVsZCkge1xyXG4gICAgaWYgKGZpZWxkc0V4cHJlc3Npb24gPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhmaWVsZHNFeHByZXNzaW9uKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgaXNFeGNsdXNpdmUgPSBSZWxhdGlvblRyZWVCdWlsZGVyLmdldElzRmllbGRzRXhwcmVzc2lvbkV4Y2x1c2l2ZShmaWVsZHNFeHByZXNzaW9uKTtcclxuXHJcbiAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICBkZWxldGUgZmllbGRzRXhwcmVzc2lvbltyZWxhdGlvbkZpZWxkXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmllbGRzRXhwcmVzc2lvbltyZWxhdGlvbkZpZWxkXSA9IDE7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBpZiB0aGUgZmllbGRzIGV4cHJlc3Npb24gaXMgZXhjbHVzaXZlIChcIkZpZWxkTmFtZVwiIDogMClcclxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb24gLSBGaWVsZHMgZXhwcmVzc2lvbiB0byBjaGVjay5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLmdldElzRmllbGRzRXhwcmVzc2lvbkV4Y2x1c2l2ZSA9IGZ1bmN0aW9uIChmaWVsZHNFeHByZXNzaW9uKSB7XHJcbiAgICB2YXIgaXNFeGNsdXNpdmU7XHJcbiAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzRXhwcmVzc2lvbikge1xyXG4gICAgICAgIGlmIChmaWVsZE5hbWUgIT09IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCAmJiBmaWVsZHNFeHByZXNzaW9uLmhhc093blByb3BlcnR5KGZpZWxkTmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZHNFeHByZXNzaW9uW2ZpZWxkTmFtZV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0V4Y2x1c2l2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZHNFeHByZXNzaW9uW2ZpZWxkTmFtZV0gPT09IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFeGNsdXNpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzRXhjbHVzaXZlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvblRyZWVCdWlsZGVyO1xyXG4iLCIvKiFcclxuICogYXN5bmNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE0IENhb2xhbiBNY01haG9uXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLypqc2hpbnQgb25ldmFyOiBmYWxzZSwgaW5kZW50OjQgKi9cclxuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGFzeW5jID0ge307XHJcblxyXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xyXG5cclxuICAgIHJvb3QgPSB0aGlzO1xyXG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xyXG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcclxuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xyXG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmbi5hcHBseShyb290LCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXHJcblxyXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG4gICAgdmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChpdGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcclxuICAgICAgICBpZiAoYXJyLm1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XHJcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XHJcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWVtbztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXHJcblxyXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGRvbmUpICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xyXG5cclxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XHJcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGl0ZXJhdGUoKTtcclxuICAgIH07XHJcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcclxuXHJcbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XHJcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xyXG5cclxuICAgIHZhciBfZWFjaExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcclxuXHJcbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcclxuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XHJcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xyXG4gICAgICAgIHJldHVybiBkb1BhcmFsbGVsTGltaXQobGltaXQsIF9hc3luY01hcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcclxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxyXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XHJcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBpbmplY3QgYWxpYXNcclxuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcclxuICAgIC8vIGZvbGRsIGFsaWFzXHJcbiAgICBhc3luYy5mb2xkbCA9IGFzeW5jLnJlZHVjZTtcclxuXHJcbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9KS5yZXZlcnNlKCk7XHJcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIC8vIGZvbGRyIGFsaWFzXHJcbiAgICBhc3luYy5mb2xkciA9IGFzeW5jLnJlZHVjZVJpZ2h0O1xyXG5cclxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcclxuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XHJcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcclxuICAgIC8vIHNlbGVjdCBhbGlhc1xyXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xyXG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xyXG5cclxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xyXG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XHJcblxyXG4gICAgdmFyIF9kZXRlY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgbWFpbl9jYWxsYmFjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmRldGVjdCA9IGRvUGFyYWxsZWwoX2RldGVjdCk7XHJcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcclxuXHJcbiAgICBhc3luYy5zb21lID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBhbnkgYWxpYXNcclxuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XHJcblxyXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xyXG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBhbGwgYWxpYXNcclxuICAgIGFzeW5jLmFsbCA9IGFzeW5jLmV2ZXJ5O1xyXG5cclxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGZuKSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGhcclxuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlbWFpbmluZ1Rhc2tzLS1cclxuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZpbmFsIGNhbGxiYWNrIGZyb20gY2FsbGluZyBpdHNlbGYgaWYgaXQgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXNrID0gX2lzQXJyYXkodGFza3Nba10pID8gdGFza3Nba106IFt0YXNrc1trXV07XHJcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xyXG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBERUZBVUxUX1RJTUVTID0gNTtcclxuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcclxuICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaWYgdGltZXMgbm90IHBhc3NlZFxyXG4gICAgICAgIGlmICh0eXBlb2YgdGltZXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xyXG4gICAgICAgICAgICB0YXNrID0gdGltZXM7XHJcbiAgICAgICAgICAgIHRpbWVzID0gREVGQVVMVF9USU1FUztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRpbWVzIGlzIGEgbnVtYmVyXHJcbiAgICAgICAgdGltZXMgPSBwYXJzZUludCh0aW1lcywgMTApIHx8IERFRkFVTFRfVElNRVM7XHJcbiAgICAgICAgdmFyIHdyYXBwZWRUYXNrID0gZnVuY3Rpb24od3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xyXG4gICAgICAgICAgICB2YXIgcmV0cnlBdHRlbXB0ID0gZnVuY3Rpb24odGFzaywgZmluYWxBdHRlbXB0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB3cmFwcGVkUmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAodGltZXMpIHtcclxuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KHRhc2ssICEodGltZXMtPTEpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXN5bmMuc2VyaWVzKGF0dGVtcHRzLCBmdW5jdGlvbihkb25lLCBkYXRhKXtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAod3JhcHBlZENhbGxiYWNrIHx8IGNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IHdyYXBwZWRUYXNrKCkgOiB3cmFwcGVkVGFza1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xyXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xyXG4gICAgICAgICAgICBlYWNoZm4ubWFwKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IGFzeW5jLm1hcCwgZWFjaDogYXN5bmMuZWFjaCB9LCB0YXNrcywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xyXG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gICAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcclxuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxyXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2IpIHtcclxuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xyXG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xyXG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XHJcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcclxuXHJcbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRlc3QoKSkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3luYy53aGlsc3QodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIXRlc3QoKSkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICBpZiAoIXRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcclxuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xyXG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XHJcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXHJcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcclxuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XHJcbiAgICAgICAgdmFyIHEgPSB7XHJcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcclxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxyXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxyXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcclxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAga2lsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHEuZHJhaW4gPSBudWxsO1xyXG4gICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IHRydWUpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFzeW5jLnByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XHJcbiAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBfYmluYXJ5U2VhcmNoKHNlcXVlbmNlLCBpdGVtLCBjb21wYXJlKSB7XHJcbiAgICAgICAgICB2YXIgYmVnID0gLTEsXHJcbiAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcclxuICAgICAgICAgIHdoaWxlIChiZWcgPCBlbmQpIHtcclxuICAgICAgICAgICAgdmFyIG1pZCA9IGJlZyArICgoZW5kIC0gYmVnICsgMSkgPj4+IDEpO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgYmVnID0gbWlkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBiZWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XHJcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXHJcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcclxuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcclxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZShfYmluYXJ5U2VhcmNoKHEudGFza3MsIGl0ZW0sIF9jb21wYXJlVGFza3MpICsgMSwgMCwgaXRlbSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXHJcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBPdmVycmlkZSBwdXNoIHRvIGFjY2VwdCBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBwcmlvcml0eVxyXG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXHJcbiAgICAgICAgZGVsZXRlIHEudW5zaGlmdDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xyXG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxyXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgY2FyZ28gPSB7XHJcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcclxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxyXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcclxuICAgICAgICAgICAgZHJhaW46IG51bGwsXHJcbiAgICAgICAgICAgIGRyYWluZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluICYmICFjYXJnby5kcmFpbmVkKSBjYXJnby5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwLCB0YXNrcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgd29ya2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNhcmdvO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2NvbnNvbGVfZm4gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XHJcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XHJcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xyXG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XHJcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXHJcblxyXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XHJcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcclxuICAgICAgICB2YXIgcXVldWVzID0ge307XHJcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xyXG4gICAgICAgICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcXVldWVzKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcclxuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XHJcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjb3VudGVyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcFNlcmllcyhjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5zZXEgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XHJcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xyXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XSkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XHJcbiAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcclxuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xyXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XHJcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcclxuXHJcbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZuKG5leHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXh0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE5vZGUuanNcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XHJcbiAgICB9XHJcbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xyXG4gICAgfVxyXG5cclxufSgpKTtcclxuIiwidmFyIGJ1aWxkUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5idWlsZFByb21pc2U7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5QbGF0Zm9ybTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbnZhciBqc3R6ID0gY29tbW9uLmpzdHo7XHJcbnZhciBfID0gY29tbW9uLl87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBDdXJyZW50RGV2aWNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHB1c2hIYW5kbGVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEN1cnJlbnREZXZpY2UgPSBmdW5jdGlvbiAocHVzaEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9wdXNoSGFuZGxlciA9IHB1c2hIYW5kbGVyO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy9TdWZmaXggZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2sgZnVuY3Rpb25zXHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck1vZGUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgQ3VycmVudERldmljZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhIHB1c2ggdG9rZW4gZnJvbSB0aGUgZGV2aWNlIHZlbmRvciBhbmQgZW5hYmxlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgZGV2aWNlLiBPbmNlIHRoaXMgaXMgZG9uZSwgeW91IGNhbiByZWdpc3RlciB0aGUgZGV2aWNlIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNpbmcgdGhlIHJlZ2lzdGVyKCkgbWV0aG9kLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1B1c2hTZXR0aW5nc30gcHVzaFNldHRpbmdzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHZhcmlvdXMgc2V0dGluZ3MgZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMuIFRoaXMgbWV0aG9kIHJlcXVlc3RzIGEgcHVzaCB0b2tlbiBmcm9tIHRoZSBkZXZpY2UgdmVuZG9yIGFuZCBlbmFibGVzIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuIE9uY2UgdGhpcyBpcyBkb25lLCB5b3UgY2FuIHJlZ2lzdGVyIHRoZSBkZXZpY2UgaW4gRXZlcmxpdmUgdXNpbmcgdGhlIHJlZ2lzdGVyKCkgbWV0aG9kLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge1B1c2hTZXR0aW5nc30gcHVzaFNldHRpbmdzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHZhcmlvdXMgc2V0dGluZ3MgZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5hYmxlTm90aWZpY2F0aW9uczogZnVuY3Rpb24gKHB1c2hTZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MgPSB0aGlzLl9jbGVhblBsYXRmb3Jtc1B1c2hTZXR0aW5ncyhwdXNoU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShfLmJpbmQodGhpcy5faW5pdGlhbGl6ZSwgdGhpcyksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXNhYmxlTm90aWZpY2F0aW9uczogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVucmVnaXN0ZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaE5vdGlmaWNhdGlvbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXJPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBzZWxmLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5XaW5kb3dzUGhvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck9wdGlvbnMgPSB7J2NoYW5uZWxOYW1lJzogc2VsZi5wdXNoU2V0dGluZ3Mud3A4LmNoYW5uZWxOYW1lfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi51bnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2dldERldmljZUlkKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEhhbmRsZXIuZGV2aWNlcy5nZXRCeUlkKCdIYXJkd2FyZUlkLycgKyBkZXZpY2VJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV0oI0N1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucykgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV0oI0N1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucykgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoY3VzdG9tUGFyYW1ldGVycywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tUGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGFyYW1ldGVycyA9IGN1c3RvbVBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3B1bGF0ZVJlZ2lzdHJhdGlvbk9iamVjdChkZXZpY2VSZWdpc3RyYXRpb24pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3B1c2hIYW5kbGVyLmRldmljZXMuY3JlYXRlKGRldmljZVJlZ2lzdHJhdGlvbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZyb20gcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEFmdGVyIHRoaXMgY2FsbCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB7e3NpdGUuYnN9fSB3aWxsIG5vIGxvbmdlciBzZW5kIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2UuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIGRldmljZSBmcm9tIHJlY2VpdmluZyBub3RpZmljYXRpb25zIGFuZCBkb2VzIG5vdCBpbnZhbGlkYXRlIHB1c2ggdG9rZW5zLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZyb20gcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEFmdGVyIHRoaXMgY2FsbCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB7e3NpdGUuYnN9fSB3aWxsIG5vIGxvbmdlciBzZW5kIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2UuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIGRldmljZSBmcm9tIHJlY2VpdmluZyBub3RpZmljYXRpb25zIGFuZCBkb2VzIG5vdCBpbnZhbGlkYXRlIHB1c2ggdG9rZW5zLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UudXVpZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoSGFuZGxlci5kZXZpY2VzLmRlc3Ryb3lTaW5nbGUoe0lkOiAnSGFyZHdhcmVJZC8nICsgZGV2aWNlSWR9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QYXJhbWV0ZXJzID0gY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0KGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSWQgPSAnSGFyZHdhcmVJZC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy51cGRhdGVTaW5nbGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaW5pdGlhbGl6ZUludGVyYWN0aXZlUHVzaDogZnVuY3Rpb24gKGlPU1NldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgcHVzaFBsdWdpbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJhY3RpdmVTZXR0aW5ncyA9IGlPU1NldHRpbmdzLmludGVyYWN0aXZlU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25UeXBlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoaU9TU2V0dGluZ3MuYWxlcnQpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGVzLnB1c2gocHVzaFBsdWdpbi5Vc2VyTm90aWZpY2F0aW9uVHlwZXMuQWxlcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpT1NTZXR0aW5ncy5iYWRnZSkge1xyXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZXMucHVzaChwdXNoUGx1Z2luLlVzZXJOb3RpZmljYXRpb25UeXBlcy5CYWRnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlPU1NldHRpbmdzLnNvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25UeXBlcy5wdXNoKHB1c2hQbHVnaW4uVXNlck5vdGlmaWNhdGlvblR5cGVzLlNvdW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdldEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb25JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gXy5maW5kKGludGVyYWN0aXZlU2V0dGluZ3MuYWN0aW9ucywgZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uaWRlbnRpZmllciA9PT0gYWN0aW9uSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb247XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0gXy5tYXAoaW50ZXJhY3RpdmVTZXR0aW5ncy5jYXRlZ29yaWVzLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogY2F0ZWdvcnkuaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRm9yRGVmYXVsdENvbnRleHQ6IF8ubWFwKGNhdGVnb3J5LmFjdGlvbnNGb3JEZWZhdWx0Q29udGV4dCwgZ2V0QWN0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRm9yTWluaW1hbENvbnRleHQ6IF8ubWFwKGNhdGVnb3J5LmFjdGlvbnNGb3JNaW5pbWFsQ29udGV4dCwgZ2V0QWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHB1c2hQbHVnaW4ucmVnaXN0ZXJVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MoXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3VjY2VzcyBjYWxsYmFjayB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHJldHVybiAoQVBOcyBpcyBub3QgY29udGFjdGVkIGZvciB0aGlzKVxyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBpbiBjYXNlIHRoZSBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc2tpbmcgcGVybWlzc2lvbiBmb3IgdGhlc2UgZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICB0eXBlczogbm90aWZpY2F0aW9uVHlwZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlc2UgY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL0luaXRpYWxpemVzIHRoZSBwdXNoIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS5cclxuICAgICAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignUHVzaCBub3RpZmljYXRpb25zIGFyZSBjdXJyZW50bHkgaW5pdGlhbGl6aW5nLicpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtdWxhdG9yTW9kZSAmJiAoIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgZ2xvYmFsaXphdGlvbiBwbHVnaW4gaXMgbm90IGluaXRpYWxpemVkLicpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtdWxhdG9yTW9kZSAmJiAoIXdpbmRvdy5wbHVnaW5zIHx8ICF3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBwdXNoIG5vdGlmaWNhdGlvbnMgcGx1Z2luIGlzIG5vdCBpbml0aWFsaXplZC4nKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBzdWNjZXNzO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0RXJyb3JDYWxsYmFjayA9IGVycm9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0aGlzLnB1c2hUb2tlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MoJ2Zha2VfcHVzaF90b2tlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgMTAwMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXg7XHJcbiAgICAgICAgICAgIGlmICghc3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeCA9IHN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IHRoaXMuX2dldFBsYXRmb3JtVHlwZShkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5pT1MpIHtcclxuICAgICAgICAgICAgICAgIC8vSW5pdGlhbGl6ZSBnbG9iYWwgQVBOIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB2YXIgYXBuQ2FsbGJhY2tOYW1lID0gJ2FwbkNhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW2FwbkNhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fb25Ob3RpZmljYXRpb25BUE4sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgaU9TIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICB2YXIgYXBuUmVnaXN0cmF0aW9uT3B0aW9ucyA9IHRoaXMucHVzaFNldHRpbmdzLmlPUztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlSU9TU2V0dGluZ3MoYXBuUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBhcG5DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgQVBOXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZmFpbGVkUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uQW5kcm9pZCkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBHQ00gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHZhciBnY21DYWxsYmFja05hbWUgPSAnZ2NtQ2FsbGJhY2tfJyArIHN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3NbZ2NtQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbkdDTSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSB0aGUgQW5kcm9pZCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5hbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBbmRyb2lkU2V0dGluZ3MoZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBnY21SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBnY21DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgR0NNXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2NtUmVnaXN0cmF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLldpbmRvd3NQaG9uZSkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBXUDggY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdwOENhbGxiYWNrTmFtZSA9ICd3cDhDYWxsYmFja18nICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHdwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja18nICsgc3VmZml4O1xyXG5cclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3Nbd3A4Q2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbldQOCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvbkVycm9yQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgdGhlIFdQOCAgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIHZhciB3cDhSZWdpc3RyYXRpb25PcHRpb25zID0gdGhpcy5wdXNoU2V0dGluZ3Mud3A4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVXUDhTZXR0aW5ncyh3cDhSZWdpc3RyYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOENhbGxiYWNrTmFtZTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMudWNjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25TdWNjZXNzQ2FsbGJhY2tOYW1lO1xyXG4gICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucy5lcnJjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrTmFtZTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi5yZWdpc3RlcihcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBjdXJyZW50IHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUDogZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHJlc3VsdC51cmkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUFuZHJvaWRTZXR0aW5nczogZnVuY3Rpb24gKGFuZHJvaWRTZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoIWFuZHJvaWRTZXR0aW5ncy5zZW5kZXJJRCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlbmRlciBJRCAocHJvamVjdCBudW1iZXIpIGlzIG5vdCBzZXQgaW4gdGhlIGFuZHJvaWQgc2V0dGluZ3MuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF92YWxpZGF0ZVdQOFNldHRpbmdzOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5jaGFubmVsTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ2NoYW5uZWxOYW1lIGlzIG5vdCBzZXQgaW4gdGhlIFdQOCBzZXR0aW5ncy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUlPU1NldHRpbmdzOiBmdW5jdGlvbiAoaU9TU2V0dGluZ3MpIHtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NsZWFuUGxhdGZvcm1zUHVzaFNldHRpbmdzOiBmdW5jdGlvbiAocHVzaFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGVhblNldHRpbmdzID0ge307XHJcbiAgICAgICAgICAgIHB1c2hTZXR0aW5ncyA9IHB1c2hTZXR0aW5ncyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtID0gZnVuY3Rpb24gYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShuZXdTZXR0aW5nc09iamVjdCwgcGxhdGZvcm0sIGFsbG93ZWRGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHVzaFNldHRpbmdzW3BsYXRmb3JtXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV0gPSBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV0gfHwge307XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGxhdGZvcm1TZXR0aW5ncyA9IHB1c2hTZXR0aW5nc1twbGF0Zm9ybV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBuZXdTZXR0aW5nc09iamVjdFtwbGF0Zm9ybV07XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goYWxsb3dlZEZpZWxkcywgZnVuY3Rpb24gKGFsbG93ZWRGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQbGF0Zm9ybVNldHRpbmdzLmhhc093blByb3BlcnR5KGFsbG93ZWRGaWVsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbYWxsb3dlZEZpZWxkXSA9IG5ld1BsYXRmb3JtU2V0dGluZ3NbYWxsb3dlZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0oY2xlYW5TZXR0aW5ncywgJ2lPUycsIFsnYmFkZ2UnLCAnc291bmQnLCAnYWxlcnQnLCAnaW50ZXJhY3RpdmVTZXR0aW5ncyddKTtcclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnYW5kcm9pZCcsIFsnc2VuZGVySUQnLCAncHJvamVjdE51bWJlciddKTtcclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnd3A4JywgWydjaGFubmVsTmFtZSddKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0ZpZWxkcyA9IFsnbm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkJywgJ25vdGlmaWNhdGlvbkNhbGxiYWNrSU9TJywgJ25vdGlmaWNhdGlvbkNhbGxiYWNrV1A4J107XHJcbiAgICAgICAgICAgIF8uZWFjaChjYWxsYmFja0ZpZWxkcywgZnVuY3Rpb24gKGNhbGxiYWNrRmllbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHB1c2hTZXR0aW5nc1tjYWxsYmFja0ZpZWxkXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBcIicgKyBjYWxsYmFja0ZpZWxkICsgJ1wiIG9mIHRoZSBwdXNoIHNldHRpbmdzIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzW2NhbGxiYWNrRmllbGRdID0gcHVzaFNldHRpbmdzW2NhbGxiYWNrRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwdXNoU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICAgICAgY2xlYW5TZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzID0gcHVzaFNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbGVhblNldHRpbmdzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wb3B1bGF0ZVJlZ2lzdHJhdGlvbk9iamVjdDogZnVuY3Rpb24gKGRldmljZVJlZ2lzdHJhdGlvbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5wdXNoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1B1c2ggdG9rZW4gaXMgbm90IGF2YWlsYWJsZS4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2dldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IHNlbGYuX2dldERldmljZUlkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFyZHdhcmVNb2RlbCA9IGRldmljZS5tb2RlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBzZWxmLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lWm9uZSA9IGpzdHouZGV0ZXJtaW5lKCkubmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1c2hUb2tlbiA9IHNlbGYucHVzaFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gbG9jYWxlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVmVyc2lvbiA9IGRldmljZS52ZXJzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkID0gZGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSGFyZHdhcmVNb2RlbCA9IGhhcmR3YXJlTW9kZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGxhdGZvcm1UeXBlID0gcGxhdGZvcm1UeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBsYXRmb3JtVmVyc2lvbiA9IHBsYXRmb3JtVmVyc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5UaW1lWm9uZSA9IHRpbWVab25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlB1c2hUb2tlbiA9IHB1c2hUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5Mb2NhbGUgPSBsYW5ndWFnZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0TG9jYWxlTmFtZTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcyh7dmFsdWU6ICdlbl9VUyd9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGxvY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGV2aWNlSWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldmljZS51dWlkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vUmV0dXJucyB0aGUgRXZlcmxpdmUgZGV2aWNlIHBsYXRmb3JtIGNvbnN0YW50IGdpdmVuIGEgdmFsdWUgYXF1aXJlZCBmcm9tIGNvcmRvdmEncyBkZXZpY2UucGxhdGZvcm0uXHJcbiAgICAgICAgX2dldFBsYXRmb3JtVHlwZTogZnVuY3Rpb24gKHBsYXRmb3JtU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBwc0xvd2VyID0gcGxhdGZvcm1TdHJpbmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgc3dpdGNoIChwc0xvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpb3MnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaXBob25lJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lwYWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5pT1M7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhbmRyb2lkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uQW5kcm9pZDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbmNlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uV2luZG93c1Bob25lO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2luMzJudCc6IC8vIHJlYWwgd3A4IGRldmljZXMgcmV0dXJuIHRoaXMgc3RyaW5nIGFzIHBsYXRmb3JtIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLldpbmRvd3NQaG9uZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLlVua25vd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRFcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0RXJyb3JDYWxsYmFjayh7ZXJyb3I6IGVycm9yfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzczogZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFRva2VuID0gdG9rZW47XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrKHt0b2tlbjogdG9rZW59KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gdGhlIGRldmljZSByZWdpc3RyYXRpb24gaW4gQVBOIHN1Y2NlZWRzXHJcbiAgICAgICAgX3N1Y2Nlc3NmdWxSZWdpc3RyYXRpb25BUE46IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5pT1MgJiYgdGhpcy5wdXNoU2V0dGluZ3MuaU9TLmludGVyYWN0aXZlU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcmFjdGl2ZVB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MuaU9TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgaW50ZXJhY3RpdmUgcHVzaCBjb25maWd1cmF0aW9uIGlzIGluY29ycmVjdDogJyArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgaWYgdGhlIGRldmljZSByZWdpc3RyYXRpb24gaW4gQVBOIGZhaWxzXHJcbiAgICAgICAgX2ZhaWxlZFJlZ2lzdHJhdGlvbkFQTjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBkZXZpY2UgcmVnaXN0cmF0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50IHRvIEdDTVxyXG4gICAgICAgIF9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbkdDTTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgc2VudCByZXF1ZXN0IGZvciByZWdpc3RlcmluZyB3aXRoIEdDTS5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL09jY3VycyB3aGVuIGRldmljZSByZWdpc3RyYXRpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNlbnQgZm9yIFdQOFxyXG4gICAgICAgIF9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbldQODogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgc2VudCByZXF1ZXN0IGZvciByZWdpc3RlcmluZyBXUDggLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gYW4gZXJyb3Igb2NjdXJlZCB3aGVuIHNlbmRpbmcgcmVnaXN0cmF0aW9uIHJlcXVlc3QgZm9yIFdQOFxyXG4gICAgICAgIF9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDg6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gYW4gZXJyb3Igb2NjdXJlZCB3aGVuIHNlbmRpbmcgcmVnaXN0cmF0aW9uIHJlcXVlc3QgdG8gR0NNXHJcbiAgICAgICAgX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTTogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gQVBOXHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uQVBOOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50SU9TKGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZvciBXUDhcclxuICAgICAgICBfb25Ob3RpZmljYXRpb25XUDg6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRXUDgoZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gR0NNXHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uR0NNOiBmdW5jdGlvbiBvbk5vdGlmaWNhdGlvbkdDTShlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZS5ldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVnaXN0ZXJlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucmVnaWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKGUucmVnaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wdXNoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrQW5kcm9pZChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRJT1M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50V1A4OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tXUDgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3VycmVudERldmljZTtcclxufSgpKTsiLCJ2YXIgU2V0dXAgPSByZXF1aXJlKCcuL1NldHVwJyk7XHJcbnZhciBEYXRhID0gcmVxdWlyZSgnLi90eXBlcy9EYXRhJyk7XHJcbnZhciB1c2Vyc01vZHVsZSA9IHJlcXVpcmUoJy4vdHlwZXMvVXNlcnMnKTtcclxudmFyIGZpbGVzTW9kdWxlID0gcmVxdWlyZSgnLi90eXBlcy9GaWxlcycpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgYnVpbGRBdXRoSGVhZGVyID0gdXRpbHMuYnVpbGRBdXRoSGVhZGVyO1xyXG52YXIgUHVzaCA9IHJlcXVpcmUoJy4vUHVzaCcpO1xyXG52YXIgQXV0aGVudGljYXRpb24gPSByZXF1aXJlKCcuL2F1dGgvQXV0aGVudGljYXRpb24nKTtcclxudmFyIG9mZmxpbmVNb2R1bGUgPSByZXF1aXJlKCcuL29mZmxpbmUvb2ZmbGluZScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgRXZlcmxpdmUgaW5zdGFuY2VzLlxyXG4gICAgLy8gVGhlIGVudHJ5IHBvaW50IGZvciB0aGUgU0RLLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEV2ZXJsaXZlXHJcbiAgICAgKiBAY2xhc3NkZXNjIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUge3tzaXRlLmJzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESy4gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBTREsuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTZXR1cCBvYmplY3QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBhIHN0cmluZyByZXByZXNlbnRpbmcgeW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gWW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVybD0vL2FwaS5ldmVybGl2ZS5jb20vdjEvXSAtIFRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IFVSTC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b2tlbl0gLSBBbiBhdXRoZW50aWNhdGlvbiB0b2tlbi4gVGhlIGluc3RhbmNlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwcmV2aW91c2x5IG9idGFpbmVkIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRva2VuVHlwZT1iZWFyZXJdIC0gVGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoYXQgaXMgdXNlZCBmb3IgYXV0aGVudGljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1lPWh0dHBdIC0gVGhlIFVSSSBzY2hlbWUgdXNlZCB0byBtYWtlIHJlcXVlc3RzLiBTdXBwb3J0ZWQgdmFsdWVzOiBodHRwLCBodHRwc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cz1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIFNESyB3aWxsIHBhcnNlIG9ubHkgY29tcGxldGUgZGF0ZSBzdHJpbmdzIChhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkKS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW11bGF0b3JNb2RlPWZhbHNlXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHNldCB0aGUgU0RLIGluIGVtdWxhdG9yIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZV0gLSBTZXQgdGhpcyBvcHRpb24gdG8gdHJ1ZSB0byB1c2UgdGhlIGRlZmF1bHQgb2ZmbGluZSBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuYXV0b1N5bmM9dHJ1ZV0gLSBXaGV0aGVyIHRvIHN5bmMgZGF0YSBhdXRvbWF0aWNhbGx5IHdoZW4gb2ZmaW5nIG9ubGluZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuaXNPbmxpbmU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzdG9yYWdlIGlzIGluIG9ubGluZSBtb2RlIGluaXRpYWxseS5cclxuICAgICAqIEBwYXJhbSB7Q29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3l8ZnVuY3Rpb259IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLmNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5PUNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnNdIC0gQSBjb25zdGFudCBzcGVjaWZ5aW5nIHRoZSBjb25mbGljdCByZXNvbHV0aW9uIHN0cmF0ZWd5IG9yIGEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjb25mbGljdHMuXHJcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VQcm92aWRlcnxvYmplY3R9IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLnN0b3JhZ2VQcm92aWRlclNldHRpbmdzPVN0b3JhZ2VQcm92aWRlci5Mb2NhbFN0b3JhZ2VdIC0gQW4gb2JqZWN0IHNwZWNpZnlpbmcgc2V0dGluZ3MgZm9yIHRoZSBvZmZsaW5lIHN0b3JhZ2UgcHJvdmlkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5zeW5jU3RhcnQ9bnVsbF0gLSBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgc3luY2hyb25pc2F0aW9uIHN0YXJ0cy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLnN5bmNFbmQ9bnVsbF0gLSBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN5bmNocm9uaXphdGlvbiBjb21wbGV0ZXMuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGxpc3Qgb2Ygc3luYyBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEV2ZXJsaXZlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zZXR1cCA9IG5ldyBTZXR1cChvcHRpb25zKTtcclxuICAgICAgICBfLmVhY2goaW5pdGlhbGl6YXRpb25zLCBmdW5jdGlvbiAoaW5pdCkge1xyXG4gICAgICAgICAgICBpbml0LmZ1bmMuY2FsbChzZWxmLCBvcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKEV2ZXJsaXZlLiQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgRXZlcmxpdmUuJCA9IHNlbGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5fZW1pdHRlclByb3h5ID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlcltldmVudF0uYXBwbHkodGhpcy5fZW1pdHRlciwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyUHJveHkoJ2FkZExpc3RlbmVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUub24gPSBFdmVybGl2ZS5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXJQcm94eSgncmVtb3ZlTGlzdGVuZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vZmYgPSBFdmVybGl2ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlclByb3h5KCdvbmNlJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyUHJveHkoJ3JlbW92ZUFsbExpc3RlbmVycycsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAqIEB0eXBlIHtFdmVybGl2ZX1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUuJCA9IG51bGw7XHJcbiAgICBFdmVybGl2ZS5pZEZpZWxkID0gY29uc3RhbnRzLmlkRmllbGQ7XHJcblxyXG5cclxuICAgIC8vIEFuIGFycmF5IGtlZXBpbmcgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb25zIGNhbGxlZCBieSB0aGUgRXZlcmxpdmUgY29uc3RydWN0b3IuXHJcbiAgICAvLyBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSB1c2VkIHRvIGV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBFdmVybGl2ZSBpbnN0YW5jZS5cclxuICAgIHZhciBpbml0aWFsaXphdGlvbnMgPSBbXTtcclxuXHJcbiAgICAvKiogQW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgYXJlIGludm9rZWQgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9uW119XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5pbml0aWFsaXphdGlvbnMgPSBpbml0aWFsaXphdGlvbnM7XHJcblxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmEgU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJucyB7RXZlcmxpdmV9IFRoZSBpbnN0YW5jZSBvZiB0aGUge3tzaXRlLmJzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESyB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBFdmVybGl2ZS4kID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZXJsaXZlKG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YSh0aGlzLnNldHVwLCBjb2xsZWN0aW9uTmFtZSwgdGhpcy5vZmZsaW5lU3RvcmFnZSwgdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVVJMIHRvIHRoZSB7e3NpdGUuYnN9fSBhcHBsaWNhdGlvbiBlbmRwb2ludCB0aGF0IHRoZSBTREsgdXNlcy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgYnVpbGRVcmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgVVJMLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYnVpbGRVcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESyB0byBtYWtlIHJlcXVlc3RzIHRvIHRoZSB7e3NpdGUuYnN9fSBzZXJ2ZXJzLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBdXRob3JpemF0aW9uSGVhZGVycyBUaGUgZ2VuZXJhdGVkIEF1dGhvcml6YXRpb24gaGVhZGVycyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkQXV0aEhlYWRlcih0aGlzLnNldHVwKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUuZGlzYWJsZVJlcXVlc3RDYWNoZSA9IGZ1bmN0aW9uICh1cmwsIG1ldGhvZCkge1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gdXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xyXG4gICAgICAgICAgICB1cmwgKz0gc2VwYXJhdG9yICsgJ19lbD0nICsgdGltZXN0YW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUuQXV0aFN0YXR1cyA9IGNvbnN0YW50cy5BdXRoU3RhdHVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGF1dGhJbmZvXHJcbiAgICAgKiBAbmFtZSBhdXRoSW5mb1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBhdXRoSW5mb1xyXG4gICAgICogQG5hbWUgYXV0aEluZm9cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYXV0aEluZm8gPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNldHVwID0gc2VsZi5zZXR1cDtcclxuICAgICAgICAgICAgaWYgKHNldHVwLm1hc3RlcktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5tYXN0ZXJLZXl9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR1cC50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy51bmF1dGhlbnRpY2F0ZWR9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuYXV0aGVudGljYXRpb24gJiYgc2VsZi5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuVXNlcnNcclxuICAgICAgICAgICAgICAgIC5za2lwQXV0aCh0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmN1cnJlbnRVc2VyKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0ZWQsIHVzZXI6IHJlcy5yZXN1bHR9KTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdXRoZW50aWNhdGlvbiAmJiBzZWxmLmF1dGhlbnRpY2F0aW9uLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRSZXF1ZXN0LmNvZGUgfHwgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7IC8vIGludmFsaWQgcmVxdWVzdCwgaS5lLiB0aGUgYWNjZXNzIHRva2VuIGlzIGludmFsaWQgb3IgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmludmFsaWRBdXRoZW50aWNhdGlvbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIGEgcmVxdWVzdCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZXRob2QgcmVxdWVzdFxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT2JqZWN0IHVzZWQgdG8gY29uZmlndXJlIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmVuZHBvaW50XSBUaGUgZW5kcG9pbnQgb2YgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgQVBJIHJlbGF0aXZlIHRvIHRoZSBBUEkga2V5IHNlY3Rpb24uIChGb3IgZXhhbXBsZSwgb3B0aW9ucy5lbmRwb2ludCA9IE15VHlwZSB3aWxsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBNeVR5cGUgdHlwZS4pXHJcbiAgICAgKiBAcGFyYW0ge0h0dHBNZXRob2R9IFtvcHRpb25zLm1ldGhvZF0gSFRUUCByZXF1ZXN0IG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5kYXRhXSBEYXRhIHRvIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIFN1Y2Nlc3MgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVzIHN1Y2Nlc3NmdWxseS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSBFcnJvciBjYWxsYmFjayB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0ge1F1ZXJ5fG9iamVjdH0gW29wdGlvbnMuZmlsdGVyXSBUaGlzIGlzIGVpdGhlciBhIHtAbGluayBRdWVyeX0gb3IgYSBbZmlsdGVyXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZXhwcmVzc2lvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0aEhlYWRlcnM9dHJ1ZV0gV2hlbiBzZXQgdG8gZmFsc2UsIG5vIEF1dGhvcml6YXRpb24gaGVhZGVycyB3aWxsIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHNlbmRgIGZ1bmN0aW9uIHRoYXQgc2VuZHMgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcy5zZXR1cCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb3RlY3RPZmZsaW5lRW5hYmxlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1lvdSBoYXZlIGluc3RhbnRpYXRlZCB0aGUgU0RLIHdpdGhvdXQgc3VwcG9ydCBmb3Igb2ZmbGluZSBzdG9yYWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zZXR1cC5vZmZsaW5lU3RvcmFnZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBTREsgdG8gd29yayBpbiBvZmZsaW5lIG1vZGVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29mZmxpbmVdIEJvb2xlYW4gcGFyYW1ldGVyIGZvciBzZXR0aW5nIHRoZSBTREsgdG8gb25saW5lIG9yIG9mZmxpbmUgbW9kZVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUub2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm90ZWN0T2ZmbGluZUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIGlzT2ZmbGluZTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpc09mZmxpbmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlzT2ZmbGluZSA9IGFyZ3VtZW50c1swXSA9PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlLl9zZXRPZmZsaW5lKGlzT2ZmbGluZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgU0RLIHRvIHdvcmsgaW4gb25saW5lIG1vZGVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29ubGluZV0gQm9vbGVhbiBwYXJhbWV0ZXIgZm9yIHNldHRpbmcgdGhlIFNESyB0byBvbmxpbmUgb3Igb2ZmbGluZSBtb2RlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIHZhciBpc09ubGluZTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpc09ubGluZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXNPbmxpbmUgPSBhcmd1bWVudHNbMF0gPT0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZS5fc2V0T2ZmbGluZSghaXNPbmxpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBTREsgaXMgaW4gb2ZmbGluZSBtb2RlXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNPZmZsaW5lIFJldHVybnMgdHJ1ZSBpZiB0aGUgU0RLIGlzIGluIG9mZmxpbmUgbW9kZVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuaXNPZmZsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc09ubGluZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBTREsgaXMgaW4gb25saW5lIG1vZGVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBpc09ubGluZSBSZXR1cm5zIHRydWUgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNPbmxpbmUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIHN5bmNocm9uaXphdGlvbiBwcm9jZWR1cmUuIEVtaXRzIHRoZSAnc3luY1N0YXJ0JyBldmVudCBvbmNlIHN0YXJ0ZWQgYW5kIHRoZSAnc3luY0VuZCcgZXZlbnQgb25jZSB0aGUgcHJvY2VkdXJlIGZpbmlzaGVzXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLnN5bmMuYXBwbHkodGhpcy5vZmZsaW5lU3RvcmFnZSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXREZWZhdWx0ID0gZnVuY3Rpb24gaW5pdERlZmF1bHQoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbVXNlcnNde0BsaW5rIFVzZXJzfSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHVzZXJzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1VzZXJzfSBVc2Vyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuVXNlcnMgPSB0aGlzLmRhdGEoJ1VzZXJzJyk7XHJcbiAgICAgICAgdXNlcnNNb2R1bGUuYWRkVXNlcnNGdW5jdGlvbnModGhpcy5Vc2VycywgdGhpcyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW0ZpbGVzXXtAbGluayBGaWxlc30gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBmaWxlcy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtGaWxlc30gRmlsZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLkZpbGVzID0gdGhpcy5kYXRhKCdGaWxlcycpO1xyXG4gICAgICAgIGZpbGVzTW9kdWxlLmFkZEZpbGVzRnVuY3Rpb25zKHRoaXMuRmlsZXMpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtQdXNoXXtAbGluayBQdXNofSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHB1c2ggbm90aWZpY2F0aW9ucy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQdXNofSBwdXNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IFB1c2godGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0QXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBpbml0QXV0aGVudGljYXRpb24oKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbQXV0aGVudGljYXRpb25de0BsaW5rIEF1dGhlbnRpY2F0aW9ufSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiBvZiB0aGUgU0RLLlxyXG4gICAgICAgICAqIEBtZW1iZXIge0F1dGhlbnRpY2F0aW9ufSBhdXRoZW50aWNhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb24gPSBuZXcgQXV0aGVudGljYXRpb24odGhpcywgdGhpcy5zZXR1cC5hdXRoZW50aWNhdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRpYWxpemF0aW9ucy5wdXNoKHtuYW1lOiAnb2ZmbGluZVN0b3JhZ2UnLCBmdW5jOiBvZmZsaW5lTW9kdWxlLmluaXRPZmZsaW5lU3RvcmFnZX0pO1xyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdkZWZhdWx0JywgZnVuYzogaW5pdERlZmF1bHR9KTtcclxuICAgIGluaXRpYWxpemF0aW9ucy5wdXNoKHtuYW1lOiAnYXV0aGVudGljYXRpb24nLCBmdW5jOiBpbml0QXV0aGVudGljYXRpb259KTtcclxuXHJcbiAgICByZXR1cm4gRXZlcmxpdmU7XHJcbn0oKSk7XHJcbiIsInZhciBFdmVybGl2ZUVycm9ycyA9IHtcclxuICAgIGl0ZW1Ob3RGb3VuZDoge1xyXG4gICAgICAgIGNvZGU6IDgwMSxcclxuICAgICAgICBtZXNzYWdlOiAnSXRlbSBub3QgZm91bmQuJ1xyXG4gICAgfSxcclxuICAgIHN5bmNDb25mbGljdDoge1xyXG4gICAgICAgIGNvZGU6IDQyNDIsXHJcbiAgICAgICAgbWVzc2FnZTogJ0EgY29uZmxpY3Qgb2NjdXJyZWQgd2hpbGUgc3luY2luZyBkYXRhLidcclxuICAgIH0sXHJcbiAgICBzeW5jRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiA0MjQzLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdTeW5jaHJvbml6YXRpb24gZmFpbGVkIGZvciBpdGVtLidcclxuICAgIH0sXHJcbiAgICBzeW5jSW5Qcm9ncmVzczoge1xyXG4gICAgICAgIGNvZGU6IDQyNDQsXHJcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiB3aGlsZSBzeW5jaHJvbml6YXRpb24gaXMgaW4gcHJvZ3Jlc3MnXHJcbiAgICB9LFxyXG4gICAgZ2VuZXJhbERhdGFiYXNlRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiAxMDcsXHJcbiAgICAgICAgbWVzc2FnZTogJ0dlbmVyYWwgZGF0YWJhc2UgZXJyb3InXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZFRva2VuOiB7XHJcbiAgICAgICAgY29kZTogMzAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFjY2VzcyB0b2tlbidcclxuICAgIH0sXHJcbiAgICBleHBpcmVkVG9rZW46IHtcclxuICAgICAgICBjb2RlOiAzMDIsXHJcbiAgICAgICAgbWVzc2FnZTogJ0V4cGlyZWQgYWNjZXNzIHRva2VuJ1xyXG4gICAgfSxcclxuICAgIGludmFsaWRFeHBhbmRFeHByZXNzaW9uOiB7XHJcbiAgICAgICAgY29kZTogNjE4LFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGV4cGFuZCBleHByZXNzaW9uLidcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkUmVxdWVzdDoge1xyXG4gICAgICAgIGNvZGU6IDYwMSxcclxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXF1ZXN0LidcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBFdmVybGl2ZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZXJsaXZlRXJyb3IobWVzc2FnZSwgY29kZSkge1xyXG4gICAgICAgIHZhciB0bXAgPSBFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICB0bXAubmFtZSA9IHRoaXMubmFtZSA9ICdFdmVybGl2ZUVycm9yJztcclxuXHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdG1wLm1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wLnN0YWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgRXZlcmxpdmVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcclxuICAgICAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRXZlcmxpdmVFcnJvcjtcclxufSgpKTtcclxuXHJcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JUeXBlLCBtZXNzYWdlLCBhZGRpdGlvbmFsSW5mb3JtYXRpb24pIHtcclxuICAgICAgICBFdmVybGl2ZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5lcnJvclR5cGUgPSBlcnJvclR5cGU7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbEluZm9ybWF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsSW5mb3JtYXRpb24gPSBhZGRpdGlvbmFsSW5mb3JtYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZXJsaXZlRXJyb3IucHJvdG90eXBlKTtcclxuXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvciA9IGZ1bmN0aW9uIChldmVybGl2ZUVycm9yKSB7XHJcbiAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbkVycm9yKERldmljZVJlZ2lzdHJhdGlvbkVycm9yVHlwZXMuRXZlcmxpdmVFcnJvciwgZXZlcmxpdmVFcnJvci5tZXNzYWdlLCBldmVybGl2ZUVycm9yKTtcclxuICAgICAgICByZXR1cm4gZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbiAgICB9O1xyXG5cclxuICAgIERldmljZVJlZ2lzdHJhdGlvbkVycm9yLmZyb21QbHVnaW5FcnJvciA9IGZ1bmN0aW9uIChlcnJvck9iaikge1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0EgcGx1Z2luIGVycm9yIG9jY3VycmVkJztcclxuICAgICAgICBpZiAoZXJyb3JPYmopIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvck9iai5lcnJvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvck9iai5lcnJvcjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JPYmoubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvck9iai5tZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IoRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JUeXBlcy5QbHVnaW5FcnJvciwgbWVzc2FnZSwgZXJyb3JPYmopO1xyXG4gICAgICAgIHJldHVybiBkZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yVHlwZXMgPSB7XHJcbiAgICAgICAgRXZlcmxpdmVFcnJvcjogMSxcclxuICAgICAgICBQbHVnaW5FcnJvcjogMlxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbn0oKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEV2ZXJsaXZlRXJyb3I6IEV2ZXJsaXZlRXJyb3IsXHJcbiAgICBFdmVybGl2ZUVycm9yczogRXZlcmxpdmVFcnJvcnMsXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcjogRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JcclxufTsiLCJ2YXIgUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9jb21tb24nKS5Qcm9jZXNzb3I7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvY2Vzc29yKHtcclxuICAgICAgICBleGVjdXRpb25Ob2RlRnVuY3Rpb246IGZ1bmN0aW9uIChub2RlLCBleHBhbmRDb250ZXh0LCBkb25lKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IG5vZGUudGFyZ2V0VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG5ldyBRdWVyeShub2RlLmZpbHRlciwgbm9kZS5zZWxlY3QsIG5vZGUuc29ydCwgbm9kZS5za2lwLCBub2RlLnRha2UpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZXhwYW5kQ29udGV4dC5vZmZsaW5lTW9kdWxlLnByb2Nlc3NRdWVyeShxdWVyeSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCBkYXRhLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGRvbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KCkpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uKG9wZXJhdG9yLCBvcGVyYW5kcykge1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuICAgICAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHMgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgYWRkT3BlcmFuZDogZnVuY3Rpb24gKG9wZXJhbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYW5kcy5wdXNoKG9wZXJhbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEV4cHJlc3Npb247XHJcbn0oKSk7IiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy9UT0RPIGFkZCBhIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2VzIGluIGdlb3NwYXRpYWwgcXVlcmllc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHZhbHVlIGZvciB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBHZW9Qb2ludCBmaWVsZC5cclxuICAgICAqIEBjbGFzcyBHZW9Qb2ludFxyXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSBMb25naXR1ZGUgb2YgdGhlIEdlb1BvaW50IGluIGRlY2ltYWwgZGVncmVlcyAocmFuZ2U6IC0xODAgdG8gMTgwKS4gRXhhbXBsZTogYDEyMy4zMjM5NDY3YFxyXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIExhdGl0dWRlIG9mIHRoZSBHZW9Qb2ludCBpbiBkZWNpbWFsIGRlZ3JlZXMgKHJhbmdlOiAtOTAgdG8gOTApLiBFeGFtcGxlOiBgNDIuNjk1NDMyMmBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2VvUG9pbnQobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlIHx8IDA7XHJcbiAgICAgICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEdlb1BvaW50O1xyXG59KCkpOyIsInZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxudmFyIGlzTmF0aXZlU2NyaXB0ID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XHJcbnZhciBpc05vZGVqcyA9IHBsYXRmb3JtLmlzTm9kZWpzO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2Uoc2RrKSB7XHJcbiAgICAgICAgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFNldHRpbmdzID0gcmVxdWlyZSgnYXBwbGljYXRpb24tc2V0dGluZ3MnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU2V0dGluZ3MuZ2V0U3RyaW5nKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5zZXRTdHJpbmcoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmFnZTtcclxuICAgICAgICAgICAgaWYgKGlzTm9kZWpzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTG9jYWxTdG9yYWdlID0gcmVxdWlyZSgnbm9kZS1sb2NhbHN0b3JhZ2UnKS5Mb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKHNkay5vZmZsaW5lU3RvcmFnZS5zZXR1cC5zdG9yYWdlLnN0b3JhZ2VQYXRoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIExvY2FsU3RvcmUoc2RrKSB7XHJcbiAgICAgICAgdGhpcy5zZGsgPSBzZGs7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlID0gZ2V0TG9jYWxTdG9yYWdlKHRoaXMuc2RrKTtcclxuICAgIH1cclxuXHJcbiAgICBMb2NhbFN0b3JlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIExvY2FsU3RvcmU7XHJcbn0oKSk7IiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgYnVpbGRQcm9taXNlID0gdXRpbHMuYnVpbGRQcm9taXNlO1xyXG52YXIgRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0ID0gdXRpbHMuRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0O1xyXG52YXIgZXZlcmxpdmVFcnJvck1vZHVsZSA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpO1xyXG52YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkRldmljZVJlZ2lzdHJhdGlvbkVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcclxudmFyIEN1cnJlbnREZXZpY2UgPSByZXF1aXJlKCcuL0N1cnJlbnREZXZpY2UnKTtcclxudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5QbGF0Zm9ybTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFB1c2hcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgcHVzaCBub3RpZmljYXRpb25zIGluIHlvdXIgYXBwbGljYXRpb24uIFN1cHBvcnRlZCBhcmUgcHVzaCBub3RpZmljYXRpb25zIGZvciBoeWJyaWQgYXBwcyBvbiBBbmRyb2lkIGFuZCBpT1MuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gZWwge0V2ZXJsaXZlfSBFdmVybGl2ZSBPYmplY3RcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUHVzaChlbCkge1xyXG4gICAgICAgIHRoaXMuX2VsID0gZWw7XHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gZWwuZGF0YSgnUHVzaC9Ob3RpZmljYXRpb25zJyk7XHJcbiAgICAgICAgdGhpcy5kZXZpY2VzID0gZWwuZGF0YSgnUHVzaC9EZXZpY2VzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgUHVzaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgVGVsZXJpayBQdXNoIE5vdGlmaWNhdGlvbnMgcGx1Zy1pbiBoYXMgYmVlbiBsb2FkZWQgYW5kIGlzIHJlYWR5IHRvIHVzZS4gQW4ge0V2ZXJsaXZlRXJyb3J9IGlzIHJldHVybmVkIGlmIHRoZSBwbHVnLWluIGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbnN1cmVQdXNoSXNBdmFpbGFibGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnN1cmVQdXNoSXNBdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGlzUHVzaE5vdGlmaWNhdGlvblBsdWdpbkF2YWlsYWJsZSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGx1Z2lucyAmJiB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNQdXNoTm90aWZpY2F0aW9uUGx1Z2luQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcihcIlRoZSBwdXNoIG5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgbm90IGF2YWlsYWJsZS4gRW5zdXJlIHRoYXQgdGhlIHB1c2hOb3RpZmljYXRpb24gcGx1Z2luIGlzIGluY2x1ZGVkIFwiICtcclxuICAgICAgICAgICAgICAgIFwiYW5kIHVzZSBhZnRlciBgZGV2aWNlcmVhZHlgIGV2ZW50IGhhcyBiZWVuIGZpcmVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHNlbmRpbmcgcHVzaCBub3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjIuN1xyXG4gICAgICAgICAqIEBzZWUgW1B1c2gucmVnaXN0ZXJde0BsaW5rIHB1c2gucmVnaXN0ZXJ9XHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjdXJyZW50RGV2aWNlXHJcbiAgICAgICAgICogQG5hbWUgY3VycmVudERldmljZVxyXG4gICAgICAgICAqIEBwYXJhbSBbZW11bGF0b3JNb2RlXSB7Qm9vbGVhbn0gSWYgc2V0IHRvIHRydWUsIGVtdWxhdG9yIG1vZGUgaXMgZW5hYmxlZCBtZWFuaW5nIHlvdSBjYW5ub3Qgc2VuZCBwdXNoIG5vdGlmaWNhdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge0N1cnJlbnREZXZpY2V9IFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ3VycmVudERldmljZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjdXJyZW50RGV2aWNlOiBmdW5jdGlvbiAoZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZW11bGF0b3JNb2RlID0gdGhpcy5fZWwuc2V0dXAuX2VtdWxhdG9yTW9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuY29yZG92YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0Vycm9yOiBjdXJyZW50RGV2aWNlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgaHlicmlkIG1vYmlsZSBhcHAsIGFmdGVyIFxcJ2RldmljZXJlYWR5XFwnIGV2ZW50IGhhcyBiZWVuIGZpcmVkLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnREZXZpY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnREZXZpY2UgPSBuZXcgQ3VycmVudERldmljZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudERldmljZS5lbXVsYXRvck1vZGUgPSBlbXVsYXRvck1vZGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudERldmljZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBvbiB0aGUgZGV2aWNlIGFuZCByZWdpc3RlcnMgaXQgZm9yIHRoZSBmZWF0dXJlIHdpdGgge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIElmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQsIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgZm9yIHRoZSByZWdpc3RyYXRpb24uIEl0IGNhbiBpbmNsdWRlIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIGJlIHN0b3JlZCBieSB7e3NpdGUuYnN9fS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuaU9TPW51bGwgaU9TLXNwZWNpZmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLmFsZXJ0PXRydWUgSWYgc2V0IHRvIHRydWUsIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiB3aWxsIGRpc3BsYXkgYXMgYSBzdGFuZGFyZCBpT1MgYWxlcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzZXR0aW5ncy5pT1MuYmFkZ2U9JysxJyBTcGVjaWZpZXMgdGhlIGJhZGdlIGNvdW50ZXIgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1Muc291bmQ9dHJ1ZSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGRldmljZSB3aWxsIHBsYXkgYSBub3RpZmljYXRpb24gc291bmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmFuZHJvaWQ9bnVsbCBBbmRyb2lkLXNwZWNpZmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5hbmRyb2lkLnNlbmRlcklEPW51bGwgWW91ciBHb29nbGUgQVBJIHByb2plY3QgbnVtYmVyLiBJdCBpcyByZXF1aXJlZCB3aGVuIG9idGFpbmluZyBhIHB1c2ggdG9rZW4gZm9yIGFuIEFuZHJvaWQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXI9bnVsbCBTeW5vbnltIGZvciBhbmRyb2lkLnNlbmRlcklELiBBdmFpbGFibGUgaW4gSmF2YVNjcmlwdCBTREsgdmVyc2lvbnMgMS4yLjcgYW5kIGxhdGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy53cDg9bnVsbCBXaW5kb3dzIFBob25lIHNwZWNpZmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgb24gdGhlIGRldmljZSBhbmQgcmVnaXN0ZXJzIGl0IGZvciB0aGUgZmVhdHVyZSB3aXRoIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLiBJZiBpdCBoYXMgYmVlbiByZWdpc3RlcmVkLCB0aGUgcmVnaXN0cmF0aW9uIGRldGFpbHMgYXJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC5cclxuICAgICAgICAgKiBJZiBpdCB3YXMgcmVnaXN0ZXJlZCB0aGUgcmVnaXN0cmF0aW9uIGRldGFpbHMgYXJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIFNldHRpbmdzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBDYW4gaW5jbHVkZSBjdXN0b20gcGFyYW1ldGVycyB0byBiZSBzYXZlZCBpbiBiYWNrZW5kIHNlcnZpY2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5pT1M9bnVsbCBpT1Mgc3BlY2lmaWMgc2V0dGluZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5hbGVydD10cnVlIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkZXZpY2Ugd2lsbCBkaXNwbGF5IGFuIGFsZXJ0IG1lc3NhZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzZXR0aW5ncy5pT1MuYmFkZ2U9JysxJyBTcGVjaWZpZXMgdGhlIGJhZGdlIGNvdW50ZXIgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1Muc291bmQ9dHJ1ZSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZGV2aWNlIHdpbGwgcGxheSBhIHNvdW5kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5hbmRyb2lkPW51bGwgQW5kcm9pZCBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5hbmRyb2lkLnNlbmRlcklEPW51bGwgVGhpcyBpcyB5b3VyIEdvb2dsZSBBUEkgcHJvamVjdCBudW1iZXIuIEl0IGlzIHJlcXVpcmVkIHdoZW4gb2J0YWluaW5nIGEgcHVzaCB0b2tlbiBmb3IgYW4gQW5kcm9pZCBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQucHJvamVjdE51bWJlcj1udWxsIFN5bm9ueW0gZm9yIGFuZHJvaWQuc2VuZGVySUQuIEF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0IFNESyB2ZXJzaW9ucyAxLjIuNyBhbmQgbGF0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLndwOD1udWxsIFdpbmRvd3MgUGhvbmUgc3BlY2lmaWMgc2V0dGluZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChzZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbmRyb2lkLnNlbmRlcklEID0gc2V0dGluZ3MuYW5kcm9pZC5wcm9qZWN0TnVtYmVyIHx8IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiAodG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGVycm9yQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbkVycm9yID0gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbUV2ZXJsaXZlRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlZ2lzdHJhdGlvbkVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjbGVhckJhZGdlSWZOZWVkZWQgPSBmdW5jdGlvbiAodG9rZW4sIHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IGN1cnJlbnREZXZpY2UuX2dldFBsYXRmb3JtVHlwZShkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyQmFkZ2UgPSBwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLmlPUztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJCYWRnZSAmJiBzZXR0aW5ncy5pT1MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckJhZGdlID0gc2V0dGluZ3MuaU9TLmNsZWFyQmFkZ2UgIT09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhckJhZGdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhckJhZGdlTnVtYmVyKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh0b2tlbiwgc3VjY2Vzc0NiKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRva2VuLCBzdWNjZXNzQ2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLmVuYWJsZU5vdGlmaWNhdGlvbnMoc2V0dGluZ3MsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLnRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21QYXJhbWV0ZXJzID0gc2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLmdldFJlZ2lzdHJhdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UudXBkYXRlUmVnaXN0cmF0aW9uKGN1c3RvbVBhcmFtZXRlcnMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckJhZGdlSWZOZWVkZWQodG9rZW4sIHN1Y2Nlc3NDYiwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gODAxKSB7IC8vTm90IHJlZ2lzdGVyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLnJlZ2lzdGVyKGN1c3RvbVBhcmFtZXRlcnMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJCYWRnZUlmTmVlZGVkKHRva2VuLCBzdWNjZXNzQ2IsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVyciwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IERldmljZVJlZ2lzdHJhdGlvbkVycm9yLmZyb21QbHVnaW5FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2IoZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLiBUaGUgZGV2aWNlIHdpbGwgYWxzbyBiZSB1bnJlZ2lzdGVyZWQgZnJvbSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LlxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAqIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIFRlbGVyaWsgQmFja2VuZCBTZXJ2aWNlcy5cclxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERldmljZS5kaXNhYmxlTm90aWZpY2F0aW9ucy5hcHBseShjdXJyZW50RGV2aWNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHJlZ2lzdHJhdGlvbiBvZiB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSWYge3VuZGVmaW5lZH0sIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSWYge3VuZGVmaW5lZH0sIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlUmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAoY3VzdG9tUGFyYW1ldGVycywgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERldmljZS51cGRhdGVSZWdpc3RyYXRpb24uYXBwbHkoY3VycmVudERldmljZSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gc2VydmVyLlxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmFkZ2UgVGhlIG51bWJlciB0byBiZSBzZXQgYXMgYSBiYWRnZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUgc2VydmVyXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiYWRnZSBUaGUgbnVtYmVyIHRvIGJlIHNldCBhcyBhIGJhZGdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0QmFkZ2VOdW1iZXI6IGZ1bmN0aW9uIChiYWRnZSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICBiYWRnZSA9IHBhcnNlSW50KGJhZGdlKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGJhZGdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignVGhlIGJhZGdlIG11c3QgaGF2ZSBhIG51bWVyaWMgdmFsdWUnKSk7XHJcbiAgICAgICAgICAgICAgICB9LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGN1cnJlbnREZXZpY2UuX2dldERldmljZUlkKCk7XHJcbiAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5JZCA9ICdIYXJkd2FyZUlkLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpO1xyXG4gICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uQmFkZ2VDb3VudGVyID0gYmFkZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERldmljZS5fcHVzaEhhbmRsZXIuZGV2aWNlcy51cGRhdGVTaW5nbGUoZGV2aWNlUmVnaXN0cmF0aW9uKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uLnNldEFwcGxpY2F0aW9uSWNvbkJhZGdlTnVtYmVyKHN1Y2Nlc3NDYiwgZXJyb3JDYiwgYmFkZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NDYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3JDYilcclxuICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBzZXJ2ZXIgdG8gMC5cclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyQmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbmFtZSBjbGVhckJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUgc2VydmVyIGJ5IHNldHRpbmcgaXQgdG8gMFxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIGNsZWFyQmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyQmFkZ2VOdW1iZXI6IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEJhZGdlTnVtYmVyKDAsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCBub3RpZmljYXRpb25zIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLmdldFJlZ2lzdHJhdGlvbi5hcHBseShjdXJyZW50RGV2aWNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbmRzIGEgcHVzaCBub3RpZmljYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBzZW5kXHJcbiAgICAgICAgICogQG5hbWUgc2VuZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVGhlIHB1c2ggbm90aWZpY2F0aW9uIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZW5kcyBhIHB1c2ggbWVzc2FnZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2VuZFxyXG4gICAgICAgICAqIEBuYW1lIHNlbmRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIFRoZSBwdXNoIG5vdGlmaWNhdGlvbiBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChub3RpZmljYXRpb24sIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucy5jcmVhdGUuYXBwbHkodGhpcy5ub3RpZmljYXRpb25zLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgZGlmZmVyZW50IG9wZXJhdGlvbiBvbiBlYWNoIHN1cHBvcnRlZCBwbGF0Zm9ybTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0gT24gaU9TOiBDaGVja3MgaWYgTm90aWZpY2F0aW9ucyBpcyBlbmFibGVkIGZvciB0aGlzIGFwcGxpY2F0aW9uIGluIHRoZSBkZXZpY2UncyBOb3RpZmljYXRpb24gQ2VudGVyLlxyXG4gICAgICAgICAqIC0gT24gV2luZG93cyBQaG9uZTogQ2hlY2tzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgYW4gYWN0aXZlIG9wZW4gY2hhbm5lbCBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBNaWNyb3NvZnQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZS4gVGhlIG91dGNvbWUgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSBkZXZpY2UncyBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogLSBPbiBBbmRyb2lkOiBDaGVja3MgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gd2l0aCBHb29nbGUgQ2xvdWQgTWVzc2FnaW5nLiBUaGUgb3V0Y29tZSBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIGRldmljZSdzIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG5hbWUgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBQdXNoIE5vdGlmaWNhdGlvbiBwbHVnaW4ncyBhcmVOb3RpZmljYXRpb25zRW5hYmxlZCBtZXRob2RcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGlPUzogQ2hlY2tzIGlmIHRoZSBOb3RpZmljYXRpb25zIGFyZSBlbmFibGVkIGZvciB0aGlzIEFwcGxpY2F0aW9uIGluIHRoZSBEZXZpY2UncyBOb3RpZmljYXRpb24gQ2VudGVyLlxyXG4gICAgICAgICAqIFdpbmRvd3MgUGhvbmU6IENoZWNrcyBpZiB0aGUgQXBwbGljYXRpb24gaGFzIGFuIGFjdGl2ZSBvcGVuZWQgQ2hhbm5lbCBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBOb3RpZmljYXRpb24gU2VydmljZS4gTm90IHJlbHlpbmcgb24gdGhlIGRldmljZSBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQW5kcm9pZDogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgZXN0YWJsaXNoZWQgY29ubmVjdGlvbiB3aXRoIHRoZSBOb3RpZmljYXRpb24gU2VydmljZS4gTm90IHJlbHlpbmcgb24gdGhlIGRldmljZSBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQG1ldGhvZCBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBuYW1lIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHBhc3NlZCB0byB0aGUgUHVzaCBOb3RpZmljYXRpb24gcGx1Z2luJ3MgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzZnVsIGNoZWNrLiBQYXNzZXMgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZTogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZXJyb3IgaW4gdGhlIHB1c2ggcGx1Z2luIGhhcyBvY2N1cnJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhcmVOb3RpZmljYXRpb25zRW5hYmxlZDogZnVuY3Rpb24gKG9wdGlvbnMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIHZhciBwdXNoTm90aWZpY2F0aW9uID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi5hcmVOb3RpZmljYXRpb25zRW5hYmxlZChzdWNjZXNzQ2IsIGVycm9yQ2IsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFB1c2g7XHJcbn0oKSk7IiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJy4vY29tbW9uJykucnN2cDtcclxudmFyIGJ1aWxkQXV0aEhlYWRlciA9IHV0aWxzLmJ1aWxkQXV0aEhlYWRlcjtcclxudmFyIHBhcnNlVXRpbGl0aWVzID0gdXRpbHMucGFyc2VVdGlsaXRpZXM7XHJcbnZhciBndWFyZFVuc2V0ID0gdXRpbHMuZ3VhcmRVbnNldDtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbnZhciByZXF3ZXN0ID0gY29tbW9uLnJlcXdlc3Q7XHJcbnZhciBfID0gY29tbW9uLl87XHJcbnZhciBIZWFkZXJzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5IZWFkZXJzO1xyXG52YXIgaXNOb2RlanMgPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOb2RlanM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgX3NlbGY7XHJcblxyXG4gICAgLy8gVGhlIFJlcXVlc3QgdHlwZSBpcyBhbiBhYnN0cmFjdGlvbiBvdmVyIEFqYXggbGlicmFyaWVzXHJcbiAgICAvLyBBIFJlcXVlc3Qgb2JqZWN0IG5lZWRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBFdmVybGl2ZSBjb25uZWN0aW9uIGFuZCBpbml0aWFsaXphdGlvbiBvcHRpb25zXHJcblxyXG4gICAgZnVuY3Rpb24gUmVxdWVzdChzZXR1cCwgb3B0aW9ucykge1xyXG4gICAgICAgIGd1YXJkVW5zZXQoc2V0dXAsICdzZXR1cCcpO1xyXG4gICAgICAgIGd1YXJkVW5zZXQob3B0aW9ucywgJ29wdGlvbnMnKTtcclxuICAgICAgICB0aGlzLnNldHVwID0gc2V0dXA7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XHJcbiAgICAgICAgLy8gVE9ETyBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3Mgc2hvdWxkIGJlIHVuaWZvcm1lZCBmb3IgYWxsIGFqYXggbGlic1xyXG4gICAgICAgIHRoaXMuc3VjY2VzcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXJzZSA9IFJlcXVlc3QucGFyc2Vycy5zaW1wbGU7XHJcblxyXG4gICAgICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIF9zZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIFJlcXVlc3QucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8vIENhbGxzIHRoZSB1bmRlcmx5aW5nIEFqYXggbGlicmFyeVxyXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgUmVxdWVzdC5zZW5kUmVxdWVzdCh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFJldHVybnMgYW4gYXV0aG9yaXphdGlvbiBoZWFkZXIgdXNlZCBieSB0aGUgcmVxdWVzdC5cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGxvZ2dlZCBpbiB1c2VyIGZvciB0aGUgRXZlcmxpdmUgaW5zdGFuY2UgdGhlbiBoZXIvaGlzIGF1dGhlbnRpY2F0aW9uIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICBidWlsZEF1dGhIZWFkZXI6IGJ1aWxkQXV0aEhlYWRlcixcclxuICAgICAgICAvLyBCdWlsZHMgdGhlIFVSTCBvZiB0aGUgdGFyZ2V0IEV2ZXJsaXZlIHNlcnZpY2VcclxuICAgICAgICBidWlsZFVybDogZnVuY3Rpb24gYnVpbGRVcmwoc2V0dXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHNldHVwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcXVlcnkgdG8gcmV0dXJuIGFwcHJvcHJpYXRlIGhlYWRlcnMgdG8gYmUgdXNlZCBieSB0aGUgcmVxdWVzdFxyXG4gICAgICAgIGJ1aWxkUXVlcnlIZWFkZXJzOiBmdW5jdGlvbiBidWlsZFF1ZXJ5SGVhZGVycyhxdWVyeSkge1xyXG4gICAgICAgICAgICBpZiAocXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIEV2ZXJsaXZlLlF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3QucHJvdG90eXBlLl9idWlsZFF1ZXJ5SGVhZGVycyhxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVxdWVzdC5wcm90b3R5cGUuX2J1aWxkRmlsdGVySGVhZGVyKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgUmVxdWVzdCBvYmplY3QgYnkgdXNpbmcgdGhlIHBhc3NlZCBvcHRpb25zXHJcbiAgICAgICAgX2luaXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIF8uZXh0ZW5kKHRoaXMuaGVhZGVycywgdGhpcy5idWlsZEF1dGhIZWFkZXIodGhpcy5zZXR1cCwgb3B0aW9ucyksIHRoaXMuYnVpbGRRdWVyeUhlYWRlcnMob3B0aW9ucy5maWx0ZXIpLCBvcHRpb25zLmhlYWRlcnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVHJhbnNsYXRlcyBhbiBFdmVybGl2ZS5RdWVyeSB0byByZXF1ZXN0IGhlYWRlcnNcclxuICAgICAgICBfYnVpbGRRdWVyeUhlYWRlcnM6IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kd2hlcmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5maWx0ZXJdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJHdoZXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHNlbGVjdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLnNlbGVjdF0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kc2VsZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHNvcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5zb3J0XSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiRzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHNraXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5za2lwXSA9IHF1ZXJ5LiRza2lwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kdGFrZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLnRha2VdID0gcXVlcnkuJHRha2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRleHBhbmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5leHBhbmRdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJGV4cGFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBDcmVhdGVzIGEgaGVhZGVyIGZyb20gYSBzaW1wbGUgZmlsdGVyXHJcbiAgICAgICAgX2J1aWxkRmlsdGVySGVhZGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5maWx0ZXJdID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZyA9IF9zZWxmICYmIF9zZWxmLnNldHVwICYmIF9zZWxmLnNldHVwLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVPYmplY3RzO1xyXG5cclxuICAgIHZhciByZXZpdmVyID0gcGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcihwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nKTtcclxuXHJcbiAgICBSZXF1ZXN0LnBhcnNlcnMgPSB7XHJcbiAgICAgICAgc2ltcGxlOiB7XHJcbiAgICAgICAgICAgIHJlc3VsdDogcGFyc2VVdGlsaXRpZXMucGFyc2VSZXN1bHQuYmluZChudWxsLCByZXZpdmVyKSxcclxuICAgICAgICAgICAgZXJyb3I6IHBhcnNlVXRpbGl0aWVzLnBhcnNlRXJyb3IuYmluZChudWxsLCByZXZpdmVyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2luZ2xlOiB7XHJcbiAgICAgICAgICAgIHJlc3VsdDogcGFyc2VVdGlsaXRpZXMucGFyc2VTaW5nbGVSZXN1bHQuYmluZChudWxsLCByZXZpdmVyKSxcclxuICAgICAgICAgICAgZXJyb3I6IHBhcnNlVXRpbGl0aWVzLnBhcnNlRXJyb3IuYmluZChudWxsLCByZXZpdmVyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgIHJlc3VsdDogcGFyc2VVdGlsaXRpZXMucGFyc2VVcGRhdGVSZXN1bHQuYmluZChudWxsLCByZXZpdmVyKSxcclxuICAgICAgICAgICAgZXJyb3I6IHBhcnNlVXRpbGl0aWVzLnBhcnNlRXJyb3IuYmluZChudWxsLCByZXZpdmVyKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gVE9ETyBidWlsdCBmb3IgcmVxdWVzdFxyXG4gICAgaWYgKHR5cGVvZiBSZXF1ZXN0LnNlbmRSZXF1ZXN0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIFJlcXVlc3Quc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gcmVxdWVzdC5idWlsZFVybChyZXF1ZXN0LnNldHVwKSArIHJlcXVlc3QuZW5kcG9pbnQ7XHJcbiAgICAgICAgICAgIHVybCA9IEV2ZXJsaXZlLmRpc2FibGVSZXF1ZXN0Q2FjaGUodXJsLCByZXF1ZXN0Lm1ldGhvZCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVxdWVzdC5tZXRob2QgPT09ICdHRVQnID8gcmVxdWVzdC5kYXRhIDogSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc05vZGVqcykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5zdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zdWNjZXNzLmNhbGwocmVxdWVzdCwgcmVxdWVzdC5wYXJzZS5yZXN1bHQoZGF0YSksIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5lcnJvciA9IGZ1bmN0aW9uIChqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZXJyb3IuY2FsbChyZXF1ZXN0LCByZXF1ZXN0LnBhcnNlLmVycm9yKGpxWEhSLnJlc3BvbnNlVGV4dCB8fCBqcVhIUi5zdGF0dXNUZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy50eXBlID0gJ2pzb24nO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5jcm9zc09yaWdpbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5wYXJzZS5yZXN1bHQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zdWNjZXNzLmNhbGwocmVxdWVzdCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5lcnJvciA9IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXF1ZXN0LnBhcnNlLmVycm9yKGpxWEhSLnJlc3BvbnNlVGV4dCB8fCBqcVhIUi5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmVycm9yLmNhbGwocmVxdWVzdCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVxd2VzdChyZXF1ZXN0UGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBSZXF1ZXN0O1xyXG59KCkpOyIsInZhciBfID0gcmVxdWlyZSgnLi9jb21tb24nKS5fO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxudmFyIEF1dGhlbnRpY2F0aW9uU2V0dXAgPSByZXF1aXJlKCcuL2F1dGgvQXV0aGVudGljYXRpb25TZXR1cCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV2ZXJsaXZlVXJsID0gY29uc3RhbnRzLmV2ZXJsaXZlVXJsO1xyXG5cclxuICAgIC8vIEFuIG9iamVjdCB0aGF0IGtlZXBzIGluZm9ybWF0aW9uIGFib3V0IGFuIEV2ZXJsaXZlIGNvbm5lY3Rpb25cclxuICAgIGZ1bmN0aW9uIFNldHVwKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnVybCA9IGV2ZXJsaXZlVXJsO1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hc3RlcktleSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJpbmNpcGFsSWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2NoZW1lID0gJ2h0dHAnOyAvLyBodHRwIG9yIGh0dHBzXHJcbiAgICAgICAgdGhpcy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRpb25zO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtdWxhdG9yTW9kZSA9IG9wdGlvbnMuZW11bGF0b3JNb2RlO1xyXG4gICAgICAgICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb24gPSBuZXcgQXV0aGVudGljYXRpb25TZXR1cCh0aGlzLCBvcHRpb25zLmF1dGhlbnRpY2F0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBTZXR1cC5wcm90b3R5cGUuc2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSBmdW5jdGlvbiAodG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpIHtcclxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XHJcbiAgICAgICAgdGhpcy5wcmluY2lwYWxJZCA9IHByaW5jaXBhbElkO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXR1cC5wcm90b3R5cGUuZ2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW4sXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogdGhpcy50b2tlblR5cGUsXHJcbiAgICAgICAgICAgIHByaW5jaXBhbElkOiB0aGlzLnByaW5jaXBhbElkXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNldHVwO1xyXG5cclxufSgpKTsiLCIndXNlIHN0cmljdCc7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlJyk7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIHVzZXJzQ29sbGVjdGlvbk5hbWUgPSAnVXNlcnMnO1xyXG52YXIgYnVpbGRQcm9taXNlID0gdXRpbHMuYnVpbGRQcm9taXNlO1xyXG52YXIgTG9jYWxTdG9yZSA9IHJlcXVpcmUoJy4uL0xvY2FsU3RvcmUnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3JzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgQXV0aGVudGljYXRpb25cclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgYXV0aGVudGljYXRpb24gb2YgYSB1c2VyIGluIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gZWwge0V2ZXJsaXZlfSBFdmVybGl2ZSBPYmplY3RcclxuICAgICAqIEBwYXJhbSBzZXR1cCB7QXV0aFNldHVwfSB0aGUgYXV0aGVudGljYXRpb24gc2V0dXAgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHZhciBBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIChlbCwgc2V0dXApIHtcclxuICAgICAgICB0aGlzLmF1dGhTZXR1cCA9IHNldHVwIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuX2VsID0gZWw7XHJcbiAgICAgICAgdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RvcmUgPSBuZXcgTG9jYWxTdG9yZShlbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFNldHVwLnBlcnNpc3QpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yZUtleSA9IHRoaXMuX2dldExvY2FsU3RvcmVLZXkoKTtcclxuICAgICAgICAgICAgdmFyIGF1dGhPcHRpb25zID0gdGhpcy5fbG9jYWxTdG9yZS5nZXRJdGVtKGxvY2FsU3RvcmVLZXkpO1xyXG4gICAgICAgICAgICB2YXIgYXV0aEluZm87XHJcbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgYXV0aEluZm8gPSBKU09OLnBhcnNlKHRoaXMuX2xvY2FsU3RvcmUuZ2V0SXRlbShsb2NhbFN0b3JlS2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGF1dGhJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9lbC5zZXR1cC5zZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyhhdXRoSW5mby50b2tlbiwgYXV0aEluZm8udG9rZW5UeXBlLCBhdXRoSW5mby5wcmluY2lwYWxJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIEFsbCByZXF1ZXN0cyBpbml0aWF0ZWQgYnkgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2Ugd2lsbCBiZSBhdXRoZW50aWNhdGVkIHdpdGggdGhhdCB1c2VyJ3MgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luXHJcbiAgICAgKiBAbmFtZSBsb2dpblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2luU3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB1c2Vyc0NvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3Bhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2VsLlVzZXJzLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbG9nb3V0U3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGVycm9yRnVuYyA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMzAxKSB7IC8vaW52YWxpZCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZXJyb3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0LFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHVzZXJzQ29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckZ1bmNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZWwuVXNlcnMucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2dldExvY2FsU3RvcmVLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5BdXRoU3RvcmVLZXkgKyB0aGlzLl9lbC5zZXR1cC5hcGlLZXkgKyAnJGF1dGhlbnRpY2F0aW9uJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhGYWNlYm9vayA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnRmFjZWJvb2snLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhBREZTID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdBREZTJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhMaXZlSUQgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0xpdmVJRCcsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2luV2l0aFByb3ZpZGVyKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoR29vZ2xlID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdHb29nbGUnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVHdpdHRlciBzZWNyZXQgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ1R3aXR0ZXInLFxyXG4gICAgICAgICAgICBUb2tlbjogdG9rZW4sXHJcbiAgICAgICAgICAgIFRva2VuU2VjcmV0OiB0b2tlblNlY3JldFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIHRoYXQgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgd2lsbCB1c2UgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldEF1dGhvcml6YXRpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlbiB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXV0aG9yaXphdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuVG9rZW5UeXBlfSB0b2tlblR5cGUgVG9rZW4gdHlwZS4gQ3VycmVudGx5IG9ubHkgJ2JlYXJlcicgdG9rZW4gaXMgc3VwcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW5jaXBhbElkIFRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IGlzIGxvZ2dlZCBpbi5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLnNldEF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBzZXRBdXRob3JpemF0aW9uKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKSB7XHJcbiAgICAgICAgdGhpcy5fZWwuc2V0dXAuc2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXModG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRoU2V0dXAucGVyc2lzdCkge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yZUtleSA9IHRoaXMuX2dldExvY2FsU3RvcmVLZXkoKTtcclxuICAgICAgICAgICAgdmFyIGF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzID0gdGhpcy5fZWwuc2V0dXAuZ2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdG9yZS5zZXRJdGVtKGxvY2FsU3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3Muc3VjY2VzcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdGhhdCB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgY3VycmVudGx5IHVzZXMuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCB0aGFuIGxvZ2dpbmcgb3V0LCBiZWNhdXNlIHRoZSBhdXRob3JpemF0aW9uIHRva2VuIHRoYXQgd2FzIHVzZWQsIHdpbGwgbm90IGJlIGludmFsaWRhdGVkLlxyXG4gICAgICogQG1ldGhvZCBjbGVhckF1dGhvcml6YXRpb25cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNsZWFyQXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQXV0aG9yaXphdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb24obnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5jbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHBlcnNpc3RlZCBhdXRoZW50aWNhdGlvbiBmcm9tIHRoZSBsb2NhbCBzdG9yZSBmb3IgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIFdpbGwgbm90IGxvZ291dCBvciBtb2RpZnkgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gb2YgdGhlIEphdmFzY3JpcHQgU0RLLlxyXG4gICAgICogQG1ldGhvZCBjbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JlS2V5ID0gdGhpcy5fZ2V0TG9jYWxTdG9yZUtleSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlLnJlbW92ZUl0ZW0obG9jYWxTdG9yZUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlbWVudCBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhbiBvbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgZnVuY3Rpb24gaXMgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5hdXRoU2V0dXAub25BdXRoZW50aWNhdGlvblJlcXVpcmVkID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogRW5zdXJlcyB0aGF0IGF1dGhlbnRpY2F0aW9uIGlzIGNvbXBsZXRlZCBiZWZvcmUgY29udGludWluZy5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBhdXRoZW50aWNhdGlvbiBpcyBjb21wbGV0ZS4gU2VlIHt7QGxpbmsgRXZlcmxpdmUucHJvdG90eXBlLmNvbXBsZXRlQXV0aGVudGljYXRpb259fS5cclxuICAgICAqIEB0aHJvd3MgdGhyb3dzIGFuIGVycm9yIGlmIG5vIG9uQXV0aGVudGljYXRpb25SZXF1aXJlZCBoYW5kbGVyIGlzIHByb3ZpZGVkIHRvIHRoZSBzZXR1cC5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLl9lbnN1cmVBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uQXV0aGVudGljYXRpb25SZXF1aXJlZCBvcHRpb24gb2YgRXZlcmxpdmUuU2V0dXAuQXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0aGVudGljYXRpbmcoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3MucHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGVhckF1dGhvcml6YXRpb24oKTtcclxuICAgICAgICB0aGlzLmF1dGhTZXR1cC5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcyA9IHV0aWxzLmdldENhbGxiYWNrcygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcy5wcm9taXNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiByZXN1bHQuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24gYXV0aGVudGljYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXHJcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24uYWNjZXNzX3Rva2VuXHJcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24udG9rZW5fdHlwZVxyXG4gICAgICogQHBhcmFtIGF1dGhlbnRpY2F0aW9uLnByaW5jaXBhbF9pZFxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuY29tcGxldGVBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIChhdXRoZW50aWNhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2VsLnNldEF1dGhvcml6YXRpb24oYXV0aGVudGljYXRpb24uYWNjZXNzX3Rva2VuLCBhdXRoZW50aWNhdGlvbi50b2tlbl90eXBlLCBhdXRoZW50aWNhdGlvbi5wcmluY2lwYWxfaWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXHJcbiAgICAgKiBAbmFtZSBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xyXG4gICAgICogQG5hbWUgZ2V0QXV0aGVudGljYXRpb25TdGF0dXNcclxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuQ2FsbGJhY2tzLmF1dGhlbnRpY2F0aW9uU3RhdHVzU3VjY2Vzc30gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5nZXRBdXRoZW50aWNhdGlvblN0YXR1cyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2V0dXAgPSBzZWxmLl9lbC5zZXR1cDtcclxuICAgICAgICAgICAgaWYgKHNldHVwLm1hc3RlcktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMubWFzdGVyS2V5fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc2V0dXAudG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLnVuYXV0aGVudGljYXRlZH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9lbC5Vc2Vyc1xyXG4gICAgICAgICAgICAgICAgLnNraXBBdXRoKHRydWUpXHJcbiAgICAgICAgICAgICAgICAuY3VycmVudFVzZXIoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0ZWQsIHVzZXI6IHJlcy5yZXN1bHR9KTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZFJlcXVlc3QuY29kZSB8fCBlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZFRva2VuLmNvZGUpIHsgLy8gaW52YWxpZCByZXF1ZXN0LCBpLmUuIHRoZSBhY2Nlc3MgdG9rZW4gaXMgaW52YWxpZCBvciBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmludmFsaWRBdXRoZW50aWNhdGlvbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmV4cGlyZWRBdXRoZW50aWNhdGlvbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpcyBjdXJyZW50bHkgd2FpdGluZyBmb3IgYXV0aGVudGljYXRpb24gdG8gYmUgY29tcGxldGVkLiBTZWUge3tAbGluayBFdmVybGl2ZS5wcm90b3R5cGUuY29tcGxldGVBdXRoZW50aWNhdGlvbn19LlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5pc0F1dGhlbnRpY2F0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzO1xyXG4gICAgfTtcclxuXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2xvZ2luU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGEucmVzdWx0O1xyXG4gICAgICAgIHRoaXMuc2V0QXV0aG9yaXphdGlvbihyZXN1bHQuYWNjZXNzX3Rva2VuLCByZXN1bHQudG9rZW5fdHlwZSwgcmVzdWx0LnByaW5jaXBhbF9pZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fbG9nb3V0U3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQXV0aG9yaXphdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2xvZ2luV2l0aFByb3ZpZGVyID0gZnVuY3Rpb24gKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciB1c2VyID0ge1xyXG4gICAgICAgICAgICBJZGVudGl0eTogaWRlbnRpdHlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc0Z1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2dpblN1Y2Nlc3MuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXIsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdXNlcnNDb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHVzZXIsXHJcbiAgICAgICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fZWwuVXNlcnMucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQXV0aGVudGljYXRpb247XHJcbn0oKSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIEF1dGhlbnRpY2F0aW9uU2V0dXAgPSBmdW5jdGlvbiAoZXZlcmxpdmUsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdGhpcy5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgPSBvcHRpb25zLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZDtcclxuICAgIHRoaXMucGVyc2lzdCA9IG9wdGlvbnMucGVyc2lzdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXV0aGVudGljYXRpb25TZXR1cDsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29tbW9uID0ge307XHJcblxyXG4gICAgdmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG4gICAgdmFyIGlzTmF0aXZlU2NyaXB0ID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XHJcbiAgICB2YXIgaXNOb2RlanMgPSBwbGF0Zm9ybS5pc05vZGVqcztcclxuXHJcbiAgICBpZiAoIWlzTm9kZWpzICYmICFpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGNvbW1vbi5yZXF3ZXN0ID0gcmVxdWlyZSgncmVxd2VzdCcpO1xyXG4gICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgICAgIGNvbW1vbi5yZXF3ZXN0ID0gcmVxdWlyZSgnLi9yZXF3ZXN0Lm5hdGl2ZXNjcmlwdCcpO1xyXG4gICAgfSBlbHNlIGlmIChpc05vZGVqcykge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgICAgIGNvbW1vbi5yZXF3ZXN0ID0gcmVxdWlyZSgnLi9yZXF3ZXN0Lm5vZGVqcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tbW9uLnJvb3QpIHtcclxuICAgICAgICAvL2Jyb3dzZXIvcmVxdWlyZWpzL2NvcmRvdmFcclxuICAgICAgICBjb21tb24ucm9vdCA9IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW5zdXJlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIGVuc3VyZURlcGVuZGVuY3koZ2xvYmFsTmFtZSwgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgaWYgKCFsb2NhbE5hbWUpIHtcclxuICAgICAgICAgICAgbG9jYWxOYW1lID0gZ2xvYmFsTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoY29tbW9uW2xvY2FsTmFtZV0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb21tb25bbG9jYWxOYW1lXSA9IGNvbW1vbi5yb290W2dsb2JhbE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy9mb3IgdGhlIGV2ZXJsaXZlIGJ1bmRsZSB3aXRob3V0IGRlcGVuZGVuY2llcyBpbmNsdWRlZCBicm93c2VyaWZ5IHJlcGxhY2VzIHRoZW0gd2l0aCBlbXB0eSBvYmplY3RzXHJcbiAgICBjb21tb24uXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ18nKTtcclxuXHJcbiAgICBjb21tb24uanN0eiA9IHJlcXVpcmUoJ2pzdGltZXpvbmVkZXRlY3QnKS5qc3R6O1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnanN0eicpO1xyXG5cclxuICAgIGNvbW1vbi5tb25nb1F1ZXJ5ID0gcmVxdWlyZSgnbW9uZ28tcXVlcnknKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ21vbmdvUXVlcnknKTtcclxuXHJcbiAgICBjb21tb24uTWluZ28gPSByZXF1aXJlKCdtaW5nbycpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnTWluZ28nKTtcclxuXHJcbiAgICBjb21tb24udXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ3V1aWQnKTtcclxuXHJcbiAgICBjb21tb24uUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vc2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yJyk7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCdQcm9jZXNzb3InKTtcclxuXHJcbiAgICBjb21tb24ucnN2cCA9IHJlcXVpcmUoJ3JzdnAnKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ1JTVlAnLCAncnN2cCcpO1xyXG5cclxuICAgIGlmICghaXNOb2RlanMgJiYgIWlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgZW5zdXJlRGVwZW5kZW5jeSgncmVxd2VzdCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb21tb247XHJcbn0oKSk7IiwidmFyIGNvbnN0YW50cyA9IHtcclxuICAgIGlkRmllbGQ6ICdJZCcsXHJcbiAgICBndWlkRW1wdHk6ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnLFxyXG4gICAgZXZlcmxpdmVVcmw6ICcvL2FwaS5ldmVybGl2ZS5jb20vdjEvJyxcclxuICAgIC8qKlxyXG4gICAgICogQSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVnaWVzLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IENsaWVudFdpbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTZXJ2ZXJXaW5zXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ3VzdG9tXHJcbiAgICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBFdmVybGl2ZS5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBDb25mbGljdFJlc29sdXRpb25TdHJhdGVneToge1xyXG4gICAgICAgIENsaWVudFdpbnM6ICdjbGllbnRXaW5zJyxcclxuICAgICAgICBTZXJ2ZXJXaW5zOiAnc2VydmVyV2lucycsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xyXG4gICAgfSxcclxuICAgIENvbmZsaWN0UmVzb2x1dGlvbjoge1xyXG4gICAgICAgIEtlZXBTZXJ2ZXI6ICdrZWVwU2VydmVyJyxcclxuICAgICAgICBLZWVwQ2xpZW50OiAna2VlcENsaWVudCcsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgYXZhaWxhYmxlIHN0b3JhZ2UgcHJvdmlkZXJzLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IExvY2FsU3RvcmFnZVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IEZpbGVTeXN0ZW1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDdXN0b21cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLlN0b3JhZ2VQcm92aWRlclxyXG4gICAgICovXHJcbiAgICBTdG9yYWdlUHJvdmlkZXI6IHtcclxuICAgICAgICBMb2NhbFN0b3JhZ2U6ICdsb2NhbFN0b3JhZ2UnLFxyXG4gICAgICAgIEZpbGVTeXN0ZW06ICdmaWxlU3lzdGVtJyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG5cclxuICAgIERlZmF1bHRTdG9yYWdlUGF0aDogJ2VsX3N0b3JlLycsXHJcblxyXG4gICAgRW5jcnlwdGlvblByb3ZpZGVyOiB7XHJcbiAgICAgICAgRGVmYXVsdDogJ2RlZmF1bHQnLFxyXG4gICAgICAgIEN1c3RvbTogJ2N1c3RvbSdcclxuICAgIH0sXHJcbiAgICAvLyBUaGUgaGVhZGVycyB1c2VkIGJ5IHRoZSBFdmVybGl2ZSBzZXJ2aWNlc1xyXG4gICAgSGVhZGVyczoge1xyXG4gICAgICAgIGZpbHRlcjogJ1gtRXZlcmxpdmUtRmlsdGVyJyxcclxuICAgICAgICBzZWxlY3Q6ICdYLUV2ZXJsaXZlLUZpZWxkcycsXHJcbiAgICAgICAgc29ydDogJ1gtRXZlcmxpdmUtU29ydCcsXHJcbiAgICAgICAgc2tpcDogJ1gtRXZlcmxpdmUtU2tpcCcsXHJcbiAgICAgICAgdGFrZTogJ1gtRXZlcmxpdmUtVGFrZScsXHJcbiAgICAgICAgZXhwYW5kOiAnWC1FdmVybGl2ZS1FeHBhbmQnLFxyXG4gICAgICAgIHNpbmdsZUZpZWxkOiAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnLFxyXG4gICAgICAgIGluY2x1ZGVDb3VudDogJ1gtRXZlcmxpdmUtSW5jbHVkZS1Db3VudCcsXHJcbiAgICAgICAgcG93ZXJGaWVsZHM6ICdYLUV2ZXJsaXZlLVBvd2VyLUZpZWxkcycsXHJcbiAgICAgICAgZGVidWc6ICdYLUV2ZXJsaXZlLURlYnVnJyxcclxuICAgICAgICBvdmVycmlkZVN5c3RlbUZpZWxkczogJ1gtRXZlcmxpdmUtT3ZlcnJpZGUtU3lzdGVtLUZpZWxkcydcclxuICAgIH0sXHJcbiAgICAvL0NvbnN0YW50cyBmb3IgZGlmZmVyZW50IHBsYXRmb3JtcyBpbiBFdmVybGl2ZVxyXG4gICAgUGxhdGZvcm06IHtcclxuICAgICAgICBXaW5kb3dzUGhvbmU6IDEsXHJcbiAgICAgICAgV2luZG93czogMixcclxuICAgICAgICBBbmRyb2lkOiAzLFxyXG4gICAgICAgIGlPUzogNCxcclxuICAgICAgICBPU1g6IDUsXHJcbiAgICAgICAgQmxhY2tiZXJyeTogNixcclxuICAgICAgICBOb2tpYTogNyxcclxuICAgICAgICBVbmtub3duOiAxMDBcclxuICAgIH0sXHJcbiAgICBPcGVyYXRvclR5cGU6IHtcclxuICAgICAgICBxdWVyeTogMSxcclxuXHJcbiAgICAgICAgd2hlcmU6IDEwMCxcclxuICAgICAgICBmaWx0ZXI6IDEwMSxcclxuXHJcbiAgICAgICAgYW5kOiAxMTAsXHJcbiAgICAgICAgb3I6IDExMSxcclxuICAgICAgICBub3Q6IDExMixcclxuXHJcbiAgICAgICAgZXF1YWw6IDEyMCxcclxuICAgICAgICBub3RfZXF1YWw6IDEyMSxcclxuICAgICAgICBsdDogMTIyLFxyXG4gICAgICAgIGx0ZTogMTIzLFxyXG4gICAgICAgIGd0OiAxMjQsXHJcbiAgICAgICAgZ3RlOiAxMjUsXHJcbiAgICAgICAgaXNpbjogMTI2LFxyXG4gICAgICAgIG5vdGluOiAxMjcsXHJcbiAgICAgICAgYWxsOiAxMjgsXHJcbiAgICAgICAgc2l6ZTogMTI5LFxyXG4gICAgICAgIHJlZ2V4OiAxMzAsXHJcbiAgICAgICAgY29udGFpbnM6IDEzMSxcclxuICAgICAgICBzdGFydHNXaXRoOiAxMzIsXHJcbiAgICAgICAgZW5kc1dpdGg6IDEzMyxcclxuXHJcbiAgICAgICAgbmVhclNocGVyZTogMTQwLFxyXG4gICAgICAgIHdpdGhpbkJveDogMTQxLFxyXG4gICAgICAgIHdpdGhpblBvbHlnb246IDE0MixcclxuICAgICAgICB3aXRoaW5TaHBlcmU6IDE0MyxcclxuXHJcbiAgICAgICAgc2VsZWN0OiAyMDAsXHJcbiAgICAgICAgZXhjbHVkZTogMjAxLFxyXG5cclxuICAgICAgICBvcmRlcjogMzAwLFxyXG4gICAgICAgIG9yZGVyX2Rlc2M6IDMwMSxcclxuXHJcbiAgICAgICAgc2tpcDogNDAwLFxyXG4gICAgICAgIHRha2U6IDQwMSxcclxuICAgICAgICBleHBhbmQ6IDQwMlxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgdXNlZCB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHVuYXV0aGVudGljYXRlZCBJbmRpY2F0ZXMgdGhhdCBubyB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWFzdGVyS2V5IEluZGljYXRlcyB0aGF0IGEgbWFzdGVyIGtleSBhdXRoZW50aWNhdGlvbiBpcyB1c2VkLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGludmFsaWRBdXRoZW50aWNhdGlvbiBJbmRpY2F0ZXMgYW4gYXV0aGVudGljYXRpb24gaGFzIGJlZW4gYXR0ZW1wdGVkLCBidXQgaXQgd2FzIGludmFsaWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXV0aGVudGljYXRlZCBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGluZyBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLiBTb21lIHJlcXVlc3RzIG1pZ2h0IGJlIHBlbmRpbmcgYW5kIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHBpcmVkQXV0aGVudGljYXRpb24gSW5kaWNhdGVzIHRoYXQgYSB1c2VyIGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGluZy4gU29tZSByZXF1ZXN0cyBtaWdodCBiZSBwZW5kaW5nIGFuZCB3YWl0aW5nIGZvciB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUuXHJcbiAgICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBFdmVybGl2ZS5BdXRoU3RhdHVzXHJcbiAgICAgKi9cclxuICAgIEF1dGhTdGF0dXM6IHtcclxuICAgICAgICB1bmF1dGhlbnRpY2F0ZWQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgICAgIG1hc3RlcktleTogJ21hc3RlcktleScsXHJcbiAgICAgICAgaW52YWxpZEF1dGhlbnRpY2F0aW9uOiAnaW52YWxpZEF1dGhlbnRpY2F0aW9uJyxcclxuICAgICAgICBhdXRoZW50aWNhdGVkOiAnYXV0aGVudGljYXRlZCcsXHJcbiAgICAgICAgZXhwaXJlZEF1dGhlbnRpY2F0aW9uOiAnZXhwaXJlZEF1dGhlbnRpY2F0aW9uJyxcclxuICAgICAgICBhdXRoZW50aWNhdGluZzogJ2F1dGhlbnRpY2F0aW5nJ1xyXG4gICAgfSxcclxuICAgIG9mZmxpbmVJdGVtU3RhdGVzOiB7XHJcbiAgICAgICAgY3JlYXRlZDogJ2NyZWF0ZWQnLFxyXG4gICAgICAgIG1vZGlmaWVkOiAnbW9kaWZpZWQnLFxyXG4gICAgICAgIGRlbGV0ZWQ6ICdkZWxldGVkJ1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhUVFAgTWV0aG9kc1xyXG4gICAgICogQGVudW0ge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgSHR0cE1ldGhvZDoge1xyXG4gICAgICAgIEdFVDogJ0dFVCcsXHJcbiAgICAgICAgUE9TVDogJ1BPU1QnLFxyXG4gICAgICAgIFBVVDogJ1BVVCcsXHJcbiAgICAgICAgREVMRVRFOiAnREVMRVRFJ1xyXG4gICAgfSxcclxuICAgIG1heERpc3RhbmNlQ29uc3RzOiB7XHJcbiAgICAgICAgcmFkaWFuczogJyRtYXhEaXN0YW5jZScsXHJcbiAgICAgICAga206ICckbWF4RGlzdGFuY2VJbktpbG9tZXRlcnMnLFxyXG4gICAgICAgIG1pbGVzOiAnJG1heERpc3RhbmNlSW5NaWxlcydcclxuICAgIH0sXHJcbiAgICByYWRpdXNDb25zdHM6IHtcclxuICAgICAgICByYWRpYW5zOiAncmFkaXVzJyxcclxuICAgICAgICBrbTogJ3JhZGl1c0luS2lsb21ldGVycycsXHJcbiAgICAgICAgbWlsZXM6ICdyYWRpdXNJbk1pbGVzJ1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gdXNpbmcgYW4gaW52YWxpZCBmaWVsZCBuYW1lIGluIHRoZSBjb250ZXh0IG9mIEV2ZXJsaXZlXHJcbi8vIHRvIGVuc3VyZSBubyBuYW1pbmcgY29sbGlzaW9ucyBjYW4gb2NjdXJcclxuY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyID0gJ19fZXZlcmxpdmVfb2ZmbGluZV9zdGF0ZSc7XHJcblxyXG5jb25zdGFudHMuU3luY0Vycm9ycyA9IHtcclxuICAgIGdlbmVyYWxFcnJvcjogJ2dlbmVyYWxFcnJvcicsXHJcbiAgICBpdGVtU3luY0Vycm9yOiAnaXRlbVN5bmNFcnJvcidcclxufTtcclxuXHJcbmNvbnN0YW50cy5zeW5jQmF0Y2hTaXplID0gMTA7XHJcblxyXG5jb25zdGFudHMuQXV0aFN0b3JlS2V5ID0gJ19fZXZlcmxpdmVfYXV0aF9rZXknO1xyXG5cclxuLy8gdGhlIG1pbmltdW0gaW50ZXJ2YWwgYmV0d2VlbiBzeW5jIHJlcXVlc3RzXHJcbmNvbnN0YW50cy5kZWZhdWx0U3luY0ludGVydmFsID0gMTAwMCAqIDYwICogMTA7IC8vIDEwIG1pbnV0ZXNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnRzOyIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJ25vZGUtY3J5cHRvanMtYWVzJykuQ3J5cHRvSlM7XHJcbnZhciBBRVMgPSBDcnlwdG9KUy5BRVM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyIChzZGspIHtcclxuICAgICAgICB0aGlzLnNkayA9IHNkaztcclxuICAgIH1cclxuXHJcbiAgICBDcnlwdG9ncmFwaGljUHJvdmlkZXIucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2RrLm9mZmxpbmVTdG9yYWdlLnNldHVwLmVuY3J5cHRpb24ua2V5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jYW5FbmNyeXB0RGVjcnlwdDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEtleSgpICYmIGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuRW5jcnlwdERlY3J5cHQoY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQUVTLmVuY3J5cHQoY29udGVudCwgdGhpcy5fZ2V0S2V5KCkpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5FbmNyeXB0RGVjcnlwdChjb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBRVMuZGVjcnlwdChjb250ZW50LCB0aGlzLl9nZXRLZXkoKSkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIENyeXB0b2dyYXBoaWNQcm92aWRlcjtcclxufSgpKTsiLCJ2YXIgaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbiA9IEJvb2xlYW4oKCh0eXBlb2YgYW5kcm9pZCAhPT0gJ3VuZGVmaW5lZCcgJiYgYW5kcm9pZCAmJiBhbmRyb2lkLndpZGdldCAmJiBhbmRyb2lkLndpZGdldC5CdXR0b24pXHJcbiAgICB8fCAodHlwZW9mIFVJQnV0dG9uICE9PSAndW5kZWZpbmVkJyAmJiBVSUJ1dHRvbikpKTtcclxuXHJcbmlmIChpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uKSB7XHJcbiAgICBnbG9iYWwuaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbiA9IGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb247XHJcbiAgICBnbG9iYWwuaXNDb3Jkb3ZhQXBwbGljYXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICBnbG9iYWwud2luZG93ID0ge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2U6IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uICgpIHsgfSAvL3NoaW0gZm9yIG1vbmdvLXF1ZXJ5IHVuZGVyIG5hdGl2ZXNjcmlwdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIGlzQ29yZG92YUFwcGxpY2F0aW9uID0gL15maWxlOlxcL3szfVteXFwvXS9pLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpICYmIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxufVxyXG5cclxudmFyIGlzTm9kZWpzID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xyXG52YXIgaXNSZXF1aXJlanMgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGlzQ29yZG92YTogaXNDb3Jkb3ZhQXBwbGljYXRpb24sXHJcbiAgICBpc05hdGl2ZVNjcmlwdDogaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbixcclxuICAgIGlzTm9kZWpzOiBpc05vZGVqcyxcclxuICAgIGlzUmVxdWlyZWpzOiBpc1JlcXVpcmVqc1xyXG59OyIsIi8qIVxyXG4gVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgVGVsZXJpayBBRFxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUueSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqL1xyXG4vKiFcclxuIEV2ZXJsaXZlIFNES1xyXG4gVmVyc2lvbiAxLjMuMFxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4vRXZlcmxpdmUnKTtcclxuICAgIHZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG4gICAgY29tbW9uLnJvb3QuRXZlcmxpdmUgPSBFdmVybGl2ZTtcclxuXHJcbiAgICBpZiAoIXBsYXRmb3JtLmlzTmF0aXZlU2NyaXB0ICYmICFwbGF0Zm9ybS5pc05vZGVqcykge1xyXG4gICAgICAgIHZhciBrZW5kbyA9IHJlcXVpcmUoJy4va2VuZG8va2VuZG8uZXZlcmxpdmUnKTtcclxuICAgICAgICBFdmVybGl2ZS5jcmVhdGVEYXRhU291cmNlID0ga2VuZG8uY3JlYXRlRGF0YVNvdXJjZTtcclxuICAgICAgICBFdmVybGl2ZS5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlID0ga2VuZG8uY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvL0dsb2JhbCBldmVudCBoYW5kbGVycyBmb3IgcHVzaCBub3RpZmljYXRpb24gZXZlbnRzLiBSZXF1aXJlZCBieSB0aGUgY29yZG92YSBQdXNoTm90aWZpY2F0aW9ucyBwbHVnaW4gdGhhdCB3ZSB1c2UuXHJcbiAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzID0ge307XHJcbiAgICBFdmVybGl2ZS5PZmZsaW5lID0ge307XHJcblxyXG4gICAgRXZlcmxpdmUuUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbiAgICBFdmVybGl2ZS5RdWVyeUJ1aWxkZXIgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5QnVpbGRlcicpO1xyXG4gICAgRXZlcmxpdmUuR2VvUG9pbnQgPSByZXF1aXJlKCcuL0dlb1BvaW50Jyk7XHJcbiAgICBFdmVybGl2ZS5Db25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG4gICAgRXZlcmxpdmUuUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xyXG4gICAgRXZlcmxpdmUuRGF0YSA9IHJlcXVpcmUoJy4vdHlwZXMvRGF0YScpO1xyXG4gICAgRXZlcmxpdmUuX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG4gICAgRXZlcmxpdmUuX3RyYXZlcnNlQW5kUmV2aXZlID0gRXZlcmxpdmUuX3V0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlQW5kUmV2aXZlO1xyXG4gICAgRXZlcmxpdmUuX2NvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcblxyXG4gICAgdmFyIHBlcnNpc3RlcnNNb2R1bGUgPSByZXF1aXJlKCcuL29mZmxpbmUvb2ZmbGluZVBlcnNpc3RlcnMnKTtcclxuICAgIEV2ZXJsaXZlLnBlcnNpc3RlciA9IHtcclxuICAgICAgICBMb2NhbFN0b3JhZ2U6IHBlcnNpc3RlcnNNb2R1bGUuTG9jYWxTdG9yYWdlUGVyc2lzdGVyLFxyXG4gICAgICAgIEZpbGVTeXN0ZW06IHBlcnNpc3RlcnNNb2R1bGUuRmlsZVN5c3RlbVBlcnNpc3RlclxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb21tb24ucm9vdC5FdmVybGl2ZTtcclxuICAgIH1cclxufSgpKTsiLCJ2YXIgUXVlcnlCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUXVlcnlCdWlsZGVyJyk7XHJcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmUnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5qUXVlcnkgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cua2VuZG8gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciAkID0gd2luZG93LmpRdWVyeTtcclxuICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbztcclxuXHJcbiAgICB2YXIgZXh0ZW5kID0gJC5leHRlbmQ7XHJcblxyXG4gICAgdmFyIGV2ZXJsaXZlVHJhbnNwb3J0ID0ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZXh0ZW5kKHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJsaXZlJCA9IG9wdGlvbnMuZGF0YVByb3ZpZGVyIHx8IEV2ZXJsaXZlLiQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVybGl2ZSQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIEJhY2tlbmQgc2VydmljZXMgc2RrIG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uID0gdGhpcy5ldmVybGl2ZSQuZGF0YShvcHRpb25zLnR5cGVOYW1lKTtcclxuICAgICAgICAgICAga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RPcHRpb24gPSB0aGlzLm9wdGlvbnNbJ3JlYWQnXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4ucmVhZC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RIZWFkZXJzID0gbWV0aG9kT3B0aW9uLmhlYWRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gdHJhbnNsYXRlS2VuZG9RdWVyeShvcHRpb25zLmRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgZXZlcmxpdmVRdWVyeSA9IG5ldyBRdWVyeShxdWVyeS4kd2hlcmUsIG51bGwsIHF1ZXJ5LiRzb3J0LCBxdWVyeS4kc2tpcCwgcXVlcnkuJHRha2UpO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmRhdGEuSWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5nZXRCeUlkKGlkKS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuZ2V0KGV2ZXJsaXZlUXVlcnkpLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1sndXBkYXRlJ107XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kSGVhZGVycztcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kSGVhZGVycyA9IG1ldGhvZE9wdGlvbi5oZWFkZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xyXG4gICAgICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCB1cGRhdGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtRm9yVXBkYXRlID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS51cGRhdGVTaW5nbGUoaXRlbUZvclVwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MuYmluZCh0aGlzLCBpdGVtRm9yVXBkYXRlKSwgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RPcHRpb24gPSB0aGlzLm9wdGlvbnNbJ2NyZWF0ZSddO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5yZWFkLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IF8uaXNBcnJheShvcHRpb25zLmRhdGEubW9kZWxzKTtcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGEgPSBpc011bHRpcGxlID8gb3B0aW9ucy5kYXRhLm1vZGVscyA6IG9wdGlvbnMuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuY3JlYXRlKGNyZWF0ZURhdGEpXHJcbiAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MuYmluZCh0aGlzLCBjcmVhdGVEYXRhKSwgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1snZGVzdHJveSddO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5yZWFkLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IF8uaXNBcnJheShvcHRpb25zLmRhdGEubW9kZWxzKTtcclxuICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2ggZGVzdHJveSBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuZGVzdHJveShvcHRpb25zLmRhdGEpXHJcbiAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQuZXh0ZW5kKHRydWUsIGtlbmRvLmRhdGEsIHtcclxuICAgICAgICB0cmFuc3BvcnRzOiB7XHJcbiAgICAgICAgICAgIGV2ZXJsaXZlOiBldmVybGl2ZVRyYW5zcG9ydFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NoZW1hczoge1xyXG4gICAgICAgICAgICBldmVybGl2ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaGFzT3duUHJvcGVydHkoJ2NvdW50JykgPyBkYXRhLmNvdW50IDogZGF0YS5Db3VudDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnJlc3VsdCB8fCBFdmVybGl2ZS5fdHJhdmVyc2VBbmRSZXZpdmUoZGF0YS5SZXN1bHQpIHx8IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzLmlkRmllbGRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUtlbmRvUXVlcnkoZGF0YSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHNraXAgPSBkYXRhLnNraXA7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5za2lwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRha2UpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC4kdGFrZSA9IGRhdGEudGFrZTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnRha2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuc29ydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRFeHByZXNzaW9ucyA9IGRhdGEuc29ydDtcclxuICAgICAgICAgICAgICAgIHZhciBzb3J0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShzb3J0RXhwcmVzc2lvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydEV4cHJlc3Npb25zID0gW3NvcnRFeHByZXNzaW9uc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAoaWR4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRbdmFsdWUuZmllbGRdID0gdmFsdWUuZGlyID09PSAnYXNjJyA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LiRzb3J0ID0gc29ydDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnNvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyQnVpbGRlci5idWlsZChkYXRhLmZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHdoZXJlID0gZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmlsdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ2V4T3BlcmF0aW9ucyA9IFsnc3RhcnRzd2l0aCcsICdzdGFydHNXaXRoJywgJ2VuZHN3aXRoJywgJ2VuZHNXaXRoJywgJ2NvbnRhaW5zJ107XHJcblxyXG4gICAgdmFyIGZpbHRlckJ1aWxkZXIgPSB7XHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ1aWxkZXIuX2J1aWxkKGZpbHRlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlckJ1aWxkZXIuX2lzUmF3KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9yYXcoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc1NpbXBsZShmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fc2ltcGxlKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNSZWdleChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fcmVnZXgoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc0FuZChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fYW5kKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNPcihmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fb3IoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmF3OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3BlcmF0b3IgPT09ICdfcmF3JztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYXc6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICBmaWVsZFRlcm1bZmlsdGVyLmZpZWxkXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1NpbXBsZTogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZpbHRlci5sb2dpYyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWZpbHRlckJ1aWxkZXIuX2lzUmVnZXgoZmlsdGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB7fSwgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IGZpbHRlckJ1aWxkZXIuX3RyYW5zbGF0ZW9wZXJhdG9yKGZpbHRlci5vcGVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGVybVtvcGVyYXRvcl0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gdGVybTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1JlZ2V4OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkoZmlsdGVyLm9wZXJhdG9yLCByZWdleE9wZXJhdGlvbnMpICE9PSAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZWdleDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IGZpbHRlckJ1aWxkZXIuX2dldFJlZ2V4KGZpbHRlcik7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gZmlsdGVyQnVpbGRlci5fZ2V0UmVnZXhWYWx1ZShyZWdleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXg6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJPcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWx0ZXJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiLipcIiArIHBhdHRlcm4gKyBcIi4qXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0c1dpdGgnOiAvLyByZW1vdmluZyB0aGUgY2FtZWwgY2FzZSBvcGVyYXRvcnMgd2lsbCBiZSBhIGJyZWFraW5nIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnRzd2l0aCc6IC8vIHRoZSBLZW5kbyBVSSBvcGVyYXRvcnMgYXJlIGluIGxvd2VyIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHNXaXRoJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHN3aXRoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIHR5cGUuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVlcnlCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UmVnZXhWYWx1ZS5jYWxsKHRoaXMsIHJlZ2V4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0FuZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxvZ2ljID09PSAnYW5kJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckJ1aWxkZXIuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYW5kQXBwZW5kOiBmdW5jdGlvbiAoYW5kT2JqLCBuZXdPYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUuX2FuZEFwcGVuZC5jYWxsKHRoaXMsIGFuZE9iaiwgbmV3T2JqKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc09yOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubG9naWMgPT09ICdvcic7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb3I6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7JG9yOiByZXN1bHR9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RyYW5zbGF0ZW9wZXJhdG9yOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXEnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmVxJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbmVcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkZ3RcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2x0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJGd0ZVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbHRlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciB0eXBlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlLlxyXG4gICAgICogS2VuZG8gVUkgW0RhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvZGF0YXNvdXJjZSkgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEtlbmRvIFVJIHdpZGdldHMgKHN1Y2ggYXMgW0xpc3RWaWV3XShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvbGlzdHZpZXcvb3ZlcnZpZXcpIGFuZCBbR3JpZF0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvd2ViL2dyaWQvb3ZlcnZpZXcpKSB0byBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHJlbmRlciBkYXRhIGZyb20gQmFja2VuZCBTZXJ2aWNlcy5cclxuICAgICAqICppbmNsdWRpbmcgS2VuZG8gc2NyaXB0cyBpcyByZXF1aXJlZCouXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkYXRhIHNvdXJjZSBvcHRpb25zLiBTZWUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBvZiBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSBmb3IgbW9yZSBpbmZvLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0LnR5cGVOYW1lIHRoZSBjb250ZW50IHR5cGUgbmFtZSBpbiBCYWNrZW5kIFNlcnZpY2VzIHRoYXQgd2lsbCBiZSBtYW5hZ2VkLlxyXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIERhdGFTb3VyY2UuIFNlZSBLZW5kbyBVSSBkb2N1bWVudGF0aW9uIG9mIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGZvciBtb3JlIGluZm8uXHJcbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICogdmFyIGJvb2tzRGF0YVNvdXJjZSA9IEV2ZXJsaXZlLmNyZWF0ZURhdGFTb3VyY2Uoe1xyXG4gICAgICogICB0cmFuc3BvcnQ6IHtcclxuICAgICAqICAgICB0eXBlTmFtZTogJ0Jvb2tzJ1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgY3JlYXRlRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gb3B0aW9ucy50eXBlTmFtZTtcclxuICAgICAgICB2YXIgZXZlcmxpdmUkID0gb3B0aW9ucy5kYXRhUHJvdmlkZXIgfHwgRXZlcmxpdmUuJDtcclxuICAgICAgICBpZiAoIWV2ZXJsaXZlJCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBpbnN0YW50aWF0ZSBhbiBFdmVybGl2ZSBpbnN0YW5jZSBpbiBvcmRlciB0byBjcmVhdGUgYSBrZW5kbyBEYXRhU291cmNlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUkLmdldEtlbmRvRGF0YVNvdXJjZSh0eXBlTmFtZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlIGFuZCBjYW4gZXhwYW5kIGEgY2hhaW4gb2YgcmVsYXRpb25zLlxyXG4gICAgICogS2VuZG8gVUkgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEtlbmRvIHdpZGdldHMgKHN1Y2ggYXMgW1RyZWVWaWV3XShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvdHJlZXZpZXcvb3ZlcnZpZXcpKSB0byByZW5kZXIgZGF0YSBmcm9tIEJhY2tlbmQgU2VydmljZXMgaW4gYSBzdHJ1Y3R1cmVkIHdheS5cclxuICAgICAqIFRoZSBjaGFpbiBvZiByZWxhdGlvbnMgaXMgZGVmaW5lZCBieSBzcGVjaWZ5aW5nIHRoZSBmaWVsZCBuYW1lcyB0aGF0IGNvbnRhaW4gdGhlIHJlbGF0aW9uIG9uIGVhY2ggbGV2ZWwuIEZvciBleGFtcGxlIGEgZ2VuZXJpYyBoaWVyYXJjaHkgY2hhaW4gaXMgYSBjb250ZW50IHR5cGUgJ0NvbnRpbmVudHMnIHdpdGggcmVsYXRpb24gdG8gJ0NvdW50cmllcycsIHdoaWNoIGluIHR1cm4gY29udGFpbnMgYSByZWxhdGlvbiB0byAnVG93bnMnLlxyXG4gICAgICogKmluY2x1ZGluZyBLZW5kbyBzY3JpcHRzIGlzIHJlcXVpcmVkKi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIGRhdGEgc291cmNlIG9wdGlvbnMgZm9yIFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHlwZU5hbWUgbmFtZSBvZiB0aGUgbWFpbiBjb250ZW50IHR5cGUgZm9yIHRoZSBkYXRhIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7RXhwYW5kRGVmaW5pdGlvbltdfSBvcHRpb25zLmV4cGFuZCBhbiBhcnJheSBvZiBleHBhbmQgZGVmaW5pdGlvbnMuIEl0IGRlZmluZXMgdGhlIGxldmVscyBvZiBoaWVyYXJjaHkgYnkgc3BlY2lmeWluZyB0aGUgcmVsYXRpb24gZmllbGRzLiBBbiBleHBhbmQgZGVmaW5pdGlvbiBjYW4gZWl0aGVyIGJlIHRoZSBmaWVsZCBuYW1lIGFzIGEgKipzdHJpbmcqKiwgb3IgYW4gKipvYmplY3QqKiB0aGF0IGFsbG93cyBhZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXhwYW5kRGVmaW5pdGlvbiAtIFRoZSBmaWVsZCBuYW1lIG9mIHRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgZXhwYW5kZWQuIE9ubHkgc3VwcG9ydGVkIGluIG9ubGluZSBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24ucmVsYXRpb24gLSAqUmVxdWlyZWQqLiBUaGUgZmllbGQgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24udHlwZU5hbWUgLSAqUmVxdWlyZWQgaW4gb2ZmbGluZSBtb2RlKi4gVGhlIHR5cGUgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uZmlsdGVyIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGZpbHRlciBleHByZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uc29ydCAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBzb3J0IGV4cHJlc3Npb24uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5za2lwIC0gYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgc2tpcCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLnRha2UgLSBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0YWtlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uZmllbGRzIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGZpZWxkcyBleHByZXNzaW9uLlxyXG4gICAgICogQHJldHVybnMge0hpZXJhcmNoaWNhbERhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIEhpZXJhcmNoaWNhbERhdGFTb3VyY2UuIFNlZSBLZW5kbyBVSSBkb2N1bWVudGF0aW9uIGZvciBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKVxyXG4gICAgICogQGV4YW1wbGUgYGBganNcclxuICAgICAqIHZhciBlbCA9IG5ldyBFdmVybGl2ZSgneW91ci1hcGkta2V5LWhlcmUnKTtcclxuICAgICAqIHZhciBjb250aW5lbnRzID0gRXZlcmxpdmUuY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZSh7XHJcbiAgICAgKiAgIFwidHlwZU5hbWVcIjogXCJDb250aW5lbnRzXCIsXHJcbiAgICAgKiAgIFwiZXhwYW5kXCI6IFtcIkNvdW50cmllc1wiLCBcIlRvd25zXCJdXHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiAuLi5cclxuICAgICAqIChcIiN0cmVldmlld1wiKS5rZW5kb1RyZWVWaWV3KHtcclxuICAgICAqICAgZGF0YVNvdXJjZTogY29udGluZW50cyxcclxuICAgICAqICAgZGF0YVRleHRGaWVsZDogW1wiQ29udGluZW50TmFtZVwiLCBcIkNvdW50cnlOYW1lXCIsIFwiVG93bk5hbWVcIl1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBjcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSBvcHRpb25zLnR5cGVOYW1lO1xyXG4gICAgICAgIHZhciBldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xyXG4gICAgICAgIGlmICghZXZlcmxpdmUkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGluc3RhbnRpYXRlIGFuIEV2ZXJsaXZlIGluc3RhbmNlIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIERhdGFTb3VyY2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgYSAndHlwZU5hbWUnIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIERhdGFTb3VyY2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUkLmdldEhpZXJhcmNoaWNhbERhdGFTb3VyY2UodHlwZU5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmdldEtlbmRvRGF0YVNvdXJjZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSwgZGF0YXNvdXJjZU9wdGlvbnMpIHtcclxuICAgICAgICBkYXRhc291cmNlT3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkYXRhc291cmNlT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKGRhdGFzb3VyY2VPcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJ2ZXJHcm91cGluZycpICYmIGRhdGFzb3VyY2VPcHRpb25zLnNlcnZlckdyb3VwaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0RXZlcmxpdmVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnZXZlcmxpdmUnLFxyXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfLmRlZmF1bHRzKGRlZmF1bHRFdmVybGl2ZU9wdGlvbnMsIGRhdGFzb3VyY2VPcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZShvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBnZXRVcmxHZW5lcmF0b3JGb3JOb2RlID0gZnVuY3Rpb24gKGJhc2VVcmwsIGV4cGFuZEFycmF5KSB7XHJcbiAgICAgICAgdmFyIGV4cGFuZEZpZWxkID0gZ2V0UmVsYXRpb25GaWVsZEZvckV4cGFuZE5vZGUoZXhwYW5kQXJyYXlbZXhwYW5kQXJyYXkubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSBleHBhbmRBcnJheS5zbGljZSgwLCBleHBhbmRBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICB2YXIgcGF0aFVybCA9ICcvX2V4cGFuZCc7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0aFVybCArPSAnLycgKyBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShwYXRoQXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChwYXRoVXJsLCBleHBhbmRGaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBiYXNlVXJsICsgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5JZCAmJiBleHBhbmRGaWVsZCkgey8vaWYgd2UgYXJlIGV4cGFuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBwYXRoVXJsICsgJy8nICsgb3B0aW9ucy5JZCArICcvJyArIGV4cGFuZEZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0ocGF0aFVybCwgZXhwYW5kRmllbGQpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2V0SGVhZGVyc0ZvckV4cGFuZE5vZGUgPSBmdW5jdGlvbiAoZXhwYW5kTm9kZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXhwYW5kTm9kZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLUZpbHRlcic6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE5vZGUuZmlsdGVyKSxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVNvcnQnOiBKU09OLnN0cmluZ2lmeShleHBhbmROb2RlLnNvcnQpLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU2luZ2xlLUZpZWxkJzogZXhwYW5kTm9kZS5zaW5nbGVGaWVsZCxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVNraXAnOiBleHBhbmROb2RlLnNraXAsXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1UYWtlJzogZXhwYW5kTm9kZS50YWtlLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRmllbGRzJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kTm9kZS5maWVsZHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZSA9IGZ1bmN0aW9uIChleHBhbmROb2RlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHBhbmROb2RlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBhbmROb2RlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleHBhbmROb2RlLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kTm9kZS5yZWxhdGlvbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgYSAncmVsYXRpb24nIGZvciBhbiBleHBhbmQgbm9kZSB3aGVuIHVzaW5nIHRoZSBvYmplY3Qgbm90YXRpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5nZXRIaWVyYXJjaGljYWxEYXRhU291cmNlID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBkYXRhU291cmNlT3B0aW9ucykge1xyXG4gICAgICAgIGRhdGFTb3VyY2VPcHRpb25zID0gZGF0YVNvdXJjZU9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VPcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJ2ZXJHcm91cGluZycpICYmIGRhdGFTb3VyY2VPcHRpb25zLnNlcnZlckdyb3VwaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4cGFuZCA9IGRhdGFTb3VyY2VPcHRpb25zLmV4cGFuZCB8fCBkYXRhU291cmNlT3B0aW9ucztcclxuICAgICAgICBkZWxldGUgZGF0YVNvdXJjZU9wdGlvbnMuZXhwYW5kO1xyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gSGllcmFyY2hpY2FsRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghJC5pc0FycmF5KGV4cGFuZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc2V0ICdleHBhbmQnIGFycmF5IG9wdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgYSBrZW5kbyBIaWVyYXJjaGljYWxEYXRhU291cmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVVybCA9IHRoaXMuYnVpbGRVcmwoKSArIHR5cGVOYW1lO1xyXG5cclxuICAgICAgICB2YXIgZXhwYW5kU2NoZW1hO1xyXG4gICAgICAgIHZhciBpc09mZmxpbmVTdG9yYWdlRW5hYmxlZCA9IHRoaXMuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGV4cGFuZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyAvL3JlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSBoaWVyYXJjaGljYWwgZGF0YSBzb3VyY2VcclxuICAgICAgICAgICAgdmFyIGV4cGFuZE5vZGUgPSBleHBhbmRbaV07XHJcbiAgICAgICAgICAgIGlmIChpc09mZmxpbmVTdG9yYWdlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzUGxhaW5PYmplY3QoZXhwYW5kTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG9mZmxpbmUgaXMgZW5hYmxlZCwgZWFjaCBtZW1iZXIgb2YgdGhlIGV4cGFuZCBhcnJheSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFleHBhbmROb2RlLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGByZWxhdGlvbmAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFleHBhbmROb2RlLnR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGB0eXBlTmFtZWAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bZXhwYW5kTm9kZS5yZWxhdGlvbl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVGFyZ2V0VHlwZU5hbWU6IGV4cGFuZE5vZGUudHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsdGVyOiBleHBhbmROb2RlLmZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBTb3J0OiBleHBhbmROb2RlLnNvcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgVGFrZTogZXhwYW5kTm9kZS50YWtlLFxyXG4gICAgICAgICAgICAgICAgICAgIFNraXA6IGV4cGFuZE5vZGUuc2tpcCxcclxuICAgICAgICAgICAgICAgICAgICBGaWVsZHM6IGV4cGFuZE5vZGUuZmllbGRzLFxyXG4gICAgICAgICAgICAgICAgICAgIFNpbmdsZUZpZWxkOiBleHBhbmROb2RlLnNpbmdsZUZpZWxkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1FeHBhbmQnOiBKU09OLnN0cmluZ2lmeShleHBhbmRFeHByZXNzaW9uKSxcclxuICAgICAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnOiBleHBhbmROb2RlLnJlbGF0aW9uXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSB0eXBlTmFtZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9IGV4cGFuZFtpIC0gMV0udHlwZU5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGV4cGFuZE5vZGUucmVsYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZXJsaXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogcGFyZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBleHBhbmRTY2hlbWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJldmVybGl2ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFVybEdlbmVyYXRvckZvck5vZGUoYmFzZVVybCwgZXhwYW5kLnNsaWNlKDAsIGkgKyAxKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnNGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXhwYW5kU2NoZW1hXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnR5cGUgPSAnZXZlcmxpdmUnO1xyXG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0ID0ge1xyXG4gICAgICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgIGRhdGFQcm92aWRlcjogdGhpc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb3B0aW9ucy5zY2hlbWEgPSBleHBhbmRTY2hlbWE7XHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChkYXRhU291cmNlT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHRydWUsIG9wdGlvbnMsIGRhdGFTb3VyY2VPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZW5kby5kYXRhLkhpZXJhcmNoaWNhbERhdGFTb3VyY2Uob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBjcmVhdGVEYXRhU291cmNlOiBjcmVhdGVEYXRhU291cmNlLFxyXG4gICAgICAgIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2U6IGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2VcclxuICAgIH07XHJcbn0oKSk7IiwidmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgZXZlcmxpdmVFcnJvck1vZHVsZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcnM7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVzID0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzO1xyXG52YXIgSGVhZGVycyA9IGNvbnN0YW50cy5IZWFkZXJzO1xyXG52YXIgUmVxdWVzdE9wdGlvbnNCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUmVxdWVzdE9wdGlvbnNCdWlsZGVyJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIG1pbmdvID0gY29tbW9uLk1pbmdvO1xyXG52YXIgbW9uZ29RdWVyeSA9IGNvbW1vbi5tb25nb1F1ZXJ5O1xyXG52YXIgdXVpZCA9IGNvbW1vbi51dWlkO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIGV4cGFuZFByb2Nlc3NvciA9IHJlcXVpcmUoJy4uL0V4cGFuZFByb2Nlc3NvcicpO1xyXG52YXIgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucyA9IHJlcXVpcmUoJy4vb2ZmbGluZVRyYW5zZm9ybWF0aW9ucycpO1xyXG52YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XHJcblxyXG4vKipcclxuICogQGNsYXNzIE9mZmxpbmVNb2R1bGVcclxuICogQGNsYXNzRGVzYyBBIGNsYXNzIHByb3ZpZGluZyBhY2Nlc3MgdG8gc29tZSBvZmZsaW5lIHN0b3JhZ2UgZnVuY3Rpb25hbGl0aWVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB7QGxpbmsgT2ZmbGluZU1vZHVsZX0gY2xhc3MuXHJcbiAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICogQG1lbWJlciB7T2ZmbGluZU1vZHVsZX0gc3RvcmFnZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9mZmxpbmVNb2R1bGUoZXZlcmxpdmUsIG9wdGlvbnMsIHBlcnNpc3RlciwgZW5jcnlwdGlvblByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVybGl2ZSA9IGV2ZXJsaXZlO1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RlciA9IHBlcnNpc3RlcjtcclxuICAgICAgICB0aGlzLl9lbmNyeXB0aW9uUHJvdmlkZXIgPSBlbmNyeXB0aW9uUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5faXNTeW5jaHJvbml6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbkNhY2hlID0ge307XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBnZXRTeW5jRmlsdGVyRm9ySXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQoaXRlbSk7XHJcbiAgICAgICAgZmlsdGVyLk1vZGlmaWVkQXQgPSBpdGVtLk1vZGlmaWVkQXQ7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIElkOiBpdGVtLklkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFVzZXJzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBkYXRhUXVlcnkub3BlcmF0aW9uO1xyXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlciB8fFxyXG4gICAgICAgICAgICBvcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyIHx8XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlclVubGlua0Zyb21Qcm92aWRlcikge1xyXG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gZGF0YVF1ZXJ5LmRhdGEuUHJvdmlkZXIgfHwgZGF0YVF1ZXJ5LmRhdGEuSWRlbnRpdHkuUHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJ1RoZSBVc2VycyBvcGVyYXRpb24gJyArIG9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9ucyA9IHt9O1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGVdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZV0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGVdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldEFjbF0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXJdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcl0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXJdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXJdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbl0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ291dF0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckNoYW5nZVBhc3N3b3JkXSA9IHRydWU7XHJcblxyXG4gICAgdmFyIHVuc3VwcG9ydGVkT2ZmbGluZUhlYWRlcnMgPSBbSGVhZGVycy5wb3dlckZpZWxkc107XHJcblxyXG4gICAgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZGF0YSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdWNjZXNzXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXJnZUFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbkNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIucHVyZ2VBbGwoc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250ZW50IHR5cGUgZnJvbSB0aGUgb2ZmbGluZSBzdG9yYWdlXHJcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVTdG9yYWdlTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCB0eXBlIHRvIHB1cmdlXHJcbiAgICAgICAgICogQHBhcmFtIHN1Y2Nlc3NcclxuICAgICAgICAgKiBAcGFyYW0gZXJyb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZVN0b3JhZ2VNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgdG8gcHVyZ2VcclxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVyZ2U6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdGVyLnB1cmdlKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcm9jZXNzUXVlcnk6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlID0gdGhpcy5nZXRVbnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UgJiYgIWRhdGFRdWVyeS5pc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IodW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc29ydCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5zb3J0KTtcclxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnRha2UpO1xyXG4gICAgICAgICAgICB2YXIgc2tpcCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5za2lwKTtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5zZWxlY3QpO1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLmZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMuZXhwYW5kKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuZmlsdGVyIGluc3RhbmNlb2YgRXZlcmxpdmUuUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJPYmogPSBkYXRhUXVlcnkuZmlsdGVyLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmaWx0ZXJPYmouJHdoZXJlIHx8IGZpbHRlcjtcclxuICAgICAgICAgICAgICAgIHNvcnQgPSBmaWx0ZXJPYmouJHNvcnQgfHwgc29ydDtcclxuICAgICAgICAgICAgICAgIGxpbWl0ID0gZmlsdGVyT2JqLiR0YWtlIHx8IGxpbWl0O1xyXG4gICAgICAgICAgICAgICAgc2tpcCA9IGZpbHRlck9iai4kc2tpcCB8fCBza2lwO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ID0gZmlsdGVyT2JqLiRzZWxlY3QgfHwgc2VsZWN0O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmlsdGVyT2JqLiRleHBhbmQgfHwgZXhwYW5kO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlciB8fCBmaWx0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkT3BlcmF0b3JzID0gdXRpbHMuZ2V0VW5zdXBwb3J0ZWRPcGVyYXRvcnMoZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkT3BlcmF0b3JDb3VudCA9IHVuc3VwcG9ydGVkT3BlcmF0b3JzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkT3BlcmF0b3JDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkT3BlcmF0b3JDb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnVGhlIG9wZXJhdG9yICcgKyB1bnN1cHBvcnRlZE9wZXJhdG9yc1swXSArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUuJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnVGhlIG9wZXJhdG9ycyAnICsgdW5zdXBwb3J0ZWRPcGVyYXRvcnMuam9pbignLCcpICsgJ2FyZSBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKGVycm9yTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMudHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZChmaWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChkYXRhUXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZChkYXRhUXVlcnksIGZpbHRlciwgc29ydCwgc2tpcCwgbGltaXQsIHNlbGVjdCwgZXhwYW5kKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJ5SWQoZGF0YVF1ZXJ5LCBleHBhbmQpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudChkYXRhUXVlcnksIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRhdGFRdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShkYXRhUXVlcnksIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZTpcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuX2lkID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShkYXRhUXVlcnksIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5pc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcihkYXRhUXVlcnkub3BlcmF0aW9uICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZScpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2U6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gdW5zdXBwb3J0ZWRPZmZsaW5lSGVhZGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuZ2V0SGVhZGVyKGhlYWRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1RoZSBoZWFkZXIgJyArIGhlYWRlciArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmaWxlcycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnT3BlcmF0aW9ucyBvbiBmaWxlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd1c2VycycgJiYgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbZGF0YVF1ZXJ5Lm9wZXJhdGlvbl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFVzZXJzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RW5jcnlwdGlvblByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0aW9uUHJvdmlkZXI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENyZWF0ZVJlc3VsdDogZnVuY3Rpb24gKGNyZWF0ZWRJdGVtcykge1xyXG4gICAgICAgICAgICBpZiAoY3JlYXRlZEl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlZEF0OiB1dGlscy5jbG9uZURhdGUoY3JlYXRlZEl0ZW1zWzBdLkNyZWF0ZWRBdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIElkOiBjcmVhdGVkSXRlbXNbMF0uX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxlQ3JlYXRlUmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY3JlYXRlZEl0ZW1zLCBmdW5jdGlvbiAoY3JlYXRlZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZUNyZWF0ZVJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlZEF0OiB1dGlscy5jbG9uZURhdGUoY3JlYXRlZEl0ZW0uQ3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSWQ6IGNyZWF0ZWRJdGVtLl9pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG11bHRpcGxlQ3JlYXRlUmVzdWx0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fY3JlYXRlSXRlbXMoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBkYXRhUXVlcnkuZGF0YSwgZGF0YVF1ZXJ5LmlzU3luYywgZGF0YVF1ZXJ5LnByZXNlcnZlU3RhdGUsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlUmVzdWx0ID0gc2VsZi5fZ2V0Q3JlYXRlUmVzdWx0KGNyZWF0ZWRJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0LCBleHBhbmQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25MZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5fcHJlcGFyZUV4cGFuZChleHBhbmQsIGRhdGFRdWVyeSwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gcHJlcGFyZUV4cGFuZFJlc3VsdC5tYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbiwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAgfHwgbGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbkxlbmd0aCA9IGFsbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZUlkVHJhbnNmb3JtKHJlc3VsdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V4cGFuZFJlc3VsdChwcmVwYXJlRXhwYW5kUmVzdWx0LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBjb2xsZWN0aW9uTGVuZ3RoLCBkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVhZEludGVybmFsOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJDb3B5ID0gXy5leHRlbmQoe30sIGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBhY3R1YWxGaWx0ZXIgPSB0aGlzLl9nZXRXaXRob3V0RGVsZXRlZEZpbHRlcihmaWx0ZXJDb3B5KTtcclxuICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy50cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkKGFjdHVhbEZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG1pbmdvLlF1ZXJ5KGFjdHVhbEZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBtaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnksIHNlbGVjdCk7XHJcbiAgICAgICAgICAgIGlmIChzb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3Iuc29ydChzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNraXApIHtcclxuICAgICAgICAgICAgICAgIGN1cnNvci5za2lwKHNraXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnNvci5saW1pdChsaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChjdXJzb3IuYWxsKCksIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHRlbmQoe30sIGl0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZWFkQnlJZDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZXhwYW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9wcmVwYXJlRXhwYW5kKGV4cGFuZCwgZGF0YVF1ZXJ5LCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0oaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V4cGFuZFJlc3VsdChwcmVwYXJlRXhwYW5kUmVzdWx0LCBpdGVtKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBudWxsLCBkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wcmVwYXJlRXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kLCBkYXRhUXVlcnksIGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFByb2Nlc3Nvci5wcmVwYXJlKGV4cGFuZCwgZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBpc0FycmF5LCBkYXRhUXVlcnkuZmllbGRzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBwcmVwYXJlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0V4cGFuZEVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZEV4cGFuZEV4cHJlc3Npb24uY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByZXBhcmVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9leHBhbmRSZXN1bHQ6IGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0LCByZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFByb2Nlc3Nvci5leHBhbmQocHJlcGFyZUV4cGFuZFJlc3VsdC5yZWxhdGlvbnNUcmVlLCByZXN1bHQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZU1vZHVsZTogc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdFeHBhbmRFcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRFeHBhbmRFeHByZXNzaW9uLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFdpdGhvdXREZWxldGVkRmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciB3aXRob3V0RGVsZXRlZEZpbHRlciA9IHtcclxuICAgICAgICAgICAgICAgICRhbmQ6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdpdGhvdXREZWxldGVkRmlsdGVyLiRhbmQucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgICAgICB2YXIgZGVsZXRlT2ZmbGluZUZpbHRlciA9IHt9O1xyXG4gICAgICAgICAgICBkZWxldGVPZmZsaW5lRmlsdGVyW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSB7JG5lOiBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkfTtcclxuICAgICAgICAgICAgd2l0aG91dERlbGV0ZWRGaWx0ZXIuJGFuZC5wdXNoKGRlbGV0ZU9mZmxpbmVGaWx0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dERlbGV0ZWRGaWx0ZXI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlSXRlbXMoZGF0YVF1ZXJ5LCBkYXRhUXVlcnkuZGF0YSwgZmlsdGVyLCBkYXRhUXVlcnkuaXNTeW5jLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW1zKGRhdGFRdWVyeSwgZmlsdGVyLCBkYXRhUXVlcnkuaXNTeW5jLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb3VudDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJSZXN1bHQgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbiwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7cmVzdWx0OiBmaWx0ZXJSZXN1bHQubGVuZ3RofSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldE9mZmxpbmU6IGZ1bmN0aW9uIChvZmZsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXAub2ZmbGluZSA9IG9mZmxpbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNPbmxpbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnNldHVwLm9mZmxpbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3ByZXBhcmVTeW5jRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlc0ZvclN5bmMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlc1N5bmNEYXRhID0ge307XHJcbiAgICAgICAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlc0ZvclN5bmMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW5jSXRlbXMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGNvbnRlbnRUeXBlLm9mZmxpbmVJdGVtc1RvU3luYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3luY0RhdGEgPSBzZWxmLl9nZXRTeW5jSXRlbVN0YXRlcyh0eXBlTmFtZSwgc3luY0l0ZW1zLCBjb250ZW50VHlwZS5zZXJ2ZXJJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaChzeW5jRGF0YS5jb25mbGljdHMpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGFbdHlwZU5hbWVdID0gc3luY0RhdGEuaXRlbXNGb3JTeW5jO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IGNvbmZsaWN0cyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlc1N5bmNEYXRhOiBjb250ZW50VHlwZXNTeW5jRGF0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZXNvbHZlQ29uZmxpY3RzOiBmdW5jdGlvbiAoc3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlSZXNvbHV0aW9uU3RyYXRlZ3koc3luY0RhdGEuY29uZmxpY3RzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fbWVyZ2VSZXNvbHZlZENvbmZsaWN0cy5iaW5kKHNlbGYsIHN5bmNEYXRhLmNvbmZsaWN0cywgc3luY0RhdGEuY29udGVudFR5cGVzU3luY0RhdGEpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jRGF0YS5jb250ZW50VHlwZXNTeW5jRGF0YTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU3luY2hyb25pemluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNTeW5jaHJvbml6aW5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9maXJlU3luY1N0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX2lzU3luY2hyb25pemluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2lzU3luY2hyb25pemluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ldmVybGl2ZS5fZW1pdHRlci5lbWl0KCdzeW5jU3RhcnQnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2ZpcmVTeW5jRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXMsIGZ1bmN0aW9uIChzeW5jZWRJdGVtcywgY29udGVudFR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRUb1NlcnZlciArPSBfLndoZXJlKHN5bmNlZEl0ZW1zLCB7c3RvcmFnZTogJ3NlcnZlcid9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRUb0NsaWVudCArPSBfLndoZXJlKHN5bmNlZEl0ZW1zLCB7c3RvcmFnZTogJ2NsaWVudCd9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ldmVybGl2ZS5fZW1pdHRlci5lbWl0KCdzeW5jRW5kJywgdGhpcy5fc3luY1Jlc3VsdEluZm8pO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY1Jlc3VsdEluZm87XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2VhY2hTeW5jSXRlbTogZnVuY3Rpb24gKGl0ZW1zLCBnZXRGaWx0ZXJGdW5jdGlvbiwgY29udGVudFR5cGVOYW1lLCBvcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1GaWx0ZXIgPSBnZXRGaWx0ZXJGdW5jdGlvbihpdGVtLnJlbW90ZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGZvciB0aGlzIGl0ZW0gd2UgZG8gbm90IHdhbnQgdG8gdHJ5IGFuZCBzeW5jIGl0IGFnYWluXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0SXRlbSA9IGl0ZW0ucmVzdWx0aW5nSXRlbTtcclxuICAgICAgICAgICAgICAgIGlmIChfLnNvbWUoc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbY29udGVudFR5cGVOYW1lXSwge2l0ZW1JZDogcmVzdWx0SXRlbS5JZH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbihyZXN1bHRJdGVtLCBpdGVtRmlsdGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZENyZWF0ZWRJdGVtc0ZvclN5bmM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlID0gXy5wbHVjayhjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLCAncmVzdWx0aW5nSXRlbScpO1xyXG4gICAgICAgICAgICB2YXIgaWRzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZHMgPSBfLnBsdWNrKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCAnSWQnKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVJZFRyYW5zZm9ybShyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bmNQcm9taXNlc1snY3JlYXRlJ10gPVxyXG4gICAgICAgICAgICAgICAgbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSA9IF8ubWFwKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLklkID0gcmVzLnJlc3VsdFtpbmRleF0uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5DcmVhdGVkQXQgPSBpdGVtLk1vZGlmaWVkQXQgPSByZXMucmVzdWx0W2luZGV4XS5DcmVhdGVkQXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVzZU9mZmxpbmUodHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSwgZnVuY3Rpb24gKGNyZWF0ZWRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKGNyZWF0ZWRJdGVtLCBjb2xsZWN0aW9uTmFtZSwgJ3NlcnZlcicsICdjcmVhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRzICYmIGlkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB7SWQ6IHskaW46IGlkc319O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51c2VPZmZsaW5lKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRlc3Ryb3koZmlsdGVyKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY3JlYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnY2xpZW50J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NyZWF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ2NsaWVudCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY3JlYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ3NlcnZlcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjcmVhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZFVwZGF0ZWRJdGVtc0ZvclN5bmM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIGdldEZpbHRlck9wZXJhdGlvbiwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgaXRlbVVwZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgICAgICBzZWxmLl9lYWNoU3luY0l0ZW0oY29udGVudFR5cGVEYXRhLm1vZGlmaWVkSXRlbXMsIGdldEZpbHRlck9wZXJhdGlvbiwgY29sbGVjdGlvbk5hbWUsIGl0ZW1VcGRhdGVPcGVyYXRpb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGREZWxldGVkSXRlbXNGb3JTeW5jOiBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCBnZXRGaWx0ZXJPcGVyYXRpb24sIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIGl0ZW1EZWxldGVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgICAgIHNlbGYuX2VhY2hTeW5jSXRlbShjb250ZW50VHlwZURhdGEuZGVsZXRlZEl0ZW1zLCBnZXRGaWx0ZXJPcGVyYXRpb24sIGNvbGxlY3Rpb25OYW1lLCBpdGVtRGVsZXRlT3BlcmF0aW9uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25TeW5jUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXMsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBvcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlcy5yZXN1bHQgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVJdGVtU3luY2VkKGl0ZW0sIGNvbGxlY3Rpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIEV2ZXJsaXZlRXJyb3JzLnN5bmNDb25mbGljdCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsICdzZXJ2ZXInLCAndXBkYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRJdGVtID0gXy5leHRlbmQoe30sIGl0ZW0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTW9kaWZpZWRBdDogcmVzLk1vZGlmaWVkQXRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB1cGRhdGVkSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLklkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW5jOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NRdWVyeSh1cGRhdGVRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkSXRlbVN5bmNlZChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgJ3NlcnZlcicsICdkZWxldGUnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVyZ2VCeUlkKGNvbGxlY3Rpb25OYW1lLCBpdGVtLklkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wdXJnZUJ5SWQ6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgaXRlbUlkKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRDb2xsZWN0aW9uKGNvbnRlbnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29sbGVjdGlvbltpdGVtSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzeW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8gPSBzZWxmLl9zeW5jUmVzdWx0SW5mbyB8fCB7XHJcbiAgICAgICAgICAgICAgICBzeW5jZWRJdGVtczoge30sXHJcbiAgICAgICAgICAgICAgICBzeW5jZWRUb1NlcnZlcjogMCxcclxuICAgICAgICAgICAgICAgIHN5bmNlZFRvQ2xpZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgZmFpbGVkSXRlbXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBhZGRlZCBmb3IgdmlzaWJpbGl0eVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT25saW5lKCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDYW5ub3Qgc3luY2hyb25pemUgd2hpbGUgb2ZmbGluZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9maXJlU3luY1N0YXJ0KClcclxuICAgICAgICAgICAgICAgIC50aGVuKHNlbGYuX2FwcGx5U3luYy5iaW5kKHNlbGYpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN5bmNSZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZsaWN0c1doaWxlU3luYyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChzeW5jUmVzdWx0cywgZnVuY3Rpb24gKHN5bmNSZXN1bHQsIGl0ZW1JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3luY1Jlc3VsdCAmJiBzeW5jUmVzdWx0LnN0YXRlID09PSAncmVqZWN0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VHlwZSA9IHN5bmNSZXN1bHQucmVhc29uLmNvbnRlbnRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmNSZXN1bHQucmVhc29uICYmIHN5bmNSZXN1bHQucmVhc29uLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLnN5bmNDb25mbGljdC5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzV2hpbGVTeW5jLnB1c2goc3luY1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNhdmUgdGltZSBhbmQgdHJhZmZpYyB3ZSBhcmUgdXNpbmcgYSBzaW5nbGUgY3JlYXRlIHJlcXVlc3QgZm9yIGFsbCBpdGVtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgd2h5IGlmIHRoZXJlIGlzIGFuIGVycm9yIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGl0ZW1zIHdlIHRyaWVkIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGhlIHNhbWUgZXJyb3IgZm9yIGFsbCBpdGVtcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHN5bmNSZXN1bHQucmVhc29uLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV0gPSBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1t0YXJnZXRUeXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NyZWF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHN5bmNSZXN1bHQucmVhc29uLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbVN5bmNlZChpdGVtLCB0YXJnZXRUeXBlLCAnc2VydmVyJywgJ2NyZWF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaChfLmV4dGVuZCh7aXRlbUlkOiBpdGVtLklkfSwgXy5waWNrKHN5bmNSZXN1bHQucmVhc29uLCAnc3RvcmFnZScsICd0eXBlJywgJ2Vycm9yJykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbVN5bmNlZChpdGVtSWQsIHRhcmdldFR5cGUsICdzZXJ2ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKF8uZXh0ZW5kKHtpdGVtSWQ6IGl0ZW1JZH0sIF8ucGljayhzeW5jUmVzdWx0LnJlYXNvbiwgJ3N0b3JhZ2UnLCAndHlwZScsICdlcnJvcicpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25mbGljdHNXaGlsZVN5bmMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN5bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9maXJlU3luY0VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jRW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaGFuZGxlS2VlcFNlcnZlcjogZnVuY3Rpb24gKHR5cGVOYW1lLCBjb25mbGljdGluZ0l0ZW0sIG9mZmxpbmVTeW5jT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VydmVySXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtO1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50SXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5jbGllbnRJdGVtO1xyXG4gICAgICAgICAgICB2YXIgc3luY1F1ZXJ5O1xyXG4gICAgICAgICAgICBpZiAoc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGl0ZW0gb2ZmbGluZVxyXG4gICAgICAgICAgICAgICAgc3luY1F1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXJ2ZXJJdGVtLklkXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJ2ZXJJdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJJdGVtICYmICFjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaXRlbSBvZmZsaW5lXHJcbiAgICAgICAgICAgICAgICBzeW5jUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VydmVySXRlbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGl0ZW0gb2ZmbGluZVxyXG4gICAgICAgICAgICAgICAgc3luY1F1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjbGllbnRJdGVtLklkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQm90aCBzZXJ2ZXJJdGVtIGFuZCBjbGllbnRJdGVtIGFyZSBub3Qgc2V0IHdoZW4gc3luY2luZyBkYXRhIHdpdGggXCJLZWVwU2VydmVyXCIgcmVzb2x1dGlvbiBzdHJhdGVneS4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3luY1F1ZXJ5LmlzU3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wcm9jZXNzUXVlcnkoc3luY1F1ZXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzeW5jUXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKHNlcnZlckl0ZW0sIHR5cGVOYW1lLCAnY2xpZW50JywgJ3VwZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkSXRlbVN5bmNlZChzZXJ2ZXJJdGVtLCB0eXBlTmFtZSwgJ2NsaWVudCcsICdjcmVhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoY2xpZW50SXRlbSwgdHlwZU5hbWUsICdjbGllbnQnLCAnZGVsZXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzeW5jUXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSBzZXJ2ZXJJdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9ICd1cGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkID0gc2VydmVySXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSAnY3JlYXRlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZCA9IGNsaWVudEl0ZW0uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gJ2RlbGV0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9wZXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBzeW5jUXVlcnkuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ2NsaWVudCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2hhbmRsZUtlZXBDbGllbnQ6IGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0sIGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uY2xpZW50SXRlbTtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkT2JqZWN0ID0gXy5leHRlbmQoY2xpZW50SXRlbSwge01vZGlmaWVkQXQ6IG5ldyBEYXRlKHNlcnZlckl0ZW0uTW9kaWZpZWRBdCl9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogbW9kaWZpZWRPYmplY3RcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuZGVsZXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IHNlcnZlckl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY3JlYXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGNsaWVudEl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0JvdGggc2VydmVySXRlbSBhbmQgY2xpZW50SXRlbSBhcmUgbm90IHNldCB3aGVuIHN5bmNpbmcgZGF0YSB3aXRoIFwiS2VlcENsaWVudFwiIHJlc29sdXRpb24gc3RyYXRlZ3kuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaGFuZGxlQ3VzdG9tOiBmdW5jdGlvbiAoY29uZmxpY3RpbmdJdGVtLCB0eXBlTmFtZSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zLCBjb250ZW50VHlwZVN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjbGllbnRJdGVtID0gY29uZmxpY3RpbmdJdGVtLmNsaWVudEl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21JdGVtID0gXy5vbWl0KGNvbmZsaWN0aW5nSXRlbS5yZXN1bHQuaXRlbSwgJ0NyZWF0ZWRBdCcsICdNb2RpZmllZEF0Jyk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtICYmIGN1c3RvbUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcnZlckl0ZW0gLy8gY3JlYXRlIHRoZSBzZXJ2ZXIgaXRlbSBvZmZsaW5lIGFuZCBpdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiBzeW5jIGZpbmlzaGVzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5LnByZXNlcnZlU3RhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlSXRlbU9mZmxpbmVRdWVyeS5pc1N5bmMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKHRoaXMucHJvY2Vzc1F1ZXJ5KGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSAmJiAhY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tSXRlbS5JZCA9IHNlcnZlckl0ZW0uSWQ7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBjdXN0b21JdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJJdGVtICYmICFjdXN0b21JdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmRlbGV0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBzZXJ2ZXJJdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VydmVySXRlbSAmJiBjdXN0b21JdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVJdGVtT2ZmbGluZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN1c3RvbUl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNsaWVudEl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZsaW5lU3luY09wZXJhdGlvbnMucHVzaCh0aGlzLnByb2Nlc3NRdWVyeSh1cGRhdGVJdGVtT2ZmbGluZVF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21JdGVtLklkID0gY2xpZW50SXRlbS5JZDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNyZWF0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGN1c3RvbUl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tSXRlbS5JZCA9IHNlcnZlckl0ZW0uSWQ7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBjdXN0b21JdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9tZXJnZVJlc29sdmVkQ29uZmxpY3RzOiBmdW5jdGlvbiAoY29uZmxpY3RzLCBzeW5jRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2ZmbGluZVN5bmNPcGVyYXRpb25zID0gW107XHJcbiAgICAgICAgICAgIF8uZWFjaChjb25mbGljdHMsIGZ1bmN0aW9uIChjb25mbGljdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gY29uZmxpY3QuY29udGVudFR5cGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMsIGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGVTeW5jRGF0YSA9IHN5bmNEYXRhW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZsaWN0aW5nSXRlbS5yZXN1bHQucmVzb2x1dGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBTZXJ2ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVLZWVwU2VydmVyKHR5cGVOYW1lLCBjb25mbGljdGluZ0l0ZW0sIG9mZmxpbmVTeW5jT3BlcmF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBDbGllbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVLZWVwQ2xpZW50KGNvbmZsaWN0aW5nSXRlbSwgY29udGVudFR5cGVTeW5jRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLkN1c3RvbTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUN1c3RvbShjb25mbGljdGluZ0l0ZW0sIHR5cGVOYW1lLCBvZmZsaW5lU3luY09wZXJhdGlvbnMsIGNvbnRlbnRUeXBlU3luY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuYWxsKG9mZmxpbmVTeW5jT3BlcmF0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFN5bmNJdGVtU3RhdGVzOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIG9mZmxpbmVJdGVtcywgc2VydmVySXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlU3luY0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtc0ZvclN5bmM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkSXRlbXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSXRlbXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtczogW11cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZU5hbWU6IGNvbnRlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXM6IFtdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBfLmVhY2gob2ZmbGluZUl0ZW1zLCBmdW5jdGlvbiAob2ZmbGluZUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gXy5maW5kV2hlcmUoc2VydmVySXRlbXMsIHtJZDogb2ZmbGluZUl0ZW0uSWR9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0uSWQgPT09IG9mZmxpbmVJdGVtLklkICYmIG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbY29udGVudFR5cGVdID0gc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbY29udGVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IHNlcnZlckl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY3JlYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6ICdjbGllbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IEV2ZXJsaXZlRXJyb3JzLnN5bmNFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGllbnRJdGVtQ2hhbmdlZCA9ICEhb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVXBkYXRlQ29uZmxpY3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudEl0ZW1DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1VwZGF0ZUNvbmZsaWN0ID0gc2VydmVySXRlbS5Nb2RpZmllZEF0LmdldFRpbWUoKSAhPT0gb2ZmbGluZUl0ZW0uTW9kaWZpZWRBdC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVXBkYXRlQ29uZmxpY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jb25mbGljdHMuY29uZmxpY3RpbmdJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIHdhcyBtb2RpZmllZCBvbiB0aGUgc2VydmVyIGFuZCBkZWxldGVkIGxvY2FsbHkgd2UgaGF2ZSBhIGNvbmZsaWN0IGFuZCBzZXQgdGhlIGNsaWVudCBpdGVtIHRvIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCBpcyBhIHNpbXBsZSBtb2RpZmljYXRpb24gY29uZmxpY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEl0ZW06IG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQgPyBudWxsIDogb2ZmbGluZUl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMuZGVsZXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogb2ZmbGluZUl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IG9mZmxpbmVJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaW4gbWVtb3J5IGhhcyBiZWVuIG1vZGlmaWVkLCBidXQgdGhlIGl0ZW0gb24gdGhlIHNlcnZlciBoYXMgYmVlbiBkZWxldGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY29uZmxpY3RzLmNvbmZsaWN0aW5nSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJdGVtOiBvZmZsaW5lSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW06IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuaXRlbXNGb3JTeW5jLmNyZWF0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBvZmZsaW5lSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUeXBlU3luY0RhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldFJlc29sdXRpb25UeXBlRm9ySXRlbTogZnVuY3Rpb24gKHJlc29sdXRpb25UeXBlLCBjb25mbGljdGluZ0l0ZW0pIHtcclxuICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtLnJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb25UeXBlOiByZXNvbHV0aW9uVHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVJlc29sdXRpb25TdHJhdGVneTogZnVuY3Rpb24gKGNvbmZsaWN0cykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb25mbGljdFJlc29sdXRpb25TdHJhdGVneSA9IHNlbGYuc2V0dXAuY29uZmxpY3RzLnN0cmF0ZWd5O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZsaWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25mbGljdCA9IGNvbmZsaWN0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25mbGljdFJlc29sdXRpb25TdHJhdGVneSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0UmVzb2x1dGlvblR5cGVGb3JJdGVtLmJpbmQoc2VsZiwgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5LZWVwU2VydmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DbGllbnRXaW5zOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21TdHJhdGVneSA9IHNlbGYuc2V0dXAuY29uZmxpY3RzLmltcGxlbWVudGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignSW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtdXN0IGJlIHByb3ZpZGVkIHdoZW4gc2V0IHRvIEN1c3RvbScpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVN0cmF0ZWd5KGNvbmZsaWN0cywgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoJ0ludmFsaWQgcmVzb2x1dGlvbiBzdHJhdGVneSBwcm92aWRlZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRTeW5jUHJvbWlzZUJhdGNoOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGJhdGNoSWRzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdJZCc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckaW4nOiBiYXRjaElkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBhcHBseU9mZmxpbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IHJlamVjdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5ID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW2RhdGFRdWVyeS5vcGVyYXRpb25dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gZ2V0UmVxdWVzdE9wdGlvbnNGcm9tUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoc2VsZi5ldmVybGl2ZS5zZXR1cCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRTeW5jUHJvbWlzZUZvckNvbGxlY3Rpb246IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29uc3RhbnRzLnN5bmNCYXRjaFNpemU7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2ZmbGluZUl0ZW1zVG9TeW5jID0gc2VsZi5fZ2V0RGlydHlJdGVtcyhjb2xsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbGxJZHNGb3JTeW5jO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShjb250ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGFsbElkc0ZvclN5bmMgPSBfLnBsdWNrKG9mZmxpbmVJdGVtc1RvU3luYywgJ19pZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzRm9yU3luYyA9IF8ucGx1Y2soXy5yZWplY3Qob2ZmbGluZUl0ZW1zVG9TeW5jLCBmdW5jdGlvbiAob2ZmbGluZUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDtcclxuICAgICAgICAgICAgICAgIH0pLCAnX2lkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBiYXRjaENvdW50ID0gTWF0aC5jZWlsKGFsbElkc0ZvclN5bmMubGVuZ3RoIC8gYmF0Y2hTaXplKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTa2lwU2l6ZSA9IGkgKiBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZHMgPSBhbGxJZHNGb3JTeW5jLnNsaWNlKGJhdGNoU2tpcFNpemUsIGJhdGNoU2tpcFNpemUgKyBiYXRjaFNpemUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5bmNHZXRTZXJ2ZXJJdGVtc1Byb21pc2UgPSB0aGlzLl9nZXRTeW5jUHJvbWlzZUJhdGNoKGNvbnRlbnRUeXBlLCBiYXRjaElkcyk7XHJcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goc3luY0dldFNlcnZlckl0ZW1zUHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByc3ZwLmFsbChiYXRjaGVzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcnZlckl0ZW1zU3luY1Jlc3BvbnNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW1zOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChzZXJ2ZXJJdGVtc1N5bmNSZXNwb25zZXMsIGZ1bmN0aW9uIChzZXJ2ZXJJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VydmVySXRlbXMgPSBfLnVuaW9uKHJlc3VsdC5zZXJ2ZXJJdGVtcywgc2VydmVySXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZUl0ZW1zVG9TeW5jID0gb2ZmbGluZUl0ZW1zVG9TeW5jO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkSXRlbVN5bmNlZDogZnVuY3Rpb24gKGl0ZW0sIGNvbnRlbnRUeXBlLCBzeW5jU3RvcmFnZSwgc3luY1R5cGUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBzeW5jVHlwZSxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNTdG9yYWdlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZUl0ZW1TeW5jZWQ6IGZ1bmN0aW9uIChpdGVtLCBjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbUlkO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgaXRlbUlkID0gaXRlbTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1JZCA9IGl0ZW0uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN5bmNlZEl0ZW1zID0gdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdO1xyXG4gICAgICAgICAgICB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0gPSBfLndpdGhvdXQoc3luY2VkSXRlbXMsIF8uZmluZFdoZXJlKHN5bmNlZEl0ZW1zLCB7aXRlbUlkOiBpdGVtSWR9KSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENsaWVudFdpbnNTeW5jRGF0YTogZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzeW5jRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc3luY0RhdGFba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSXRlbXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSXRlbXM6IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlydHlJdGVtcyA9IHNlbGYuX2dldERpcnR5SXRlbXMoY29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXNGb3JTeW5jID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShkaXJ0eUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtc0ZvclN5bmMsIGZ1bmN0aW9uIChpdGVtRm9yU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaXRlbUZvclN5bmNbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YVtrZXldLmNyZWF0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBpdGVtRm9yU3luYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBpdGVtRm9yU3luY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW2tleV0ubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBpdGVtRm9yU3luYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBpdGVtRm9yU3luY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY0RhdGFba2V5XS5kZWxldGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogaXRlbUZvclN5bmMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogaXRlbUZvclN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbUZvclN5bmNbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHN5bmNEYXRhW2tleV0ub2ZmbGluZUl0ZW1zVG9TeW5jID0gaXRlbXNGb3JTeW5jO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bmNEYXRhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGRNb2RpZmllZEl0ZW1zRm9yU3luY0NsaWVudFdpbnM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWRkVXBkYXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1doZW4gdXBkYXRpbmcgYW4gaXRlbSBpdCBtdXN0IGhhdmUgYW4gSWQgZmllbGQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtSWRdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZVNpbmdsZShpdGVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCAnc2VydmVyJywgJ3VwZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRJdGVtID0gXy5leHRlbmQoe30sIGl0ZW0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb2RpZmllZEF0OiByZXMuTW9kaWZpZWRBdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZEl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NRdWVyeSh1cGRhdGVRdWVyeSkudGhlbihyZXNvbHZlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6ICdjbGllbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiByZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ3NlcnZlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmNDbGllbnRXaW5zOiBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBnZXRTeW5jRmlsdGVyTm9Nb2RpZmllZEF0LCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGl0ZW0sIGl0ZW1GaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbS5JZF0gPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW0uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignV2hlbiBkZWxldGluZyBhbiBpdGVtIGl0IG11c3QgaGF2ZSBhbiBJZCBmaWVsZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRlc3Ryb3lTaW5nbGUoaXRlbUZpbHRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCAnc2VydmVyJywgJ2RlbGV0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wdXJnZUJ5SWQoY29sbGVjdGlvbk5hbWUsIGl0ZW0uSWQpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6ICdjbGllbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnc2VydmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtSWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseUNsaWVudFdpbnM6IGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzeW5jRGF0YSA9IHRoaXMuX2dldENsaWVudFdpbnNTeW5jRGF0YShjb2xsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBzeW5jUHJvbWlzZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChzeW5jRGF0YSwgZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhQ29sbGVjdGlvbiA9IHNlbGYuZXZlcmxpdmUuZGF0YSh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRDcmVhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZE1vZGlmaWVkSXRlbXNGb3JTeW5jQ2xpZW50V2lucyhjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuZGVsZXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmNDbGllbnRXaW5zKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaFNldHRsZWQoc3luY1Byb21pc2VzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlTdGFuZGFyZFN5bmM6IGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB7fTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbGxlY3Rpb25zLCBmdW5jdGlvbiAoY29sbGVjdGlvbiwgY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzW2NvbnRlbnRUeXBlXSA9IHNlbGYuX2dldFN5bmNQcm9taXNlRm9yQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaChwcm9taXNlcylcclxuICAgICAgICAgICAgICAgIC50aGVuKHNlbGYuX3ByZXBhcmVTeW5jRGF0YS5iaW5kKHNlbGYpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fcmVzb2x2ZUNvbmZsaWN0cy5iaW5kKHNlbGYpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3luY1Byb21pc2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlU3luY0RhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQ29sbGVjdGlvbiA9IHNlbGYuZXZlcmxpdmUuZGF0YSh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkQ3JlYXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLm1vZGlmaWVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRVcGRhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgZ2V0U3luY0ZpbHRlckZvckl0ZW0sIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpdGVtRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW0uSWRdID0gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlKGl0ZW0sIGl0ZW1GaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vblN5bmNSZXNwb25zZShyZXMsIGl0ZW0sIHR5cGVOYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmRlbGV0ZWRJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBnZXRTeW5jRmlsdGVyRm9ySXRlbSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGl0ZW1GaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbS5JZF0gPSBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZXN0cm95KGl0ZW1GaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vblN5bmNSZXNwb25zZShyZXMsIGl0ZW0sIHR5cGVOYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByc3ZwLmhhc2hTZXR0bGVkKHN5bmNQcm9taXNlcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlTeW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBbGxDb2xsZWN0aW9ucygpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR1cC5jb25mbGljdHMuc3RyYXRlZ3kgPT09IGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DbGllbnRXaW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseUNsaWVudFdpbnMoY29sbGVjdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseVN0YW5kYXJkU3luYyhjb2xsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldERpcnR5SXRlbXM6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB7fTtcclxuICAgICAgICAgICAgZmlsdGVyW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSB7JGV4aXN0czogdHJ1ZX07XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG1pbmdvLlF1ZXJ5KGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBtaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLmFsbCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRBbGxDb2xsZWN0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZSh0aGlzLl9wZXJzaXN0ZXIuZ2V0QWxsRGF0YS5iaW5kKHRoaXMuX3BlcnNpc3RlcikpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHBlcnNpc3RlciBpZiB0aGVyZSBpcyBubyBkYXRhIGluIHRoZSBjb2xsZWN0aW9uIGNhY2hlIGZvciB0aGlzIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdGVyLmdldERhdGEoY29udGVudFR5cGUsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0gPSBkYXRhIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wZXJzaXN0RGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZURhdGEgPSBzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdHJhbnNmb3JtUGVyc2lzdGVkRGF0YShjb250ZW50VHlwZSwgY29udGVudFR5cGVEYXRhKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5zYXZlRGF0YShjb250ZW50VHlwZSwgY29udGVudFR5cGVEYXRhLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0QnlJZDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkKSB7XHJcbiAgICAgICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdJZCBmaWVsZCBpcyBtYW5kYXRvcnkgd2hlbiB1c2luZyBvZmZsaW5lIHN0b3JhZ2UnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baWRdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF8uZXh0ZW5kKHt9LCBjb2xsZWN0aW9uW2lkXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEZWxldGVkID0gaXRlbSAmJiBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGVsZXRlZCA/IHVuZGVmaW5lZCA6IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0SXRlbTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZW0sIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29sbGVjdGlvbltpdGVtLl9pZF0gPSBpdGVtO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5zZXR1cCAmJiB0aGlzLnNldHVwLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnNldHVwLnR5cGVTZXR0aW5nc1tjb250ZW50VHlwZV0gJiYgdGhpcy5zZXR1cC50eXBlU2V0dGluZ3NbY29udGVudFR5cGVdLmF1dG9HZW5lcmF0ZUlkID09PSBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NyZWF0ZUl0ZW1zOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGl0ZW1zLCBpc1N5bmMsIHByZXNlcnZlU3RhdGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29sbGVjdGlvbihjb250ZW50VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zRm9yQ3JlYXRlID0gXy5pc0FycmF5KGl0ZW1zKSA/IGl0ZW1zIDogW2l0ZW1zXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZEl0ZW1zID0gXy5tYXAoaXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChjdXJyZW50SXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub0NyZWF0ZSA9IF8uZXh0ZW5kKHt9LCBjdXJyZW50SXRlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuX2lkID0gaXRlbVRvQ3JlYXRlLklkIHx8IHV1aWQudjEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1Ub0NyZWF0ZS5JZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0l0ZW0gPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub0NyZWF0ZS5faWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUV4aXN0cyA9ICEhZXhpc3RpbmdJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtRXhpc3RzICYmICghaXNTeW5jICYmICFwcmVzZXJ2ZVN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIHJldHVybiB0aGUgc2FtZSBlcnJvciBhcyB0aGUgc2VydmVyIGRvZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihuZXcgRXJyb3IoJ0FuIGl0ZW0gd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGFscmVhZHkgZXhpc3RzJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYyAmJiBwcmVzZXJ2ZVN0YXRlICYmIGl0ZW1FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGV4aXN0aW5nSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGlzU3luYyA/IHVuZGVmaW5lZCA6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7IC8vIHNldCB0aGUgc3RhdGUgdG8gY3JlYXRlZCBvbmx5IGlmIG5vdCBzeW5jaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFudWFsbHkgY2xvbmUgdGhlIGRhdGVzIGluIG9yZGVyIHRvIGRlcmVmZXJlbmNlIHRoZW0gZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0IGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIF8uZXh0ZW5kcyB3aWxsIHBhc3MgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGRhdGUgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0uQ3JlYXRlZEF0ICYmIGN1cnJlbnRJdGVtLkNyZWF0ZWRBdCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQXQgPSB1dGlscy5jbG9uZURhdGUoY3VycmVudEl0ZW0uQ3JlYXRlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0uTW9kaWZpZWRBdCAmJiBjdXJyZW50SXRlbS5Nb2RpZmllZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQXQgPSB1dGlscy5jbG9uZURhdGUoY3VycmVudEl0ZW0uTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShpdGVtVG9DcmVhdGUuQ3JlYXRlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRCeSA9IGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQnkgfHwgc2VsZi5ldmVybGl2ZS5zZXR1cC5wcmluY2lwYWxJZCB8fCBjb25zdGFudHMuZ3VpZEVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuTW9kaWZpZWRCeSA9IGl0ZW1Ub0NyZWF0ZS5Nb2RpZmllZEJ5IHx8IGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ1VzZXJzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk93bmVyID0gaXRlbVRvQ3JlYXRlLl9pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5Pd25lciA9IGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQnkgfHwgY29uc3RhbnRzLmd1aWRFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0SXRlbShjb2xsZWN0aW9uLCBfLmV4dGVuZCh7fSwgaXRlbVRvQ3JlYXRlKSwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVRvQ3JlYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoY29udGVudFR5cGUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoY29udGVudFR5cGUpICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtcyA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlSWRUcmFuc2Zvcm0oY3JlYXRlZEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZWRJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5VXBkYXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAob3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uLCBpdGVtVG9VcGRhdGUsIGNvbGxlY3Rpb24sIGlzU3luYykge1xyXG4gICAgICAgICAgICB2YXIgZGJPcGVyYXRvcnMgPSB1dGlscy5nZXREYk9wZXJhdG9ycyhvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb24sIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgaGFzRGJPcGVyYXRvciA9IGRiT3BlcmF0b3JzLmxlbmd0aCAhPT0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICBpZiAoaGFzRGJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbiA9IG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNldDogb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVFeHByZXNzaW9uRm9yVXNlciA9IHtcclxuICAgICAgICAgICAgICAgIE1vZGlmaWVkQnk6IHRoaXMuZXZlcmxpdmUuc2V0dXAucHJpbmNpcGFsSWQgfHwgY29uc3RhbnRzLmd1aWRFbXB0eVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uLiRzZXQgPSBfLmV4dGVuZCh1cGRhdGVFeHByZXNzaW9uRm9yVXNlciwgdXBkYXRlRXhwcmVzc2lvbi4kc2V0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24uJHNldC5Nb2RpZmllZEF0ID0gdXRpbHMuY2xvbmVEYXRlKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbi5Nb2RpZmllZEF0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbW9uZ29RdWVyeShpdGVtVG9VcGRhdGUsIHt9LCB1cGRhdGVFeHByZXNzaW9uLCB7c3RyaWN0OiB0cnVlfSk7IC8vIFNldHRpbmcgc3RyaWN0IHRvIHRydWUgc28gb25seSBleGFjdCBtYXRjaGVzIHdvdWxkIGJlIHVwZGF0ZWRcclxuXHJcbiAgICAgICAgICAgIGl0ZW1Ub1VwZGF0ZS5faWQgPSBpdGVtVG9VcGRhdGUuX2lkIHx8IHVwZGF0ZUV4cHJlc3Npb24uX2lkIHx8IHVwZGF0ZUV4cHJlc3Npb24uSWQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtVG9VcGRhdGUuSWQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub1VwZGF0ZVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVtKGNvbGxlY3Rpb24sIGl0ZW1Ub1VwZGF0ZSwgbmV3U3RhdGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF91cGRhdGVJdGVtczogZnVuY3Rpb24gKGRhdGFRdWVyeSwgdXBkYXRlRXhwcmVzc2lvbiwgZmlsdGVyLCBpc1N5bmMsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9nZXRDb2xsZWN0aW9uKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUl0ZW1zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zICYmIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9VcGRhdGUgPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FwcGx5VXBkYXRlT3BlcmF0aW9uKHVwZGF0ZUV4cHJlc3Npb24sIGl0ZW1Ub1VwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbXMgPSBbaXRlbVRvVXBkYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtcyA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRvVXBkYXRlID0gdXBkYXRlSXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUV4aXN0cyA9ICEhc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBpdGVtVG9VcGRhdGUuX2lkLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUV4aXN0cyAmJiAhaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FwcGx5VXBkYXRlT3BlcmF0aW9uKHVwZGF0ZUV4cHJlc3Npb24sIGl0ZW1Ub1VwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlcnNpc3REYXRhKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRJdGVtQ291bnQgPSB1cGRhdGVJdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRBdFJlc3VsdCA9IHVwZGF0ZWRJdGVtQ291bnQgPyB1cGRhdGVJdGVtc1swXS5Nb2RpZmllZEF0IDogbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGlmaWVkQXQ6IG1vZGlmaWVkQXRSZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB1cGRhdGVkSXRlbUNvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jbGVhckl0ZW06IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVtKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjb2xsZWN0aW9uW2l0ZW0uX2lkXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVtb3ZlSXRlbXM6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlciwgaXNTeW5jLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtc1RvUmVtb3ZlID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXNUb1JlbW92ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRvUmVtb3ZlID0gaXRlbXNUb1JlbW92ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvUmVtb3ZlLl9pZCA9IGl0ZW1Ub1JlbW92ZS5faWQgfHwgaXRlbVRvUmVtb3ZlLklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUV4aXN0cyA9ICEhc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBpdGVtVG9SZW1vdmUuX2lkLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtRXhpc3RzICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoJ0Nhbm5vdCBkZWxldGUgaXRlbSAtIGl0ZW0gd2l0aCBpZCAnICsgaXRlbVRvUmVtb3ZlLl9pZCArICcgZG9lcyBub3QgZXhpc3QuJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRnJvbU1lbW9yeSA9IGl0ZW1Ub1JlbW92ZVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkIHx8IGlzU3luYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUZyb21NZW1vcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NsZWFySXRlbShjb2xsZWN0aW9uLCBpdGVtVG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0SXRlbShjb2xsZWN0aW9uLCBpdGVtVG9SZW1vdmUsIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBzZWxmLl90cmFuc2Zvcm1PZmZsaW5lUmVzdWx0KGl0ZW1zVG9SZW1vdmUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5VHJhbnNmb3JtYXRpb25zOiBmdW5jdGlvbiAodHJhbnNmb3JtZWRSZXN1bHQsIHRyYW5zZm9ybWF0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godHJhbnNmb3JtYXRpb25zLCBmdW5jdGlvbiAodHJhbnNmb3JtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQubWFwKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdFtrZXldID0gdHJhbnNmb3JtYXRpb24odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2godHJhbnNmb3JtYXRpb25zLCBmdW5jdGlvbiAodHJhbnNmb3JtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQgPSB0cmFuc2Zvcm1hdGlvbih0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdHJhbnNmb3JtT2ZmbGluZVJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdFNldCwgY291bnQsIGRhdGFRdWVyeSwgYWRkaXRpb25hbFRyYW5zZm9ybWF0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFNldCxcclxuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCB8fCAocmVzdWx0U2V0IHx8IFtdKS5sZW5ndGhcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoY291bnQgIT09IHVuZGVmaW5lZCAmJiBjb3VudCAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRTZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudCA9IGNvdW50IHx8IHJlc3VsdFNldC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZU1hcmtlcnNUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVDb3VudCA9IGRhdGFRdWVyeS5nZXRIZWFkZXIoSGVhZGVycy5pbmNsdWRlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDb3VudCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHJhbnNmb3JtZWRSZXN1bHQuY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZUZpZWxkRXhwcmVzc2lvbiA9IGRhdGFRdWVyeS5nZXRIZWFkZXIoSGVhZGVycy5zaW5nbGVGaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZUZpZWxkRXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnNpbmdsZUZpZWxkVHJhbnNmb3JtLmJpbmQodGhpcywgc2luZ2xlRmllbGRFeHByZXNzaW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsVHJhbnNmb3JtYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMgPSB0cmFuc2Zvcm1hdGlvbnMuY29uY2F0KGFkZGl0aW9uYWxUcmFuc2Zvcm1hdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybWF0aW9ucyh0cmFuc2Zvcm1lZFJlc3VsdCwgdHJhbnNmb3JtYXRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhbnNmb3JtZWRSZXN1bHQuY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdHJhbnNmb3JtUGVyc2lzdGVkRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBjb250ZW50VHlwZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUZpZWxkcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnVXNlcnMnKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1GaWVsZHMgPSB0cmFuc2Zvcm1GaWVsZHMuY29uY2F0KFsnUGFzc3dvcmQnLCAnUXVlc3Rpb25JZCcsICdTZWNyZXRBbnN3ZXInXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1GaWVsZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVEYXRhLCBmdW5jdGlvbiAoY29udGVudFR5cGVPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZUZpZWxkc1RyYW5zZm9ybShjb250ZW50VHlwZU9iamVjdCwgdHJhbnNmb3JtRmllbGRzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gT2ZmbGluZU1vZHVsZTtcclxufSkoKTsiLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBwZXJzaXN0ZXJzTW9kdWxlID0gcmVxdWlyZSgnLi9vZmZsaW5lUGVyc2lzdGVycycpO1xyXG52YXIgTG9jYWxTdG9yYWdlUGVyc2lzdGVyID0gcGVyc2lzdGVyc01vZHVsZS5Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXI7XHJcbnZhciBGaWxlU3lzdGVtUGVyc2lzdGVyID0gcGVyc2lzdGVyc01vZHVsZS5GaWxlU3lzdGVtUGVyc2lzdGVyO1xyXG52YXIgT2ZmbGluZVN0b3JhZ2VNb2R1bGUgPSByZXF1aXJlKCcuL09mZmxpbmVTdG9yYWdlTW9kdWxlJyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBpc05hdGl2ZVNjcmlwdCA9IHJlcXVpcmUoJy4uL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOYXRpdmVTY3JpcHQ7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIENyeXB0b2dyYXBoaWNQcm92aWRlciA9IHJlcXVpcmUoJy4uL2VuY3J5cHRpb24vQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyJyk7XHJcblxyXG52YXIgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyA9IHtcclxuICAgIGF1dG9TeW5jOiB0cnVlLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIGNvbmZsaWN0czoge1xyXG4gICAgICAgIHN0cmF0ZWd5OiBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2lucyxcclxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogbnVsbFxyXG4gICAgfSxcclxuICAgIG9mZmxpbmU6IGZhbHNlLFxyXG4gICAgc3RvcmFnZToge1xyXG4gICAgICAgIG5hbWU6ICcnLFxyXG4gICAgICAgIHByb3ZpZGVyOiBpc05hdGl2ZVNjcmlwdCA/IGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuRmlsZVN5c3RlbSA6IGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuTG9jYWxTdG9yYWdlLFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsLFxyXG4gICAgICAgIHN0b3JhZ2VQYXRoOiBjb25zdGFudHMuRGVmYXVsdFN0b3JhZ2VQYXRoXHJcbiAgICB9LFxyXG4gICAgdHlwZVNldHRpbmdzOiB7fSxcclxuICAgIGVuY3J5cHRpb246IHtcclxuICAgICAgICBwcm92aWRlcjogY29uc3RhbnRzLkVuY3J5cHRpb25Qcm92aWRlci5EZWZhdWx0LFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsLFxyXG4gICAgICAgIGtleTogJydcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ2llcyA9IHt9O1xyXG5cclxuICAgIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWdpZXNbY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnNdID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGxvY2FsLCBzZXJ2ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKGxvY2FsKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ2llc1tjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luc10gPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgbG9jYWwsIHNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoc2VydmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXRTdG9yYWdlUGVyc2lzdGVyID0gZnVuY3Rpb24gaW5pdFN0b3JhZ2VQZXJzaXN0ZXIob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBwZXJzaXN0ZXI7XHJcbiAgICAgICAgdmFyIHN0b3JhZ2VQcm92aWRlciA9IG9wdGlvbnMuc3RvcmFnZS5wcm92aWRlcjtcclxuICAgICAgICB2YXIgc3RvcmFnZVByb3ZpZGVySW1wbGVtZW50YXRpb24gPSBvcHRpb25zLnN0b3JhZ2UuaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBvcHRpb25zLnN0b3JhZ2UubmFtZSB8fCAnZXZlcmxpdmVPZmZsaW5lU3RvcmFnZV8nICsgdGhpcy5zZXR1cC5hcGlLZXk7XHJcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc3RvcmFnZVByb3ZpZGVySW1wbGVtZW50YXRpb24pICYmIHN0b3JhZ2VQcm92aWRlciA9PT0gY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5DdXN0b20pIHtcclxuICAgICAgICAgICAgcGVyc2lzdGVyID0gc3RvcmFnZVByb3ZpZGVySW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzdG9yYWdlUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5Mb2NhbFN0b3JhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVyID0gbmV3IExvY2FsU3RvcmFnZVBlcnNpc3RlcihzdG9yYWdlS2V5LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5GaWxlU3lzdGVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlciA9IG5ldyBGaWxlU3lzdGVtUGVyc2lzdGVyKHN0b3JhZ2VLZXksIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkN1c3RvbTpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQ3VzdG9tIHN0b3JhZ2UgcHJvdmlkZXIgcmVxdWlyZXMgYW4gaW1wbGVtZW50YXRpb24gb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbnN1cHBvcnRlZCBzdG9yYWdlIHR5cGUgJyArIHN0b3JhZ2VQcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMuc3RvcmFnZS5pbXBsZW1lbnRhdGlvbiA9IHBlcnNpc3RlcjtcclxuICAgICAgICByZXR1cm4gcGVyc2lzdGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaW5pdEVuY3J5cHRpb25Qcm92aWRlciA9IGZ1bmN0aW9uIGluaXRFbmNyeXB0aW9uUHJvdmlkZXIob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBlbmNyeXB0b3I7XHJcbiAgICAgICAgdmFyIGVuY3J5cHRpb25Qcm92aWRlciA9IG9wdGlvbnMuZW5jcnlwdGlvbi5wcm92aWRlcjtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvbkltcGxlbWVudGF0aW9uID0gb3B0aW9ucy5lbmNyeXB0aW9uLmltcGxlbWVudGF0aW9uO1xyXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGVuY3J5cHRpb25JbXBsZW1lbnRhdGlvbikgJiYgZW5jcnlwdGlvblByb3ZpZGVyID09PSBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkN1c3RvbSkge1xyXG4gICAgICAgICAgICBlbmNyeXB0b3IgPSBlbmNyeXB0aW9uSW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChlbmNyeXB0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkVuY3J5cHRpb25Qcm92aWRlci5EZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRvciA9IG5ldyBDcnlwdG9ncmFwaGljUHJvdmlkZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5FbmNyeXB0aW9uUHJvdmlkZXIuQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDdXN0b20gZW5jcnlwdGlvbiBwcm92aWRlciByZXF1aXJlcyBhbiBpbXBsZW1lbnRhdGlvbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gcHJvdmlkZXIgJyArIGVuY3J5cHRpb25Qcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMuZW5jcnlwdGlvbi5pbXBsZW1lbnRhdGlvbiA9IGVuY3J5cHRvcjtcclxuICAgICAgICByZXR1cm4gZW5jcnlwdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZSA9IGZ1bmN0aW9uIGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUoc3RvcmFnZU9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucztcclxuICAgICAgICBpZiAoc3RvcmFnZU9wdGlvbnMgPT09IHRydWUpIHsgLy8gZXhwbGljaXQgY2hlY2sgZm9yIHNob3J0aGFuZCBpbml0aWFsaXphdGlvblxyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHN0b3JhZ2VPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucywgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuc3RvcmFnZSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucy5zdG9yYWdlKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5lbmNyeXB0aW9uID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucy5lbmNyeXB0aW9uLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLmVuY3J5cHRpb24pO1xyXG4gICAgICAgICAgICBvcHRpb25zLmNvbmZsaWN0cyA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuY29uZmxpY3RzLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLmNvbmZsaWN0cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIGRlZmF1bHRPZmZsaW5lU3RvcmFnZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICBvcHRpb25zLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwZXJzaXN0ZXIgPSBpbml0U3RvcmFnZVBlcnNpc3Rlci5jYWxsKHRoaXMsIG9wdGlvbnMsIHN0b3JhZ2VPcHRpb25zKTtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gaW5pdEVuY3J5cHRpb25Qcm92aWRlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IE9mZmxpbmVTdG9yYWdlTW9kdWxlKHRoaXMsIG9wdGlvbnMsIHBlcnNpc3RlciwgZW5jcnlwdGlvblByb3ZpZGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXRPZmZsaW5lU3RvcmFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZSA9IGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUuY2FsbCh0aGlzLCBvcHRpb25zLm9mZmxpbmVTdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbml0T2ZmbGluZVN0b3JhZ2U6IGluaXRPZmZsaW5lU3RvcmFnZVxyXG4gICAgfVxyXG59KCkpOyIsInZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxudmFyIGlzTmF0aXZlU2NyaXB0ID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XHJcbnZhciBpc0NvcmRvdmEgPSBwbGF0Zm9ybS5pc0NvcmRvdmE7XHJcbnZhciByc3ZwID0gY29tbW9uLnJzdnA7XHJcbnZhciBwYXJzZVV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxzJykucGFyc2VVdGlsaXRpZXM7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG52YXIgTG9jYWxTdG9yZSA9IHJlcXVpcmUoJy4uL0xvY2FsU3RvcmUnKTtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG5cclxuLyoqXHJcbiAqIENhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczoge0BsaW5rIExvY2FsU3RvcmFnZVBlcnNpc3Rlcn0sXHJcbiAqIHtAbGluayBGaWxlU3lzdGVtUGVyc2lzdGVyfSBvciBhIGN1c3RvbSBiYXNlZCBvbiB7QGxpbmsgQmFzZVBlcnNpc3Rlcn1cclxuICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGVcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXIge0Jhc2VQZXJzaXN0ZXJ9IGxvY2FsXHJcbiAqL1xyXG5cclxudmFyIEJhc2VQZXJzaXN0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEJhc2VQZXJzaXN0ZXJcclxuICAgICAqIEBjbGFzc2Rlc2MgQW4gYWJzdHJhY3Rpb24gbGF5ZXIgZm9yIGFsbCBwZXJzaXN0ZXJzLiBFdmVyeSBwZXJzaXN0ZXIgY2FuIHdyaXRlL3JlYWRcclxuICAgICAqIGRhdGEgZnJvbSBhIHNwZWNpZmljIHBsYWNlLiBUaGUgZGF0YSBpcyBzYXZlZCBhcyBrZXktdmFsdWUgcGFpcnMgd2hlcmUgdGhlIGtleXMgYXJlXHJcbiAgICAgKiBjb250ZW50IHR5cGVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCYXNlUGVyc2lzdGVyKGtleSwgc2RrKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5zZGsgPSBzZGs7XHJcbiAgICB9XHJcblxyXG4gICAgQmFzZVBlcnNpc3Rlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgdGhlIHNhdmVkIGRhdGEuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRBbGxEYXRhXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gS2V5cyBhcmUgdGhlIGNvbnRlbnQgdHlwZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBbGxEYXRhOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgZ2V0QWxsRGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzYXZlZCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0RGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCB0eXBlIGZvciB3aGljaCB0byByZXRyZWl2ZSB0aGUgZGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2tcclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXRyaWV2ZWQgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgZ2V0RGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlcyBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2F2ZURhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgZm9yIHdoaWNoIHRvIHNhdmUgdGhlIGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29udGVudCB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFja1xyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2F2ZURhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2Qgc2F2ZURhdGEgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBwZXJzaXN0ZWQgZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250ZW50IHR5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgZm9yIHdoaWNoIHRvIGNsZWFyIHRoZSBkYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFja1xyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVyZ2U6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgY2xlYXIgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBwZXJzaXN0ZWQgZGF0YSBmb3IgYSBjb250ZW50IHR5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyQWxsXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVyZ2VBbGw6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBjbGVhckFsbCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0S2V5OiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ICsgJ18nICsgY29udGVudFR5cGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldEVuY3J5cHRpb25Qcm92aWRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZGsub2ZmbGluZVN0b3JhZ2UuX2dldEVuY3J5cHRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEJhc2VQZXJzaXN0ZXI7XHJcbn0oKSk7XHJcblxyXG52YXIgTG9jYWxTdG9yYWdlUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIExvY2FsU3RvcmFnZVBlcnNpc3RlclxyXG4gICAgICogQGV4dGVuZHMgQmFzZVBlcnNpc3RlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIoa2V5LCBzZGspIHtcclxuICAgICAgICBCYXNlUGVyc2lzdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbC5pbmhlcml0cyhMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsIEJhc2VQZXJzaXN0ZXIpO1xyXG5cclxuICAgIC8vV2UgbmVlZCB0byBvZmZsaW5lIHN0b3JhZ2UgcGF0aCBmcm9tIHRoZSBzZGsub2ZmbGluZVN0b3JhZ2Uuc2V0dXAgaW4gbm9kZWpzXHJcbiAgICAvL2J1dCBpdCBpcyBub3QgYXZhaWxhYmxlIHNpbmNlIGl0IGlzIGNyZWF0ZWQgYWZ0ZXIgdGhlIHBlcnNpc3RlcnMgYXJlIGluaXRpYWxpemVkXHJcbiAgICAvL3RoYXQgaXMgd2h5IHdlIHBvc3BvbmUgdGhlIGxvY2Fsc3RvcmUgaW5pdGlhbGl6YXRpb24gZm9yIHRoZSBmaXJzdCB0aW1lIGl0IGlzIG5lZWRlZFxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fZW5zdXJlTG9jYWxTdG9yZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RvcmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdG9yZSA9IG5ldyBMb2NhbFN0b3JlKHRoaXMuc2RrKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0QWxsRGF0YSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgY29udGVudFR5cGVzID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzKCk7XHJcbiAgICAgICAgdmFyIGFsbENvbGxlY3Rpb25zID0ge307XHJcbiAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlcywgZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGFsbENvbGxlY3Rpb25zW2NvbnRlbnRUeXBlXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5nZXREYXRhKGNvbnRlbnRUeXBlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcnN2cC5oYXNoKGFsbENvbGxlY3Rpb25zKS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmVkSXRlbSA9IHRoaXMuX2dldEl0ZW0oa2V5KSB8fCAne30nO1xyXG4gICAgICAgICAgICB2YXIgcmV2aXZlciA9IHBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcclxuICAgICAgICAgICAgdmFyIHN0b3JlZEl0ZW1PYmplY3QgPSBKU09OLnBhcnNlKHN0b3JlZEl0ZW0sIHJldml2ZXIpO1xyXG4gICAgICAgICAgICBzdWNjZXNzKHN0b3JlZEl0ZW1PYmplY3QpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLnNhdmVEYXRhID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVLZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVtKGNvbnRlbnRUeXBlS2V5LCBjb2xsZWN0aW9uc1N0cmluZyk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUucHVyZ2VBbGwgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVzID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzKCk7XHJcbiAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZXMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlS2V5ID0gc2VsZi5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVLZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXNLZXkgPSB0aGlzLl9nZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVzS2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVMb2NhbFN0b3JlKCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbG9jYWxTdG9yZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgdmFyIGVuY3J5cHRpb25Qcm92aWRlciA9IHRoaXMuX2dldEVuY3J5cHRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgIHJldHVybiBlbmNyeXB0aW9uUHJvdmlkZXIuZGVjcnlwdCh2YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX3NldEl0ZW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxvY2FsU3RvcmUoKTtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0RW5jcnlwdGlvblByb3ZpZGVyKCk7XHJcbiAgICAgICAgdmFsdWUgPSBlbmNyeXB0aW9uUHJvdmlkZXIuZW5jcnlwdCh2YWx1ZSk7XHJcblx0XHRyZXR1cm4gdGhpcy5fbG9jYWxTdG9yZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVMb2NhbFN0b3JlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmUucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRLZXkgPSBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVMb2NhbFN0b3JlKCk7XHJcbiAgICAgICAgdGhpcy5fYWRkVHlwZVRvQ29sbGVjdGlvbnNDYWNoZShjb250ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5zdXBlcl8ucHJvdG90eXBlLl9nZXRLZXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbktleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXkgKyAnQENvbnRlbnRUeXBlcyc7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29sbGVjdGlvbktleSA9IHRoaXMuX2dldENvbnRlbnRUeXBlc0NvbGxlY3Rpb25LZXkoKTtcclxuICAgICAgICB2YXIgbG9jYWxTdG9yYWdlU3RyaW5nID0gdGhpcy5fZ2V0SXRlbShjb2xsZWN0aW9uS2V5KTtcclxuXHJcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9zZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgY29sbGVjdGlvbktleSA9IHRoaXMuX2dldENvbnRlbnRUeXBlc0NvbGxlY3Rpb25LZXkoKTtcclxuICAgICAgICB0aGlzLl9zZXRJdGVtKGNvbGxlY3Rpb25LZXksIEpTT04uc3RyaW5naWZ5KGNvbGxlY3Rpb24pKTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fYWRkVHlwZVRvQ29sbGVjdGlvbnNDYWNoZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgIHZhciBjb250ZW50VHlwZXNDb2xsZWN0aW9uID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzKCk7XHJcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGNvbnRlbnRUeXBlc0NvbGxlY3Rpb24sIHR5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICBjb250ZW50VHlwZXNDb2xsZWN0aW9uLnB1c2godHlwZU5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uKGNvbnRlbnRUeXBlc0NvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIExvY2FsU3RvcmFnZVBlcnNpc3RlcjtcclxufSgpKTtcclxuXHJcbnZhciBGaWxlU3lzdGVtUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEZpbGVTeXN0ZW1QZXJzaXN0ZXJcclxuICAgICAqIEBleHRlbmRzIEJhc2VQZXJzaXN0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRmlsZVN5c3RlbVBlcnNpc3RlcihrZXksIHNkaykge1xyXG4gICAgICAgIEJhc2VQZXJzaXN0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc0NvcmRvdmEgJiYgIWlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdGaWxlU3lzdGVtUGVyc2lzdGVyIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCBDb3Jkb3ZhIGFuZCBOYXRpdmVTY3JpcHQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXkgPSAnQENvbnRlbnRUeXBlcyc7XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbC5pbmhlcml0cyhGaWxlU3lzdGVtUGVyc2lzdGVyLCBCYXNlUGVyc2lzdGVyKTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5nZXRBbGxEYXRhID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9nZXRDb250ZW50VHlwZXNNZXRhZGF0YShmdW5jdGlvbiAoY29udGVudFR5cGVzKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRlbnRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzW2NvbnRlbnRUeXBlXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0RGF0YShjb250ZW50VHlwZSwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJzdnAuaGFzaChwcm9taXNlcykudGhlbihzdWNjZXNzLCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICB0aGlzLl9nZXRGaWxlRnVsbChjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICBzZWxmLl9yZWFkRmlsZUNvbnRlbnQoZmlsZUVudHJ5LCBzdWNjZXNzLCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0sIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuc2F2ZURhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuX2dldEZpbGVGdWxsKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3dyaXRlRmlsZUNvbnRlbnQoZmlsZUVudHJ5LCBkYXRhU3RyaW5nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zYXZlQ29udGVudFR5cGVzTWV0YWRhdGEoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUucHVyZ2UgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICB0aGlzLl9nZXRGaWxlRnVsbChjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICBzZWxmLl9yZW1vdmVGaWxlKGZpbGVFbnRyeSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlQWxsID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlRGF0YURpcmVjdG9yeShmdW5jdGlvbiAoZGF0YURpckVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlbW92ZUZpbGVzRGlyZWN0b3J5KGRhdGFEaXJFbnRyeSwgc3VjY2VzcywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fZW5zdXJlUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoID0gdGhpcy5zZGsub2ZmbGluZVN0b3JhZ2Uuc2V0dXAuc3RvcmFnZS5zdG9yYWdlUGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kYXRhRGlyZWN0b3J5UGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29yZG92YSAmJiAhY29yZG92YS5maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1lvdSBuZWVkIHRvIGVuYWJsZSB0aGUgY29yZG92YSBmaWxlIHBsdWdpbiB0byB1c2UgZmlsZSBvZmZsaW5lIHN0b3JhZ2UuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCB0aGUgXCJkZXZpY2VSZWFkeVwiIGV2ZW50IGhhcyBmaXJlZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFEaXJlY3RvcnlQYXRoID0gY29yZG92YS5maWxlLmRhdGFEaXJlY3Rvcnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnMgPSByZXF1aXJlKCdmaWxlLXN5c3RlbScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhRGlyZWN0b3J5UGF0aCA9IHRoaXMuZnMua25vd25Gb2xkZXJzLmRvY3VtZW50cygpLnBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB0aGlzLmdldERhdGEodGhpcy5jb250ZW50VHlwZXNTdG9yZUtleSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fc2F2ZUNvbnRlbnRUeXBlc01ldGFkYXRhID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzTWV0YWRhdGEoZnVuY3Rpb24gKHNhdmVkQ29udGVudFR5cGVzKSB7XHJcbiAgICAgICAgICAgIHNhdmVkQ29udGVudFR5cGVzW2NvbnRlbnRUeXBlXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuX2dldEZpbGVGdWxsKHNlbGYuY29udGVudFR5cGVzU3RvcmVLZXksIGZ1bmN0aW9uIChjb250ZW50VHlwZXNGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl93cml0ZUZpbGVDb250ZW50KGNvbnRlbnRUeXBlc0ZpbGUsIEpTT04uc3RyaW5naWZ5KHNhdmVkQ29udGVudFR5cGVzKSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRGaWxlRnVsbCA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUZpbGVzRGlyZWN0b3J5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSBzZWxmLl9nZXRGaWxlUGF0aChjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHNlbGYuX2dldEZpbGVGcm9tU3lzdGVtKHBhdGgsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9yZW1vdmVGaWxlc0RpcmVjdG9yeSA9IGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICBkaXJlY3RvcnlFbnRyeS5nZXREaXJlY3RvcnkodGhpcy5maWxlc0RpcmVjdG9yeVBhdGgsIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZTogZmFsc2VcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGZpbGVzRGlyRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVzRGlyRW50cnkucmVtb3ZlUmVjdXJzaXZlbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpXHJcbiAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsZXNEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgICAgICB2YXIgZmlsZXNEaXJlY3RvcnkgPSB0aGlzLmZzLkZvbGRlci5mcm9tUGF0aChmaWxlc0RpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgICAgICBmaWxlc0RpcmVjdG9yeS5yZW1vdmUoKS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9yZW1vdmVGaWxlID0gZnVuY3Rpb24gKGZpbGVFbnRyeSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkucmVtb3ZlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LnJlbW92ZSgpLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlYWRGaWxlQ29udGVudCA9IGZ1bmN0aW9uIChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlUHJvcGVydGllcygpO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcmVhZFRleHRTdWNjZXNzID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGVuY3J5cHRpb25Qcm92aWRlciA9IHRoYXQuX2dldEVuY3J5cHRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb250ZW50ID0gZW5jcnlwdGlvblByb3ZpZGVyLmRlY3J5cHQoY29udGVudCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV2aXZlciA9IHBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdE9iamVjdCA9IEpTT04ucGFyc2UoY29udGVudCB8fCAne30nLCByZXZpdmVyKTtcclxuICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHRPYmplY3QpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChpc0NvcmRvdmEpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkVGV4dFN1Y2Nlc3ModGhpcy5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LnJlYWRUZXh0KCkudGhlbihyZWFkVGV4dFN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl93cml0ZUZpbGVDb250ZW50ID0gZnVuY3Rpb24gKGZpbGVFbnRyeSwgY29udGVudCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdmFyIGVuY3J5cHRpb25Qcm92aWRlciA9IHRoaXMuX2dldEVuY3J5cHRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnRlbnQgPSBlbmNyeXB0aW9uUHJvdmlkZXIuZW5jcnlwdChjb250ZW50KTtcclxuXHJcbiAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uIChmaWxlV3JpdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLm9ud3JpdGVlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLm9uZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIud3JpdGUoY29udGVudCk7XHJcbiAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS53cml0ZVRleHQoY29udGVudCkudGhlbihzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fZ2V0RmlsZUZyb21TeXN0ZW0gPSBmdW5jdGlvbiAocGF0aCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZURhdGFEaXJlY3RvcnkoZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvcmRvdmEpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldEZpbGUocGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxGaWxlUGF0aCA9IHRoaXMuZnMucGF0aC5qb2luKGRpcmVjdG9yeUVudHJ5LnBhdGgsIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gdGhpcy5mcy5GaWxlLmZyb21QYXRoKGZ1bGxGaWxlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRGaWxlUGF0aCA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc0RpcmVjdG9yeVBhdGggKyB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fcmVzb2x2ZURhdGFEaXJlY3RvcnkgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICByZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMKHRoaXMuZGF0YURpcmVjdG9yeVBhdGgsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhRGlyZWN0b3J5ID0gdGhpcy5mcy5Gb2xkZXIuZnJvbVBhdGgodGhpcy5kYXRhRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YURpcmVjdG9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fZW5zdXJlRmlsZXNEaXJlY3RvcnkgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdmFyIGZpbGVzRGlyZWN0b3J5UGF0aCA9IHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVEYXRhRGlyZWN0b3J5KGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xyXG4gICAgICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RvcnlFbnRyeS5nZXREaXJlY3RvcnkoZmlsZXNEaXJlY3RvcnlQYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZURpcmVjdG9yeVBhdGggPSB0aGlzLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCBmaWxlc0RpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnMuRm9sZGVyLmZyb21QYXRoKGZpbGVEaXJlY3RvcnlQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCFpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzTWFwID0ge307XHJcbiAgICAgICAgICAgIF8uZWFjaChPYmplY3Qua2V5cyhGaWxlRXJyb3IpLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yc01hcFtGaWxlRXJyb3JbZXJyb3JdXSA9IGVycm9yO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gZXJyb3JzTWFwW2UuY29kZV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEZpbGVTeXN0ZW1QZXJzaXN0ZXI7XHJcbn0oKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEJhc2VQZXJzaXN0ZXI6IEJhc2VQZXJzaXN0ZXIsXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXI6IExvY2FsU3RvcmFnZVBlcnNpc3RlcixcclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXI6IEZpbGVTeXN0ZW1QZXJzaXN0ZXJcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVNYXJrZXIgPSBjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXI7XHJcblxyXG52YXIgdHJhdmVyc2VBbmRBcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3BlcmF0aW9uLCBhZGRpdGlvbmFsT3B0aW9ucykge1xyXG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gXy5tYXAodmFsdWUsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24oaXRlbSwgYWRkaXRpb25hbE9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uKHZhbHVlLCBhZGRpdGlvbmFsT3B0aW9ucyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgaWRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2lkICYmICF2YWx1ZS5JZCkge1xyXG4gICAgICAgIHZhbHVlLklkID0gdmFsdWUuX2lkO1xyXG4gICAgICAgIGRlbGV0ZSB2YWx1ZS5faWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIHJlbW92ZUlkVHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRzKSB7XHJcbiAgICB2YXIgdmVyaWZ5U3RhdGVDcmVhdGVkID0gb3B0cy52ZXJpZnlTdGF0ZUNyZWF0ZWQ7XHJcbiAgICB2YXIgc2hvdWxkTW9kaWZ5T2JqZWN0ID0gdmVyaWZ5U3RhdGVDcmVhdGVkID8gdmFsdWVbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgOiB0cnVlO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgKHZhbHVlLl9pZCB8fCB2YWx1ZS5JZCkgJiYgc2hvdWxkTW9kaWZ5T2JqZWN0KSB7XHJcbiAgICAgICAgZGVsZXRlIHZhbHVlLl9pZDtcclxuICAgICAgICBkZWxldGUgdmFsdWUuSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIHJlbW92ZU1hcmtlclRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgZGVsZXRlIHZhbHVlW29mZmxpbmVJdGVtU3RhdGVNYXJrZXJdO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMgPSB7XHJcbiAgICByZW1vdmVJZFRyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCB2ZXJpZnlTdGF0ZUNyZWF0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRBcHBseSh2YWx1ZSwgcmVtb3ZlSWRUcmFuc2Zvcm0sIHt2ZXJpZnlTdGF0ZUNyZWF0ZWQ6IHZlcmlmeVN0YXRlQ3JlYXRlZH0pO1xyXG4gICAgfSxcclxuICAgIGlkVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRBcHBseSh2YWx1ZSwgaWRUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICB9LFxyXG4gICAgc2luZ2xlRmllbGRUcmFuc2Zvcm06IGZ1bmN0aW9uIChzaW5nbGVGaWVsZEV4cHJlc3Npb24sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3NpbmdsZUZpZWxkRXhwcmVzc2lvbl07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQ6IGZ1bmN0aW9uIChmaWx0ZXJPYmopIHtcclxuICAgICAgICBpZiAoZmlsdGVyT2JqICYmIGZpbHRlck9iai5JZCkge1xyXG4gICAgICAgICAgICBmaWx0ZXJPYmouX2lkID0gZmlsdGVyT2JqLklkO1xyXG4gICAgICAgICAgICBkZWxldGUgZmlsdGVyT2JqLklkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmaWx0ZXJPYmopIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlck9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdE1lbWJlciA9IGZpbHRlck9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0TWVtYmVyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMudHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZChvYmplY3RNZW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZU1hcmtlcnNUcmFuc2Zvcm06IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZEFwcGx5KHZhbHVlLCByZW1vdmVNYXJrZXJUcmFuc2Zvcm0pO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUZpZWxkc1RyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCBmaWVsZHMpIHtcclxuICAgICAgICBfLmVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2ZpZWxkXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zOyIsInZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFRPRE86IFtvZmZsaW5lXSBVcGRhdGUgdGhlIHN0cnVjdHVyZSAtIGZpbHRlciBmaWVsZCBjYW4gYmUgcmVmYWN0b3JlZCBmb3IgZXhhbXBsZSBhbmQgYSBza2lwL2xpbWl0L3NvcnQgcHJvcGVydHkgY2FuIGJlIGFkZGVkXHJcbiAgICB2YXIgRGF0YVF1ZXJ5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb25maWcuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBjb25maWcuZmlsdGVyO1xyXG4gICAgICAgIHRoaXMub25TdWNjZXNzID0gY29uZmlnLm9uU3VjY2VzcztcclxuICAgICAgICB0aGlzLm9uRXJyb3IgPSBjb25maWcub25FcnJvcjtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IGNvbmZpZy5vcGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5wYXJzZSA9IGNvbmZpZy5wYXJzZTtcclxuICAgICAgICB0aGlzLmFkZGl0aW9uYWxPcHRpb25zID0gY29uZmlnLmFkZGl0aW9uYWxPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGNvbmZpZy5kYXRhO1xyXG4gICAgICAgIHRoaXMudXNlT2ZmbGluZSA9IGNvbmZpZy51c2VPZmZsaW5lO1xyXG4gICAgICAgIHRoaXMuYXBwbHlPZmZsaW5lID0gY29uZmlnLmFwcGx5T2ZmbGluZTtcclxuICAgICAgICB0aGlzLm5vUmV0cnkgPSBjb25maWcubm9SZXRyeTsgLy9yZXRyeSB3aWxsIGJlIGRvbmUgYnkgZGVmYXVsdCwgd2hlbiBhIHJlcXVlc3QgZmFpbHMgYmVjYXVzZSBvZiBleHBpcmVkIHRva2VuLCBvbmNlIHRoZSBhdXRoZW50aWNhdGlvbi5jb21wbGV0ZUF1dGhlbnRpY2F0aW9uIGluIHNkayBpcyBjYWxsZWQuXHJcbiAgICAgICAgdGhpcy5za2lwQXV0aCA9IGNvbmZpZy5za2lwQXV0aDsgLy9pZiBzZXQgdG8gdHJ1ZSwgdGhlIHNkayB3aWxsIG5vdCByZXF1aXJlIGF1dGhvcml6YXRpb24gaWYgdGhlIGRhdGEgcXVlcnkgZmFpbHMgYmVjYXVzZSBvZiBleHBpcmVkIHRva2VuLiBVc2VkIGludGVybmFsbHkgZm9yIHZhcmlvdXMgbG9naW4gbWV0aG9kcy5cclxuICAgICAgICB0aGlzLl9ub3JtYWxpemVkSGVhZGVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1N5bmMgPSBjb25maWcuaXNTeW5jO1xyXG4gICAgfTtcclxuXHJcbiAgICBEYXRhUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGdldEhlYWRlcjogZnVuY3Rpb24gKGhlYWRlcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goaGVhZGVyS2V5cywgZnVuY3Rpb24gKGhlYWRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkS2V5ID0gaGVhZGVyS2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gc2VsZi5oZWFkZXJzW2hlYWRlcktleV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbm9ybWFsaXplZEhlYWRlcnNbbm9ybWFsaXplZEtleV0gPSBoZWFkZXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZEhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplZEhlYWRlcnNbbm9ybWFsaXplZEhlYWRlcl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0SGVhZGVyQXNKU09OOiBmdW5jdGlvbiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZSA9IHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoaGVhZGVyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoaGVhZGVyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGhlYWRlclZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIERhdGFRdWVyeS5vcGVyYXRpb25zID0ge1xyXG4gICAgICAgIHJlYWQ6ICdyZWFkJyxcclxuICAgICAgICBjcmVhdGU6ICdjcmVhdGUnLFxyXG4gICAgICAgIHVwZGF0ZTogJ3VwZGF0ZScsXHJcbiAgICAgICAgcmVtb3ZlOiAnZGVzdHJveScsXHJcbiAgICAgICAgcmVtb3ZlU2luZ2xlOiAnZGVzdHJveVNpbmdsZScsXHJcbiAgICAgICAgcmVhZEJ5SWQ6ICdyZWFkQnlJZCcsXHJcbiAgICAgICAgY291bnQ6ICdjb3VudCcsXHJcbiAgICAgICAgcmF3VXBkYXRlOiAncmF3VXBkYXRlJyxcclxuICAgICAgICBzZXRBY2w6ICdzZXRBY2wnLFxyXG4gICAgICAgIHNldE93bmVyOiAnc2V0T3duZXInLFxyXG4gICAgICAgIHVzZXJMb2dpbjogJ2xvZ2luJyxcclxuICAgICAgICB1c2VyTG9nb3V0OiAnbG9nb3V0JyxcclxuICAgICAgICB1c2VyQ2hhbmdlUGFzc3dvcmQ6ICdjaGFuZ2VQYXNzd29yZCcsXHJcbiAgICAgICAgdXNlckxvZ2luV2l0aFByb3ZpZGVyOiAnbG9naW5XaXRoJyxcclxuICAgICAgICB1c2VyTGlua1dpdGhQcm92aWRlcjogJ2xpbmtXaXRoJyxcclxuICAgICAgICB1c2VyVW5saW5rRnJvbVByb3ZpZGVyOiAndW5saW5rRnJvbScsXHJcbiAgICAgICAgZmlsZXNVcGRhdGVDb250ZW50OiAndXBkYXRlQ29udGVudCcsXHJcbiAgICAgICAgZmlsZXNHZXREb3dubG9hZFVybEJ5SWQ6ICdkb3dubG9hZFVybEJ5SWQnXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEYXRhUXVlcnk7XHJcbn0oKSk7IiwidmFyIEV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9FeHByZXNzaW9uJyk7XHJcbnZhciBPcGVyYXRvclR5cGUgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5PcGVyYXRvclR5cGU7XHJcbnZhciBXaGVyZVF1ZXJ5ID0gcmVxdWlyZSgnLi9XaGVyZVF1ZXJ5Jyk7XHJcbnZhciBRdWVyeUJ1aWxkZXIgPSByZXF1aXJlKCcuL1F1ZXJ5QnVpbGRlcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgUXVlcnlcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBxdWVyeSBjbGFzcyB1c2VkIHRvIGRlc2NyaWJlIGEgcmVxdWVzdCB0aGF0IHdpbGwgYmUgbWFkZSB0byB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IEFQSS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmlsdGVyXSBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpZWxkc10gQSBbZmllbGRzIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctU3Vic2V0LW9mLWZpZWxkcyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc29ydF0gQSBbc29ydCBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLXNvcnRpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NraXBdIE51bWJlciBvZiBpdGVtcyB0byBza2lwLiBVc2VkIGZvciBwYWdpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Rha2VdIE51bWJlciBvZiBpdGVtcyB0byB0YWtlLiBVc2VkIGZvciBwYWdpbmcuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V4cGFuZF0gQW4gW2V4cGFuZCBleHByZXNzaW9uXSh7JSBzbHVnIGZlYXR1cmVzLWRhdGEtcmVsYXRpb25zLWRlZmluaW5nLWV4cGFuZCAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUXVlcnkoZmlsdGVyLCBmaWVsZHMsIHNvcnQsIHNraXAsIHRha2UsIGV4cGFuZCkge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xyXG4gICAgICAgIHRoaXMuc29ydCA9IHNvcnQ7XHJcbiAgICAgICAgdGhpcy50b3NraXAgPSBza2lwO1xyXG4gICAgICAgIHRoaXMudG90YWtlID0gdGFrZTtcclxuICAgICAgICB0aGlzLmV4cGFuZEV4cHJlc3Npb24gPSBleHBhbmQ7XHJcbiAgICAgICAgdGhpcy5leHByID0gbmV3IEV4cHJlc3Npb24oT3BlcmF0b3JUeXBlLnF1ZXJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqIEFwcGxpZXMgYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgcXVlcnkuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBvbmx5IGEgc3Vic2V0IG9mIHRoZSBpdGVtcyBiYXNlZCBvbiB2YXJpb3VzIGZpbHRlcmluZyBjcml0ZXJpYS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB3aGVyZVxyXG4gICAgICAgICAqIEBuYW1lIHdoZXJlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKiBEZWZpbmVzIGEgZmlsdGVyIGRlZmluaXRpb24gZm9yIHRoZSBjdXJyZW50IHF1ZXJ5LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHdoZXJlXHJcbiAgICAgICAgICogQG5hbWUgd2hlcmVcclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aGVyZTogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5maWx0ZXIsIFtmaWx0ZXJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVRdWVyeSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIEFwcGxpZXMgYSBmaWVsZHMgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgb25seSBhIHN1YnNldCBvZiBhbGwgYXZhaWxhYmxlIGl0ZW0gZmllbGRzLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNlbGVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZHNFeHByZXNzaW9uIEEgW2ZpZWxkcyBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLVN1YnNldC1vZi1maWVsZHMgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5zZWxlY3QsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy9leGNsdWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZXhjbHVkZSwgYXJndW1lbnRzKTtcclxuICAgICAgICAvL30sXHJcbiAgICAgICAgLyoqIFNvcnRzIHRoZSBpdGVtcyBpbiB0aGUgY3VycmVudCBxdWVyeSBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBvcmRlclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZSB0byBvcmRlciBieSBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9yZGVyOiBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUub3JkZXIsIFtmaWVsZF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFNvcnRzIHRoZSBpdGVtcyBpbiB0aGUgY3VycmVudCBxdWVyeSBpbiBkZXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgb3JkZXJEZXNjXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lIHRvIG9yZGVyIGJ5IGluIGRlc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9yZGVyRGVzYzogZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm9yZGVyX2Rlc2MsIFtmaWVsZF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFNraXBzIGEgY2VydGFpbiBudW1iZXIgb2YgaXRlbXMgZnJvbSB0aGUgYmVnaW5uaW5nIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3Qgb2YgdGhlIGl0ZW1zLiBVc2VkIGZvciBwYWdpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2tpcFxyXG4gICAgICAgICAqIEBzZWUgW3F1ZXJ5LnRha2Vde0BsaW5rIHF1ZXJ5LnRha2V9XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2tpcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2tpcDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnNraXAsIFt2YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFRha2VzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBxdWVyeSByZXN1bHQuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB0YWtlXHJcbiAgICAgICAgICogQHNlZSBbcXVlcnkuc2tpcF17QGxpbmsgcXVlcnkuc2tpcH1cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBpdGVtcyB0byB0YWtlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0YWtlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUudGFrZSwgW3ZhbHVlXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogU2V0cyBhbiBleHBhbmQgZXhwcmVzc2lvbiBmb3IgdGhlIGN1cnJlbnQgcXVlcnkuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBjb21wbGV4IGRhdGEgc2V0cyB1c2luZyBhIHNpbmdsZSBxdWVyeSBiYXNlZCBvbiByZWxhdGlvbnMgYmV0d2VlbiBkYXRhIHR5cGVzLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGV4cGFuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHBhbmRFeHByZXNzaW9uIEFuIFtleHBhbmQgZXhwcmVzc2lvbl0oeyUgc2x1ZyBmZWF0dXJlcy1kYXRhLXJlbGF0aW9ucy1kZWZpbmluZy1leHBhbmQgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZXhwYW5kLCBbZXhwYW5kRXhwcmVzc2lvbl0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIEJ1aWxkcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGlmZmVyZW50IGV4cHJlc3Npb25zIHRoYXQgd2lsbCBiZSBzZW50IHRvIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEl0IGJhc2ljYWxseSB0cmFuc2xhdGVzIGFueSBwcmV2aW91c2x5IHNwZWNpZmllZCBleHByZXNzaW9ucyBpbnRvIHN0YW5kYXJkIHF1ZXJpZXMgdGhhdCB7e3NpdGUuYnN9fSBjYW4gdW5kZXJzdGFuZC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBidWlsZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7JHdoZXJlLCRzZWxlY3QsJHNvcnQsJHNraXAsJHRha2UsJGV4cGFuZH19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUJ1aWxkZXIodGhpcykuYnVpbGQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChvcCwgb3Bycykge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwob3Bycyk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwci5hZGRPcGVyYW5kKG5ldyBFeHByZXNzaW9uKG9wLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFF1ZXJ5O1xyXG59KCkpOyIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIE9wZXJhdG9yVHlwZSA9IGNvbnN0YW50cy5PcGVyYXRvclR5cGU7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIEdlb1BvaW50ID0gcmVxdWlyZSgnLi4vR2VvUG9pbnQnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9FeHByZXNzaW9uJyk7XHJcbnZhciBtYXhEaXN0YW5jZUNvbnN0cyA9IGNvbnN0YW50cy5tYXhEaXN0YW5jZUNvbnN0cztcclxudmFyIHJhZGl1c0NvbnN0cyA9IGNvbnN0YW50cy5yYWRpdXNDb25zdHM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRdWVyeUJ1aWxkZXIocXVlcnkpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgdGhpcy5leHByID0gcXVlcnkuZXhwcjtcclxuICAgIH1cclxuXHJcbiAgICBRdWVyeUJ1aWxkZXIucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8vIFRPRE8gbWVyZ2UgdGhlIHR3byBvYmplY3RzIGJlZm9yZSByZXR1cm5pbmcgdGhlbVxyXG4gICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnk7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS5maWx0ZXIgfHwgcXVlcnkuZmllbGRzIHx8IHF1ZXJ5LnNvcnQgfHwgcXVlcnkudG9za2lwIHx8IHF1ZXJ5LnRvdGFrZSB8fCBxdWVyeS5leHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICR3aGVyZTogcXVlcnkuZmlsdGVyIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdDogcXVlcnkuZmllbGRzIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNvcnQ6IHF1ZXJ5LnNvcnQgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkc2tpcDogcXVlcnkudG9za2lwIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRha2U6IHF1ZXJ5LnRvdGFrZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICRleHBhbmQ6IHF1ZXJ5LmV4cGFuZEV4cHJlc3Npb24gfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJHdoZXJlOiB0aGlzLl9idWlsZFdoZXJlKCksXHJcbiAgICAgICAgICAgICAgICAkc2VsZWN0OiB0aGlzLl9idWlsZFNlbGVjdCgpLFxyXG4gICAgICAgICAgICAgICAgJHNvcnQ6IHRoaXMuX2J1aWxkU29ydCgpLFxyXG4gICAgICAgICAgICAgICAgJHNraXA6IHRoaXMuX2dldFNraXAoKSxcclxuICAgICAgICAgICAgICAgICR0YWtlOiB0aGlzLl9nZXRUYWtlKCksXHJcbiAgICAgICAgICAgICAgICAkZXhwYW5kOiB0aGlzLl9nZXRFeHBhbmQoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFNraXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNraXBFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuc2tpcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBza2lwRXhwcmVzc2lvbiA/IHNraXBFeHByZXNzaW9uLm9wZXJhbmRzWzBdIDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRUYWtlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0YWtlRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLnRha2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFrZUV4cHJlc3Npb24gPyB0YWtlRXhwcmVzc2lvbi5vcGVyYW5kc1swXSA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0RXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBleHBhbmRFeHByZXNzaW9uID0gXy5jaGFpbih0aGlzLmV4cHIub3BlcmFuZHMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLmV4cGFuZDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGV4cHJlc3Npb24pIHsgLy9leHByZXNzaW9uIGNvbnRhaW5zIG9wZXJhbmRzIGFuZCBoYXMgb3BlcmF0b3IgdHlwZSBleHBhbmRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5leHRlbmQocmVzdWx0LCBleHByZXNzaW9uLm9wZXJhbmRzWzBdKTtcclxuICAgICAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgICAgICAgICAgLnZhbHVlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmlzRW1wdHkoZXhwYW5kRXhwcmVzc2lvbikgPyBudWxsIDogZXhwYW5kRXhwcmVzc2lvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9idWlsZFNlbGVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0RXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLnNlbGVjdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIF8ucmVkdWNlKHNlbGVjdEV4cHJlc3Npb24ub3BlcmFuZHMsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbW9bdmFsdWVdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9idWlsZFNvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNvcnRFeHByZXNzaW9ucyA9IF8uZmlsdGVyKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXIgfHwgdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcmRlcl9kZXNjO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoc29ydEV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIF8ucmVkdWNlKHNvcnRFeHByZXNzaW9ucywgZnVuY3Rpb24gKG1lbW8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtb1t2YWx1ZS5vcGVyYW5kc1swXV0gPSB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yZGVyID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkV2hlcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdoZXJlRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLndoZXJlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHdoZXJlRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkKG5ldyBFeHByZXNzaW9uKE9wZXJhdG9yVHlwZS5hbmQsIHdoZXJlRXhwcmVzc2lvbi5vcGVyYW5kcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlckV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uLm9wZXJhbmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9idWlsZDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2ltcGxlKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzUmVnZXgoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdleChleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0dlbyhleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbyhleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0FuZChleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuZChleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc09yKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3IoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNOb3QoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3QoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1NpbXBsZTogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPj0gT3BlcmF0b3JUeXBlLmVxdWFsICYmIGV4cHIub3BlcmF0b3IgPD0gT3BlcmF0b3JUeXBlLnNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgdGVybSA9IHt9LCBmaWVsZFRlcm0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5fdHJhbnNsYXRlb3BlcmF0b3IoZXhwci5vcGVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGVybVtvcGVyYXRvcl0gPSBvcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gPSBvcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaWVsZFRlcm1bb3BlcmFuZHNbMF1dID0gdGVybTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1JlZ2V4OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA+PSBPcGVyYXRvclR5cGUucmVnZXggJiYgZXhwci5vcGVyYXRvciA8PSBPcGVyYXRvclR5cGUuZW5kc1dpdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcmVnZXg6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZFRlcm0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gdGhpcy5fZ2V0UmVnZXgoZXhwcik7XHJcbiAgICAgICAgICAgIHZhciByZWdleFZhbHVlID0gdGhpcy5fZ2V0UmVnZXhWYWx1ZShyZWdleCk7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSByZWdleFZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGV4cHIub3BlcmFuZHNbMV07XHJcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGV4cHIub3BlcmFuZHNbMl0gPyBleHByLm9wZXJhbmRzWzJdIDogJyc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUucmVnZXg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAgPyBwYXR0ZXJuIDogbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiICsgcGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuZW5kc1dpdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiArIFwiJFwiLCBmbGFncyk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbmtub3duIG9wZXJhdG9yIHR5cGUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRSZWdleFZhbHVlOiBmdW5jdGlvbiAocmVnZXgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAnJztcclxuICAgICAgICAgICAgaWYgKHJlZ2V4Lmdsb2JhbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyArPSAnZyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4Lm11bHRpbGluZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyArPSAnbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4Lmlnbm9yZUNhc2UpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgKz0gJ2knO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7JHJlZ2V4OiByZWdleC5zb3VyY2UsICRvcHRpb25zOiBvcHRpb25zfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0dlbzogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPj0gT3BlcmF0b3JUeXBlLm5lYXJTaHBlcmUgJiYgZXhwci5vcGVyYXRvciA8PSBPcGVyYXRvclR5cGUud2l0aGluU2hwZXJlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dlbzogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICBmaWVsZFRlcm1bb3BlcmFuZHNbMF1dID0gdGhpcy5fZ2V0R2VvVGVybShleHByKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRHZW9UZXJtOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIub3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5lYXJTaHBlcmU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5lYXJTcGhlcmVUZXJtKGV4cHIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUud2l0aGluQm94OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRXaXRoaW5Cb3goZXhwcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5Qb2x5Z29uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRXaXRoaW5Qb2x5Z29uKGV4cHIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUud2l0aGluU2hwZXJlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRXaXRoaW5DZW50ZXJTcGhlcmUoZXhwcik7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbmtub3duIG9wZXJhdG9yIHR5cGUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXROZWFyU3BoZXJlVGVybTogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzFdKTtcclxuICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlID0gb3BlcmFuZHNbMl07XHJcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gb3BlcmFuZHNbM107XHJcbiAgICAgICAgICAgIHZhciBtYXhEaXN0YW5jZUNvbnN0O1xyXG4gICAgICAgICAgICB2YXIgdGVybSA9IHtcclxuICAgICAgICAgICAgICAgICckbmVhclNwaGVyZSc6IGNlbnRlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2VDb25zdCA9IG1heERpc3RhbmNlQ29uc3RzW21ldHJpY3NdIHx8IG1heERpc3RhbmNlQ29uc3RzLnJhZGlhbnM7XHJcbiAgICAgICAgICAgICAgICB0ZXJtW21heERpc3RhbmNlQ29uc3RdID0gbWF4RGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0V2l0aGluQm94OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzFdKTtcclxuICAgICAgICAgICAgdmFyIHVwcGVyUmlnaHQgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1syXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcclxuICAgICAgICAgICAgICAgICAgICAnJGJveCc6IFtib3R0b21MZWZ0LCB1cHBlclJpZ2h0XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFdpdGhpblBvbHlnb246IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9nZXRHZW9Qb2ludHMob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJyR3aXRoaW4nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRwb2x5Z29uJzogcG9pbnRzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0V2l0aGluQ2VudGVyU3BoZXJlOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gb3BlcmFuZHNbMl07XHJcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gb3BlcmFuZHNbM107XHJcbiAgICAgICAgICAgIHZhciByYWRpdXNDb25zdCA9IHJhZGl1c0NvbnN0c1ttZXRyaWNzXSB8fCByYWRpdXNDb25zdHMucmFkaWFucztcclxuICAgICAgICAgICAgdmFyIHNwaGVyZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAnY2VudGVyJzogY2VudGVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNwaGVyZUluZm9bcmFkaXVzQ29uc3RdID0gcmFkaXVzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJyR3aXRoaW4nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRjZW50ZXJTcGhlcmUnOiBzcGhlcmVJbmZvXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0R2VvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW9Qb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRHZW9Qb2ludHM6IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5tYXAocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRHZW9Qb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzQW5kOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLmFuZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmQ6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsLCB0ZXJtLCByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IHRoaXMuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYW5kQXBwZW5kOiBmdW5jdGlvbiAoYW5kT2JqLCBuZXdPYmopIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIGtleSwgdmFsdWUsIG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhuZXdPYmopO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFuZE9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmRPYmpba2V5XSA9IG5ld09ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdPYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXy5leHRlbmQodmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmRPYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhbmRPYmo7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNPcjogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9vcjogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BlcmFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gdGhpcy5fYnVpbGQob3BlcmFuZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGVybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHskb3I6IHJlc3VsdH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNOb3Q6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUubm90O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX25vdDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHskbm90OiB0aGlzLl9idWlsZChleHByLm9wZXJhbmRzWzBdKX07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdHJhbnNsYXRlb3BlcmF0b3I6IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5lcXVhbDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5vdF9lcXVhbDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRuZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5ndDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRndCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5sdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRsdCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5ndGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckZ3RlJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmx0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRsdGUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuaXNpbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRpbic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5ub3RpbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRuaW4nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuYWxsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGFsbCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5zaXplOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJHNpemUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbmtub3duIG9wZXJhdG9yIHR5cGUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUXVlcnlCdWlsZGVyO1xyXG59KCkpOyIsInZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuL0RhdGFRdWVyeScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIFJlcXVlc3RPcHRpb25zQnVpbGRlciA9IHt9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybCA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgaWYgKGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucyAmJiBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpIHtcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdCA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdE9iamVjdCA9IHtcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpLFxyXG4gICAgICAgICAgICBmaWx0ZXI6IGRhdGFRdWVyeS5maWx0ZXIsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGRhdGFRdWVyeS5vblN1Y2Nlc3MsXHJcbiAgICAgICAgICAgIGVycm9yOiBkYXRhUXVlcnkub25FcnJvcixcclxuICAgICAgICAgICAgZGF0YTogZGF0YVF1ZXJ5LmRhdGEsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGRhdGFRdWVyeS5oZWFkZXJzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGFRdWVyeS5wYXJzZSkge1xyXG4gICAgICAgICAgICBkZWZhdWx0T2JqZWN0LnBhcnNlID0gZGF0YVF1ZXJ5LnBhcnNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPYmplY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQgPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBhZGRpdGlvbmFsT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfLmV4dGVuZChSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdChkYXRhUXVlcnkpLCBhZGRpdGlvbmFsT3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUgKyAnL19jb3VudCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlcjtcclxuICAgICAgICB2YXIgb2ZpbHRlciA9IG51bGw7IC8vIHJlcXVlc3Qgb3B0aW9ucyBmaWx0ZXJcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcjsgLy8gc2VuZCB0aGUgZmlsdGVyIHRocm91Z2ggcXVlcnkgc3RyaW5nXHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBvZmlsdGVyID0gZmlsdGVyOyAvLyBzZW5kIHRoZSBmaWx0ZXIgYXMgZmlsdGVyIGhlYWRlcnNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXHJcbiAgICAgICAgICAgIGZpbHRlcjogb2ZpbHRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gXy5leHRlbmQoUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEJhc2VPYmplY3QoZGF0YVF1ZXJ5KSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGVdID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZV07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldEFjbF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHsgLy8gaWYgZmlsdGVyIGlzIHN0cmluZyB0aGFuIHdpbGwgdXBkYXRlIGEgc2luZ2xlIGl0ZW0gdXNpbmcgdGhlIGZpbHRlciBhcyBhbiBpZGVudGlmaWVyXHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcjtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7IC8vIGVsc2UgaWYgaXQgaXMgYW4gb2JqZWN0IHRoYW4gd2Ugd2lsbCB1c2UgaXQncyBpZCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXJbaWRGaWVsZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZHBvaW50ICs9ICcvX2FjbCc7XHJcbiAgICAgICAgdmFyIG1ldGhvZCwgZGF0YTtcclxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmFjbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtZXRob2QgPSAnREVMRVRFJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5hY2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcclxuICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXJdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlcjtcclxuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHsgLy8gaWYgZmlsdGVyIGlzIHN0cmluZyB0aGFuIHdpbGwgdXBkYXRlIGEgc2luZ2xlIGl0ZW0gdXNpbmcgdGhlIGZpbHRlciBhcyBhbiBpZGVudGlmaWVyXHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcjtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7IC8vIGVsc2UgaWYgaXQgaXMgYW4gb2JqZWN0IHRoYW4gd2Ugd2lsbCB1c2UgaXQncyBpZCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXJbaWRGaWVsZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZHBvaW50ICs9ICcvX293bmVyJztcclxuXHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiAnb2F1dGgvdG9rZW4nLFxyXG4gICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0XSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6ICdvYXV0aC9sb2dvdXQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBrZWVwVG9rZW5zID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmtlZXBUb2tlbnM7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gJ1VzZXJzL2NoYW5nZXBhc3N3b3JkJztcclxuICAgICAgICBpZiAoa2VlcFRva2Vucykge1xyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnP2tlZXBUb2tlbnM9dHJ1ZSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcclxuICAgICAgICAgICAgYXV0aEhlYWRlcnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luV2l0aFByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXJdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpICsgJy9saW5rJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlclVubGlua0Zyb21Qcm92aWRlcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSkgKyAnL3VubGluaydcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzVXBkYXRlQ29udGVudF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvQ29udGVudCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzR2V0RG93bmxvYWRVcmxCeUlkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyO1xyXG59KCkpOyIsInZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xyXG52YXIgT3BlcmF0b3JUeXBlID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuT3BlcmF0b3JUeXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgZmx1ZW50IEFQSSBvcGVyYXRpb24gZm9yIGNyZWF0aW5nIGEgZmlsdGVyIGZvciBhIHF1ZXJ5IGJ5IGNoYWluaW5nIGRpZmZlcmVudCBydWxlcy5cclxuICAgICAqIEBjbGFzcyBXaGVyZVF1ZXJ5XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2VxIGFzIFdoZXJlUXVlcnkjZXF1YWxcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbmUgYXMgV2hlcmVRdWVyeSNub3RFcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNndCBhcyBXaGVyZVF1ZXJ5I2dyZWF0ZXJUaGFuXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2d0ZSBhcyBXaGVyZVF1ZXJ5I2dyZWF0ZXJUaGFuRXF1YWxcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbHQgYXMgV2hlcmVRdWVyeSNsZXNzVGhhblxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNsdGUgYXMgV2hlcmVRdWVyeSNsZXNzVGhhbkVxdWFsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFdoZXJlUXVlcnkocGFyZW50UXVlcnksIGV4cHJPcCwgc2luZ2xlT3BlcmFuZCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50UXVlcnk7XHJcbiAgICAgICAgdGhpcy5zaW5nbGUgPSBzaW5nbGVPcGVyYW5kO1xyXG4gICAgICAgIHRoaXMuZXhwciA9IG5ldyBFeHByZXNzaW9uKGV4cHJPcCB8fCBPcGVyYXRvclR5cGUud2hlcmUpO1xyXG4gICAgICAgIHRoaXMucGFyZW50LmV4cHIuYWRkT3BlcmFuZCh0aGlzLmV4cHIpO1xyXG4gICAgfVxyXG5cclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYGFuZGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFuZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLmFuZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGBvcmAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIG9yXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXaGVyZVF1ZXJ5KHRoaXMsIE9wZXJhdG9yVHlwZS5vcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgYG5vdGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIG5vdFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLm5vdCwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwci5hZGRPcGVyYW5kKG5ldyBFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb25lKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGVxdWFsIHRvIGEgc3BlY2lmaWMgdmFsdWUuXHJcbiAgICAgICAgICogQG1ldGhvZCBlcVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodG8gd2hpY2ggdGhlIGZpZWxkcyBtdXN0IGJlIGVxdWFsKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBlcTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5lcXVhbCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgKm5vdCogYmUgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cclxuICAgICAgICAgKiBAbWV0aG9kIG5lXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0byB3aGljaCB0aGUgZmllbGQgbXVzdCBub3QgYmUgZXF1YWwpLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5vdF9lcXVhbCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbmAgYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBndFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbikuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ3Q6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZ3QsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGBncmVhdGVyIHRoYW4gb3IgZXF1YWxgIHRvIGEgY2VydGFpbiB2YWx1ZS4gQXBwbGljYWJsZSB0byBOdW1iZXIsIFN0cmluZywgYW5kIERhdGUgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ3RlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBndGU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZ3RlLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgbGVzcyB0aGFuYCBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGx0XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsdDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5sdCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGxlc3MgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBsdGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx0ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5sdGUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGluIGEgc2V0IG9mIHZhbHVlcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGlzaW5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBpbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc2luOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmlzaW4sIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0ICpub3QqIGJlIGluIGEgc2V0IG9mIHZhbHVlcy5cclxuICAgICAgICAgKiBAbWV0aG9kIG5vdGluXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgQW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBub3QgYmUgaW4uXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbm90aW46IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUubm90aW4sIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGluY2x1ZGUgKmFsbCogb2YgdGhlIHNwZWNpZmllZCB2YWx1ZXMuIEFwcGxpY2FibGUgdG8gQXJyYXkgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYWxsXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgQW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIG11c3QgaW5jbHVkZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhbGw6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuYWxsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBjb250YWluIGFuIGFycmF5IHdob3NlIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiBhIHNwZWNpZmllZCB2YWx1ZS4gQXBwbGljYWJsZSB0byBBcnJheSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBzaXplXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBzaXplIHRoYXQgdGhlIGFycmF5IG11c3QgYmUgYmlnZ2VyIHRoYW4uXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5zaXplLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBzYXRpc2Z5IGEgc3BlY2lmaWVkIHJlZ2V4LlxyXG4gICAgICAgICAqIEBtZXRob2QgcmVnZXhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVndWxhckV4cHJlc3Npb24gUmVndWxhciBleHByZXNzaW9uIGluIFBDUkUgZm9ybWF0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnZXg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnJlZ2V4LCBmaWVsZCwgdmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIHZhbHVlIG11c3QgKnN0YXJ0KiB3aXRoIGEgc3BlY2lmaWVkIHN0cmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIHN0YXJ0c1dpdGhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB0aGF0IHRoZSBmaWVsZCBzaG91bGQgc3RhcnQgd2l0aC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnNdIEEgc3RyaW5nIG9mIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGgsIGZpZWxkLCB2YWx1ZSwgZmxhZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgdmFsdWUgbXVzdCAqZW5kKiB3aXRoIGEgc3BlY2lmaWVkIHN0cmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuZHNXaXRoXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHJpbmcgdGhhdCB0aGUgZmllbGQgc2hvdWxkIGVuZCB3aXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuZHNXaXRoOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlLCBmbGFncykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5lbmRzV2l0aCwgZmllbGQsIHZhbHVlLCBmbGFncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSBhbm90aGVyIGdlb3BvaW50LiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2QgbmVhclNwaGVyZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lIGNvbnRhaW5pbmcgYSB7R2VvUG9pbnR9IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgKGRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSxkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKWAsIHdoZXJlICpkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUqIHJhbmdlcyBmcm9tIC05MCB0byA5MCBhbmQgKmRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUqIHJhbmdlcyBmcm9tIC0xODAgdG8gMTgwLiBFeGFtcGxlOiBgKDQyLjY5NTQzMjIsMTIzLjMyMzk0NjcpYFxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuR2VvUG9pbnR9IHBvaW50IENvbXBhcmlzb24gZ2VvcG9pbnQgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0cmljcz1yYWRpYW5zXSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hhdCB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIGRpc3RhbmNlLiBQb3NzaWJsZSB2YWx1ZXM6IHJhZGlhbnMsIGttLCBtaWxlcy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZWFyU3BoZXJlOiBmdW5jdGlvbiAoZmllbGQsIHBvaW50LCBkaXN0YW5jZSwgbWV0cmljcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5uZWFyU2hwZXJlLCBmaWVsZCwgcG9pbnQsIGRpc3RhbmNlLCBtZXRyaWNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBHZW9zcGF0aWFsIGNvbmRpdGlvbiB0aGF0IGEgc3BlY2lmaWVkIGdlb3BvaW50IG11c3QgYmUgd2l0aGluIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUgcmVjdGFuZ2xlLiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluQm94XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnRCb3R0b21MZWZ0IFZhbHVlIHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnRVcHBlclJpZ2h0IFZhbHVlIHJlcHJlc2VudGluZyB0aGUgdXBwZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICogQGV4YW1wbGUgYGBganNcclxuICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEV2ZXJsaXZlLlF1ZXJ5KCk7XHJcbiAgICAgICAgIHF1ZXJ5LndoZXJlKCkud2l0aGluQm94KCdMb2NhdGlvbicsXHJcbiAgICAgICAgIG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMTc4NzEsIDQyLjY4NzcwOSksXHJcbiAgICAgICAgIG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMzEzNDYsIDQyLjcwNzA3NSkpO1xyXG4gICAgICAgICBgYGBcclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aXRoaW5Cb3g6IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnRCb3R0b21MZWZ0LCBwb2ludFVwcGVyUmlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUud2l0aGluQm94LCBmaWVsZCwgcG9pbnRCb3R0b21MZWZ0LCBwb2ludFVwcGVyUmlnaHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBwb2x5Z29uLiBUaGUgcG9seWdvbiBpcyBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2YgZ2VvcG9pbnRzLiBUaGUgbGFzdCBwb2ludCBpbiB0aGUgYXJyYXkgaXMgaW1wbGljaXRseSBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0IHBvaW50IHRodXMgY2xvc2luZyB0aGUgc2hhcGUuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5Qb2x5Z29uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludFtdfSBwb2ludHMgQ29tcGFyaXNvbiB2YWx1ZSBpbiB0aGUgZm9ybSBvZiBhbiBhcnJheSBvZiBnZW9wb2ludHMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgICAgICogQGV4YW1wbGUgYGBganNcclxuICAgICAgICAgdmFyIHBvaW50MSA9IG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMTc4NzEsIDQyLjY4NzcwOSk7XHJcbiAgICAgICAgIHZhciBwb2ludDIgPSBuZXcgRXZlcmxpdmUuR2VvUG9pbnQoNDIuNjk4NzQ5LCA0Mi42OTg3NDkpO1xyXG4gICAgICAgICB2YXIgcG9pbnQzID0gbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMzMTM0NiwgNDIuNzAyMjgyKTtcclxuXHJcbiAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBFdmVybGl2ZS5RdWVyeSgpO1xyXG4gICAgICAgICBxdWVyeS53aGVyZSgpLndpdGhpblBvbHlnb24oXCJsb2NhdGlvblwiLCBbcG9pbnQxLCBwb2ludDIsIHBvaW50M10pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpblBvbHlnb246IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLndpdGhpblBvbHlnb24sIGZpZWxkLCBwb2ludHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBjb29yZGluYXRlIGNpcmNsZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cclxuICAgICAgICAgKiBAbWV0aG9kIHdpdGhpbkNlbnRlclNwaGVyZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lIGNvbnRhaW5pbmcgYSB7R2VvUG9pbnR9IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgKGRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSxkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKWAsIHdoZXJlICpkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUqIHJhbmdlcyBmcm9tIC05MCB0byA5MCBhbmQgKmRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUqIHJhbmdlcyBmcm9tIC0xODAgdG8gMTgwLiBFeGFtcGxlOiBgKDQyLjY5NTQzMjIsMTIzLjMyMzk0NjcpYFxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuR2VvUG9pbnR9IGNlbnRlciBDb21wYXJpc29uIHZhbHVlIHNwZWNpZnlpbmcgdGhlIGNlbnRlciBvZiB0aGUgY29vcmRpbmF0ZSBjaXJjbGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBWYWx1ZSBzcGVjaWZ5aW5nIHRoZSByYWRpdXMgbGVuZ3RoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0cmljcz1yYWRpYW5zXSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hhdCB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIHJhZGl1cyBsZW5ndGguIFBvc3NpYmxlIHZhbHVlczogcmFkaWFucywga20sIG1pbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpbkNlbnRlclNwaGVyZTogZnVuY3Rpb24gKGZpZWxkLCBjZW50ZXIsIHJhZGl1cywgbWV0cmljcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmUsIGZpZWxkLCBjZW50ZXIsIHJhZGl1cywgbWV0cmljcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmRzIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IFdoZXJlUXVlcnkuIFlvdSBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgaW4gb3JkZXIgdG8gY29udGludWUgd2l0aCB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgcGFyZW50IGBRdWVyeWAuIEFsbCBvdGhlciBgV2hlcmVRdWVyeWAgbWV0aG9kcyByZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgYFdoZXJlUXVlcnlgIHRvIGFsbG93IGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgZG9uZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFdoZXJlUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZG9uZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5lcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmVxO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubm90RXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5uZTtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3Q7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ncmVhdGVyVGhhbkVxdWFsID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3RlO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubGVzc1RoYW4gPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sdDtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmxlc3NUaGFuRXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sdGU7XHJcblxyXG4gICAgcmV0dXJuIFdoZXJlUXVlcnk7XHJcbn0oKSk7IiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiByZXF3ZXN0KG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgaHR0cFJlcXVlc3RPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XHJcbiAgICAgICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5jb250ZW50ID0gb3B0aW9ucy5kYXRhOyAvLyBOT1RFOiBJZiB3ZSBwYXNzIG51bGwvdW5kZWZpbmVkLCBpdCB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbiBpbiB0aGUgaHR0cCBtb2R1bGUuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgaHR0cFJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG5cclxuICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IG5vb3A7XHJcbiAgICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvciB8fCBub29wO1xyXG5cclxuICAgICAgICB2YXIgcmVxdWVzdFN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFN0cmluZyA9IHJlc3BvbnNlLmNvbnRlbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgY2FsbGJhY2sgY2FsbHMgYSBjdXN0b20gcGFyc2UgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY29udGVudFN0cmluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBjYWxsYmFjayByZWxpZXMgb24gYSBKU09OIE9iamVjdCB3aXRoIFJlc3BvbnNlVGV4dCBpbnNpZGVcclxuICAgICAgICAgICAgICAgIGVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IGNvbnRlbnRTdHJpbmdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlcXVlc3RFcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAvLyBlcnJvcjogZnVuY3Rpb24oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKVxyXG4gICAgICAgICAgICAvLyB3aGVuIHRpbWVvdXRpbmcgZm9yIGV4YW1wbGUgKGkuZS4gbm8gaW50ZXJuZXQgY29ubmVjdGl2aXR5KSwgd2UgZ2V0IGFuIGVyciB3aXRoIGNvbnRlbnQgeyBtZXNzYWdlOiBcInRpbWVvdXQuLi5cIiwgc3RhY2s6IG51bGwgfVxyXG4gICAgICAgICAgICBlcnJvcih7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBodHRwLnJlcXVlc3QoaHR0cFJlcXVlc3RPcHRpb25zKS50aGVuKHJlcXVlc3RTdWNjZXNzQ2FsbGJhY2ssIHJlcXVlc3RFcnJvckNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVxd2VzdDtcclxufSgpKTsiLCJ2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJ3JzdnAnKTtcclxudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcXdlc3Qob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB1cmxQYXJ0cyA9IHVybC5wYXJzZShvcHRpb25zLnVybCk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3Q7XHJcbiAgICAgICAgaWYgKHVybFBhcnRzLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gaHR0cHMucmVxdWVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBfLm5vb3A7XHJcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgXy5ub29wO1xyXG5cclxuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XHJcbiAgICAgICAgdmFyIHJlcSA9IHJlcXVlc3Qoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgICAgICBob3N0bmFtZTogdXJsUGFydHMuaG9zdG5hbWUsXHJcbiAgICAgICAgICAgIHBvcnQ6IHVybFBhcnRzLnBvcnQsXHJcbiAgICAgICAgICAgIHBhdGg6IHVybFBhcnRzLnBhdGgsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIHZhciBqc29uID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50RW5jb2RpbmcgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm94eTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50RW5jb2Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3ppcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eSA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnBpcGUocmVzcG9uc2VQcm94eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJveHkgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eS5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXNwb25zZVByb3h5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGpzb24gKz0gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlc3BvbnNlUHJveHkub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIDF4eCBJbmZvcm1hdGlvbmFsLCAyeHggU3VjY2VzcywgM3h4IFJlZGlyZWN0aW9uLCA0eHggQ2xpZW50IEVycm9yLCA1eHggU2VydmVyIEVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlcy5zdGF0dXNDb2RlIDwgNDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGpzb24sIHJlcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGpzb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBlbXB0eSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGVycm9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmVycm9yKHsgcmVzcG9uc2VUZXh0OiBlIH0pOyAvLyBUT0RPXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRFbmNvZGluZyA9IGhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50RW5jb2Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3ppcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIob3B0aW9ucy5kYXRhLCAndXRmLTgnKTtcclxuICAgICAgICAgICAgICAgICAgICB6bGliLmd6aXAoYnVmLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmVuZChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXEuZW5kKG9wdGlvbnMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcS5lbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcXdlc3Q7XHJcbn0oKSk7IiwidmFyIGJ1aWxkUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnVpbGRQcm9taXNlO1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXInKTtcclxudmFyIHJzdnAgPSByZXF1aXJlKCcuLi9jb21tb24nKS5yc3ZwO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIGlkRmllbGQgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5pZEZpZWxkO1xyXG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZScpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcnM7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIG1lcmdlUmVzdWx0RGF0YShkYXRhLCBzdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHJlcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGtlbmRvIG9ic2VydmFibGUgYXJyYXlcclxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShkYXRhKSB8fCB0eXBlb2YgZGF0YS5sZW5ndGggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXy5leHRlbmQoaXRlbSwgYXR0cnNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXy5leHRlbmQoZGF0YSwgYXR0cnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdWNjZXNzKHJlcywgcmVzcG9uc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWVyZ2VVcGRhdGVSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRBdCA9IHJlcy5Nb2RpZmllZEF0O1xyXG4gICAgICAgICAgICBkYXRhLk1vZGlmaWVkQXQgPSBtb2RpZmllZEF0O1xyXG4gICAgICAgICAgICBzdWNjZXNzKHJlcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBEYXRhXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgY2xhc3MgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBhbGwgQ1JVRCBvcGVyYXRpb25zIHRvIGEgZ2l2ZW4ge3tzaXRlLmJzfX0gZGF0YSB0eXBlLiBDb3ZlcnMgYWR2YW5jZWQgc2NlbmFyaW9zIHdpdGggY3VzdG9tIGhlYWRlcnMgYW5kIHNwZWNpYWwgc2VydmVyLXNpZGUgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR1cFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25OYW1lXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGEoc2V0dXAsIGNvbGxlY3Rpb25OYW1lLCBvZmZsaW5lU3RvcmFnZSwgZXZlcmxpdmUpIHtcclxuICAgICAgICB0aGlzLnNldHVwID0gc2V0dXA7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZSA9IG9mZmxpbmVTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuZXZlcmxpdmUgPSBldmVybGl2ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2lzT25saW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlID8gdGhpcy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZSgpIDogdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0T2ZmbGluZUNyZWF0ZURhdGE6IGZ1bmN0aW9uIChxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVEYXRhO1xyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHF1ZXJ5LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5LmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0VG9DcmVhdGUgPSBfLmV4dGVuZChxdWVyeS5kYXRhW2ldLCByZXF1ZXN0UmVzcG9uc2UucmVzdWx0W2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhLnB1c2gob2JqZWN0VG9DcmVhdGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gXy5leHRlbmQocXVlcnkuZGF0YSwgcmVxdWVzdFJlc3BvbnNlLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FwcGx5T2ZmbGluZTogZnVuY3Rpb24gKHF1ZXJ5LCByZXF1ZXN0UmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGF1dG9TeW5jRW5hYmxlZCA9IHRoaXMub2ZmbGluZVN0b3JhZ2UgJiYgdGhpcy5vZmZsaW5lU3RvcmFnZS5zZXR1cC5hdXRvU3luYztcclxuICAgICAgICAgICAgaWYgKGF1dG9TeW5jRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChxdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bmNSZWFkUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KF8uZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFJlc3BvbnNlLnJlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5jcmVhdGUoc3luY1JlYWRRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVEYXRhID0gdGhpcy5fZ2V0T2ZmbGluZUNyZWF0ZURhdGEocXVlcnksIHJlcXVlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoXy5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjcmVhdGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW5jOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLmNyZWF0ZShjcmVhdGVRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuaXNTeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBfLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zW2tleV0sIHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuXHJcbiAgICAgICAgICogRGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBvZmZsaW5lU3RvcmFnZSBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB3b3JrT2ZmbGluZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgdXNlT2ZmbGluZTogZnVuY3Rpb24gKHVzZU9mZmxpbmUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gdXNlT2ZmbGluZSgpIHF1ZXJ5IG1vZGlmaWVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbigndXNlT2ZmbGluZScsIHVzZU9mZmxpbmUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU3luYzogZnVuY3Rpb24gKGlzU3luYykge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNpbmdsZSB2YWx1ZSBpcyBleHBlY3RlZCBpbiBpc1N5bmMoKSBxdWVyeSBtb2RpZmllcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2lzU3luYycsIGlzU3luYyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBpbnZva2UgdGhlIHt7QGxpbmsgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmhhc0F1dGhlbnRpY2F0aW9uUmVxdWlyZW1lbnR9fS5cclxuICAgICAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBhdXRoZW50aWNhdGlvbiBtb2R1bGUgaGFzIGFuIG9uQXV0aGVudGljYXRpb25SZXF1aXJlZCBmdW5jdGlvbiAuXHJcbiAgICAgICAgICogQHBhcmFtIHNraXBBdXRoXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICBza2lwQXV0aDogZnVuY3Rpb24gKHNraXBBdXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIHNraXBBdXRoKCkgcXVlcnkgbW9kaWZpZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdza2lwQXV0aCcsIHNraXBBdXRoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RpZmllcyB3aGV0aGVyIHRoZSBxdWVyeSBzaG91bGQgYmUgYXBwbGllZCBvZmZsaW5lLCBpZiB0aGUgc2RrIGlzIGN1cnJlbnR5IHdvcmtpbmcgb25saW5lLlxyXG4gICAgICAgICAqIERlZmF1bHQgaXMgdHJ1ZS5cclxuICAgICAgICAgKiBPbmx5IHZhbGlkIHdoZW4gb2ZmbGluZVN0b3JhZ2UgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIGFwcGx5T2ZmbGluZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgYXBwbHlPZmZsaW5lOiBmdW5jdGlvbiAoYXBwbHlPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIGFwcGx5T2ZmbGluZSgpIHF1ZXJ5IG1vZGlmaWVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbignYXBwbHlPZmZsaW5lJywgYXBwbHlPZmZsaW5lKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFkZGl0aW9uYWwgbm9uLXN0YW5kYXJkIEhUVFAgaGVhZGVycyBpbiB0aGUgY3VycmVudCBkYXRhIHJlcXVlc3QuIFNlZSBbTGlzdCBvZiBOb24tU3RhbmRhcmQgSFRUUCBIZWFkZXJzXXt7JSBzbHVnIHJlc3QtYXBpLWhlYWRlcnN9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnMgQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHNlbnQgd2l0aCB0aGUgZGF0YSByZXF1ZXN0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhIZWFkZXJzOiBmdW5jdGlvbiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdoZWFkZXJzJywgaGVhZGVycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuIGV4cGFuZCBleHByZXNzaW9uIHRvIGJlIHVzZWQgaW4gdGhlIGRhdGEgcmVxdWVzdC4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGNvbXBsZXggZGF0YSBzZXRzIHVzaW5nIGEgc2luZ2xlIHF1ZXJ5IGJhc2VkIG9uIHJlbGF0aW9ucyBiZXR3ZWVuIGRhdGEgdHlwZXMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHBhbmRFeHByZXNzaW9uIEFuIFtleHBhbmQgZXhwcmVzc2lvbl0oeyUgc2x1ZyBmZWF0dXJlcy1kYXRhLXJlbGF0aW9ucy1kZWZpbmluZy1leHBhbmQgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgZXhwYW5kSGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRXhwYW5kJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kRXhwcmVzc2lvbilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aEhlYWRlcnMoZXhwYW5kSGVhZGVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzZXMgYSBxdWVyeSB3aXRoIGFsbCBvZiBpdHMgb3B0aW9ucy4gQXBwbGllcyB0aGUgb3BlcmF0aW9uIG9ubGluZS9vZmZsaW5lXHJcbiAgICAgICAgICogQHBhcmFtIHtEYXRhUXVlcnl9IHF1ZXJ5IFRoZSBxdWVyeSB0byBwcm9jZXNzXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFRdWVyeX0gcXVlcnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcm9jZXNzRGF0YVF1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZmxpbmVTdG9yYWdlRW5hYmxlZCA9IHRoaXMuZXZlcmxpdmUuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCk7XHJcbiAgICAgICAgICAgIHF1ZXJ5LnVzZU9mZmxpbmUgPSBvZmZsaW5lU3RvcmFnZUVuYWJsZWQgPyAhdGhpcy5ldmVybGl2ZS5pc09ubGluZSgpIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHF1ZXJ5LmFwcGx5T2ZmbGluZSA9IG9mZmxpbmVTdG9yYWdlRW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gXy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFxdWVyeS5za2lwQXV0aCAmJiB0aGlzLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uICYmIHRoaXMuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvciA9IF8ud3JhcChxdWVyeS5vbkVycm9yLCBmdW5jdGlvbiAoZXJyb3JGdW5jLCBlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRUb2tlbi5jb2RlIHx8IGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5leHBpcmVkVG9rZW4uY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlID0gc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5fZW5zdXJlQXV0aGVudGljYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5ub1JldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuQXV0aGVudGljYXRlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRnVuYy5jYWxsKHNlbGYsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLCBxdWV1ZSB0aGUgZGF0YSBxdWVyeSBhZnRlciB3ZSBoYXZlIGxvZ2dlZCBpblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZSA9IHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uX2Vuc3VyZUF1dGhlbnRpY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5ub1JldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKCFxdWVyeS5pc1N5bmMgJiYgdGhpcy5vZmZsaW5lU3RvcmFnZSAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlLmlzU3luY2hyb25pemluZygpKSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIEV2ZXJsaXZlRXJyb3JzLnN5bmNJblByb2dyZXNzKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghcXVlcnkudXNlT2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3VjY2VzcyA9IHF1ZXJ5Lm9uU3VjY2VzcztcclxuICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fYXBwbHlPZmZsaW5lKHF1ZXJ5LCBkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5ID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW3F1ZXJ5Lm9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMuc2V0dXAsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5hcHBseU9mZmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYXBwbHlPZmZsaW5lIG11c3QgYmUgZmFsc2Ugd2hlbiB3b3JraW5nIG9mZmxpbmUuJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeS5vblN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVyci5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFdmVybGl2ZUVycm9yKGVyci5tZXNzYWdlLCBFdmVybGl2ZUVycm9ycy5nZW5lcmFsRGF0YWJhc2VFcnJvci5jb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgb3B0aW9uczogeyByZXF1ZXN0U2V0dGluZ3M6IHsgZXhlY3V0ZVNlcnZlckNvZGU6IGZhbHNlIH0gfS4gcG93ZXIgZmllbGRzIHF1ZXJpZXMgY291bGQgYmUgYWRkZWQgdG8gdGhhdCBvcHRpb25zIGFyZ3VtZW50XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NDYixcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckNiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIG9wdGlvbnNcclxuICAgICAgICAvLyBUT0RPIHRoaW5rIHRvIHBhc3MgdGhlIGlkIGFzIGEgZmlsdGVyXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRCeUlkXHJcbiAgICAgICAgICogQG5hbWUgZ2V0QnlJZFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gaXRlbSBieSBJRC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldEJ5SWRcclxuICAgICAgICAgKiBAbmFtZSBnZXRCeUlkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIChpZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiB0aGUgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvdW50IG9mIHRoZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICAgICAqIEBuYW1lIGNyZWF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBkYXRhIEl0ZW0gb3IgaXRlbXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAgICAgKiBAbmFtZSBjcmVhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSBUaGUgaXRlbSBvciBpdGVtcyB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogbWVyZ2VSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZU9iamVjdCBVcGRhdGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIG9iamVjdHMgdGhhdCBtYXRjaCBhIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFuIG9iamVjdCBieSBJRCB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlZE9iamVjdCBVcGRhdGVkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFuIG9iamVjdCBieSBJRCB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZWQgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmF3VXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBhdHRycyxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGVyZSBpcyBhIGNhc2UgaW4gd2hpY2ggcmVwbGFjZSA9IHRydWUgaXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCByZXBsYWNlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgIGRhdGFbcmVwbGFjZSA/ICckcmVwbGFjZScgOiAnJHNldCddID0gYXR0cnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHVwZGF0ZSBpcyBmb3IgYSBzaW5nbGUgaXRlbSAtIG1lcmdlIHRoZSB1cGRhdGUgcmVzdWx0IGFuZCBhZGQgdGhlIE1vZGlmaWVkQXQgZmllbGQgdG8gdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgdmFyIG9uU3VjY2VzcyA9IHNpbmdsZSA/IG1lcmdlVXBkYXRlUmVzdWx0RGF0YShhdHRycywgc3VjY2VzcykgOiBzdWNjZXNzO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaW5nbGUgPyBhdHRyc1tpZEZpZWxkXSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHRha2VzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBib3RoIHRoZSBkYXRhIGl0ZW0gdG8gYmUgdXBkYXRlZCBhbmQgdGhlIHVwZGF0ZWQgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBUaGUgaXRlbSB0aGF0IHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVNpbmdsZTogZnVuY3Rpb24gKG1vZGVsLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG1vZGVsLCBudWxsLCB0cnVlLCBmYWxzZSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIGl0ZW1zIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFRoZSB1cGRhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWwgVGhlIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobW9kZWwsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShtb2RlbCwgZmlsdGVyLCBmYWxzZSwgZmFsc2UsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogc2luZ2xlID8gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlIDogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2luZ2xlID8gYXR0cnNbaWRGaWVsZF0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBzaW5nbGUgZGF0YSBpdGVtIGJ5IElELlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lTaW5nbGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95U2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95U2luZ2xlOiBmdW5jdGlvbiAobW9kZWwsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KG1vZGVsLCBudWxsLCB0cnVlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIGEgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveShudWxsLCBmaWx0ZXIsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB3aGljaCBhY2NlcHRzIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QWNsXHJcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFjbCBUaGUgYWNsIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhbiBpdGVtIHdpdGggYSBzcGVjaWZpZWQgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEFjbDogZnVuY3Rpb24gKGFjbCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0QWNsLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjbDogYWNsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2wgVGhlIG5ldyBvd25lciBJRC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBUaGUgaXRlbSB3aG9zZSBvd25lciB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRPd25lclxyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFjbCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIG93bmVyIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMudXNlT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lPXRydWVdIElmIHdvcmtpbmcgb25saW5lLCB3aGV0aGVyIHRvIGFsc28gYXBwbHkgdGhlIG9wZXJhdGlvbiBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXJJZCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXJJZCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldE93bmVyOiBmdW5jdGlvbiAob3duZXJJZCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPd25lcjogb3duZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F2ZXMgdGhlIHByb3ZpZGVkIGRhdGEgaXRlbS4gVGhpcyBvcGVyYXRpb24gd2lsbCBjcmVhdGUgb3IgdXBkYXRlIHRoZSBpdGVtIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIG5ldyBvciBleGlzdGluZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcclxuICAgICAgICAgKiBAbmFtZSBzYXZlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBzYXZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHdpbGwgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBuZXcgb3IgZXhpc3RpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzYXZlXHJcbiAgICAgICAgICogQG5hbWUgc2F2ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIHNhdmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlOiBmdW5jdGlvbiAobW9kZWwsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGlzTmV3ID0gdGhpcy5pc05ldyhtb2RlbCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2F2ZVN1Y2Nlc3MocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnR5cGUgPSBpc05ldyA/ICdjcmVhdGUnIDogJ3VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVFcnJvcihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9IGlzTmV3ID8gJ2NyZWF0ZScgOiAndXBkYXRlJztcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc05ldykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZShtb2RlbCwgc2F2ZVN1Y2Nlc3MsIHNhdmVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnVwZGF0ZVNpbmdsZShtb2RlbCwgc2F2ZVN1Y2Nlc3MsIHNhdmVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbSBpcyBuZXcgb3Igbm90LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0gbW9kZWwgSXRlbSB0byBjaGVjay5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc05ldzogZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbW9kZWxbaWRGaWVsZF0gPT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERhdGE7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAY2xhc3MgRmlsZXNcclxuICogQHByb3RlY3RlZFxyXG4gKiBAZXh0ZW5kcyBEYXRhXHJcbiAqL1xyXG5cclxudmFyIGJ1aWxkUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnVpbGRQcm9taXNlO1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuYWRkRmlsZXNGdW5jdGlvbnMgPSBmdW5jdGlvbiBhZGRGaWxlc0Z1bmN0aW9ucyhucykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRwb2ludCBmb3IgdXBsb2FkaW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0VXBsb2FkVXJsXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBucy5nZXRVcGxvYWRVcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApICsgdGhpcy5jb2xsZWN0aW9uTmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRvd25sb2FkIFVSTCBmb3IgYSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXREb3dubG9hZFVybFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdXJsIFRoZSBkb3dubG9hZCBVUkwuXHJcbiAgICAgKi9cclxuICAgIG5zLmdldERvd25sb2FkVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybCh0aGlzLnNldHVwKSArIHRoaXMuY29sbGVjdGlvbk5hbWUgKyAnLycgKyBmaWxlSWQgKyAnL0Rvd25sb2FkJztcclxuICAgIH07XHJcblxyXG4gICAgbnMuX2dldFVwZGF0ZVVybCA9IGZ1bmN0aW9uIChmaWxlSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uTmFtZSArICcvJyArIGZpbGVJZCArICcvQ29udGVudCc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kcG9pbnQgZm9yIHVwZGF0aW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0VXBkYXRlVXJsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHVybCBUaGUgdXBkYXRlIFVSTC5cclxuICAgICAqL1xyXG4gICAgbnMuZ2V0VXBkYXRlVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybCh0aGlzLnNldHVwKSArIHRoaXMuX2dldFVwZGF0ZVVybChmaWxlSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYSBmaWxlJ3MgY29udGVudFxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVDb250ZW50XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIEZpbGUgSUQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZSBGaWxlIGNvbnRlbnRzIGluIGJhc2U2NCBlbmNvZGluZy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBucy51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gKGZpbGVJZCwgZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhc3NlZCBmaWxlIGNvbnRlbnQgaXMgYmFzZTY0IGVuY29kZWRcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGUsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZG93bmxvYWQgVVJMIGZvciBhIGZpbGUgYnkgSUQuXHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldERvd25sb2FkVXJsQnlJZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBGaWxlIElELlxyXG4gICAgICogQHBhcmFtIG9wZXJhdGlvblBhcmFtZXRlcnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgbnMuZ2V0RG93bmxvYWRVcmxCeUlkID0gZnVuY3Rpb24gKGZpbGVJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNHZXREb3dubG9hZFVybEJ5SWQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YS5yZXN1bHQuVXJpKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxufTsiLCIvKipcclxuICogQGNsYXNzIFVzZXJzXHJcbiAqIEBleHRlbmRzIERhdGFcclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XHJcbnZhciBndWFyZFVuc2V0ID0gdXRpbHMuZ3VhcmRVbnNldDtcclxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5hZGRVc2Vyc0Z1bmN0aW9ucyA9IGZ1bmN0aW9uIGFkZFVzZXJzRnVuY3Rpb25zKG5zLCBldmVybGl2ZSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHVzZXIgd2l0aCB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSBuZXcgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBuZXcgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVzZXJJbmZvIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIHRoZSB1c2VyIChleC4gRGlzcGxheU5hbWUsIEVtYWlsLCBldGMuKVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgdXNlciB1c2luZyBhIHVzZXJuYW1lIGFuZCBhIHBhc3N3b3JkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgbmV3IHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgbmV3IHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSBhdHRyc1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgYXR0cnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgZ3VhcmRVbnNldCh1c2VybmFtZSwgJ3VzZXJuYW1lJyk7XHJcbiAgICAgICAgZ3VhcmRVbnNldChwYXNzd29yZCwgJ3Bhc3N3b3JkJyk7XHJcbiAgICAgICAgdmFyIHVzZXIgPSB7XHJcbiAgICAgICAgICAgIFVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgUGFzc3dvcmQ6IHBhc3N3b3JkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBfLmV4dGVuZCh1c2VyLCBhdHRycyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVzZXIsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHRoYXQgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdG8gdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjdXJyZW50VXNlclxyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHRvIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgY3VycmVudFVzZXJcclxuICAgICAqIEBuYW1lIGN1cnJlbnRVc2VyXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMuY3VycmVudFVzZXIgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlkID0gc2VsZi5ldmVybGl2ZS5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQoKSAmJiBzZWxmLmV2ZXJsaXZlLmlzT2ZmbGluZSgpID8gc2VsZi5ldmVybGl2ZS5zZXR1cC5wcmluY2lwYWxJZCA6ICdtZSc7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGlkID09PSAnbWUnICYmICFzZWxmLmV2ZXJsaXZlLnNldHVwLnRva2VuICYmICFzZWxmLmV2ZXJsaXZlLnNldHVwLm1hc3RlcktleSB8fCAhaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtyZXN1bHQ6IG51bGx9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2VsZi5nZXRCeUlkKGlkKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3Jlc3VsdDogcmVzLnJlc3VsdH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24gJiYgc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IDYwMSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IDgwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihFdmVybGl2ZUVycm9ycy5pbnZhbGlkVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBwYXNzd29yZCBvZiBhIHVzZXIuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXHJcbiAgICAgKiBAbmFtZSBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXNzd29yZCBUaGUgdXNlcidzIG5ldyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFRva2VucyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgdG9rZW5zIHdpbGwgYmUgcHJlc2VydmVkIGV2ZW4gYWZ0ZXIgdGhlIHBhc3N3b3JkIGNoYW5nZS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgcGFzc3dvcmQgb2YgYSB1c2VyLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQG5hbWUgY2hhbmdlUGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFzc3dvcmQgVGhlIHVzZXIncyBuZXcgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBUb2tlbnMgSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIHRva2VucyB3aWxsIGJlIHByZXNlcnZlZCBldmVuIGFmdGVyIHRoZSBwYXNzd29yZCBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMuY2hhbmdlUGFzc3dvcmQgPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBuZXdQYXNzd29yZCwga2VlcFRva2Vucywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc3VjY2VzcyA9IF8ud3JhcChzdWNjZXNzLCBmdW5jdGlvbiAoc3VjY2VzcywgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXBUb2tlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnMuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBVc2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgUGFzc3dvcmQ6IHBhc3N3b3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIE5ld1Bhc3N3b3JkOiBuZXdQYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAga2VlcFRva2Vuczoga2VlcFRva2Vuc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSlcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcilcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGluIGEgdXNlciB1c2luZyBhIHVzZXJuYW1lIGFuZCBhIHBhc3N3b3JkIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLiBBbGwgcmVxdWVzdHMgaW5pdGlhdGVkIGJ5IHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlIHdpbGwgYmUgYXV0aGVudGljYXRlZCB3aXRoIHRoYXQgdXNlcidzIGNyZWRlbnRpYWxzLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpblxyXG4gICAgICogQG5hbWUgbG9naW5cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW4odXNlcm5hbWUsIHBhc3N3b3JkLCBzdWNjZXNzLCBlcnJvcik7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxyXG4gICAgICogQG5hbWUgbG9nb3V0XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dvdXQgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9nb3V0KHN1Y2Nlc3MsIGVycm9yKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoRmFjZWJvb2sgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aEZhY2Vib29rKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIEJhY2tlbmQgU2VydmljZXMgdXNlciB3aXRoIGEgRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEZhY2Vib29rIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gYSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoRmFjZWJvb2sgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnRmFjZWJvb2snLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEZhY2Vib29rIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgRmFjZWJvb2sgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMudW5saW5rRnJvbUZhY2Vib29rID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignRmFjZWJvb2snLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoQURGUyA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoQURGUyhhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoQURGU1xyXG4gICAgICogQG5hbWUgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEFERlMgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgQURGUyBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoQURGUyA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdBREZTJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBBREZTIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEFERlMgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21BREZTID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignQURGUycsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luV2l0aExpdmVJRCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoTGl2ZUlEKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIExpdmVJZCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aExpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBMaXZlSUQgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIExpdmVJZCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aExpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBMaXZlSUQgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5saW5rV2l0aExpdmVJRCA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdMaXZlSUQnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIExpdmVJRCBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIExpdmVJRCBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tTGl2ZUlEID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignTGl2ZUlEJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoR29vZ2xlID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhHb29nbGUoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoR29vZ2xlID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0dvb2dsZScsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Hb29nbGVcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21Hb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Hb29nbGVcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21Hb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tR29vZ2xlID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignR29vZ2xlJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB3aXRoIGEgVHdpdHRlciB0b2tlbi4gQSBzZWNyZXQgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUd2l0dGVyIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVHdpdHRlciBzZWNyZXQgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aFR3aXR0ZXIodG9rZW4sIHRva2VuU2VjcmV0LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgdG8gYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFRoZSBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgdG8gYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4gICAgICAgICAqIExpbmtzIGEgQmFja2VuZCBTZXJ2aWNlcyB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFRoZSBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5saW5rV2l0aFR3aXR0ZXIgPSBmdW5jdGlvbiAodXNlcklkLCB0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ1R3aXR0ZXInLFxyXG4gICAgICAgICAgICBUb2tlbjogdG9rZW4sXHJcbiAgICAgICAgICAgIFRva2VuU2VjcmV0OiB0b2tlblNlY3JldFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIFR3aXR0ZXIgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbVR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIFR3aXR0ZXIgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbVR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tVHdpdHRlciA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIoJ1R3aXR0ZXInLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0b2tlbiBhbmQgdG9rZW4gdHlwZSB0aGF0IHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIHdpbGwgdXNlIGZvciBhdXRob3JpemF0aW9uLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBzZXRBdXRob3JpemF0aW9uXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhdXRob3JpemF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtFdmVybGl2ZS5Ub2tlblR5cGV9IHRva2VuVHlwZSBUb2tlbiB0eXBlLiBDdXJyZW50bHkgb25seSAnYmVhcmVyJyB0b2tlbiBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbmNpcGFsSWQgVGhlIGlkIG9mIHRoZSB1c2VyIHRoYXQgaXMgbG9nZ2VkIGluLlxyXG4gICAgICovXHJcbiAgICBucy5zZXRBdXRob3JpemF0aW9uID0gZnVuY3Rpb24gc2V0QXV0aG9yaXphdGlvbih0b2tlbiwgdG9rZW5UeXBlLCBwcmluY2lwYWxJZCkge1xyXG4gICAgICAgIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLnNldEF1dGhvcml6YXRpb24odG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0aGF0IHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBjdXJyZW50bHkgdXNlcy4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IHRoYW4gbG9nZ2luZyBvdXQsIGJlY2F1c2UgdGhlIGN1cnJlbnQgYXV0aG9yaXphdGlvbiB0b2tlbiBpcyBub3QgaW52YWxpZGF0ZWQuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyQXV0aG9yaXphdGlvblxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgbnMuY2xlYXJBdXRob3JpemF0aW9uID0gZnVuY3Rpb24gY2xlYXJBdXRob3JpemF0aW9uKCkge1xyXG4gICAgICAgIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLnNldEF1dGhvcml6YXRpb24obnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLl9saW5rV2l0aFByb3ZpZGVyID0gZnVuY3Rpb24gKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdXNlcklkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaWRlbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXJOYW1lLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogcHJvdmlkZXJOYW1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogdXNlcklkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcbn07IiwidmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi9FdmVybGl2ZScpO1xyXG52YXIgaXNOb2RlanMgPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOb2RlanM7XHJcblxyXG52YXIgdXRpbHMgPSB7fTtcclxuXHJcbnV0aWxzLmd1YXJkVW5zZXQgPSBmdW5jdGlvbiBndWFyZFVuc2V0KHZhbHVlLCBuYW1lLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICBtZXNzYWdlID0gJ1RoZSAnICsgbmFtZSArICcgaXMgcmVxdWlyZWQnO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLnBhcnNlVXRpbGl0aWVzID0ge1xyXG4gICAgZ2V0UmV2aXZlcjogZnVuY3Rpb24gKHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcpIHtcclxuICAgICAgICB2YXIgZGF0ZVBhcnNlcjtcclxuICAgICAgICBpZiAocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZykge1xyXG4gICAgICAgICAgICBkYXRlUGFyc2VyID0gdXRpbHMucGFyc2VVdGlsaXRpZXMucGFyc2VJc29EYXRlU3RyaW5nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGVQYXJzZXIgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlSXNvRGF0ZVN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oXFxkezR9KSgtKFxcZHsyfSkoLShcXGR7Mn0pKFQoXFxkezJ9KTooXFxkezJ9KSg6KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoXFwrfC0pKFxcZHsyfSk6KFxcZHsyfSkpKSk/KSkkLykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVRpbWVcclxuICAgICAgICAgICAgdmFyIHNlY29uZFBhcnRzID0gbWF0Y2hbMTJdO1xyXG4gICAgICAgICAgICBpZiAoc2Vjb25kUGFydHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgPSBNYXRoLnJvdW5kKE51bWJlcihzZWNvbmRQYXJ0cy5zdWJzdHIoMCwgMykgKyAnLicgKyBzZWNvbmRQYXJ0cy5zdWJzdHIoMykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFBhcnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2Vjb25kUGFydHMgYXJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB0aGVuIHR3byBvciBvbmUgemVyb3Mgc2hvdWxkIGJlIGFwcGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gaGF2ZSB0aGUgY29ycmVjdCBudW1iZXIgZm9yIG1pbGxpc2Vjb25kcyAoJy42NycgbWVhbnMgNjcwbXMgbm90IDY3bXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgKz0gc2Vjb25kUGFydHMubGVuZ3RoID09PSAyID8gJzAnIDogJzAwJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzFdKSwgLy8geWVhclxyXG4gICAgICAgICAgICAgICAgICAgIChOdW1iZXIobWF0Y2hbM10pIC0gMSkgfHwgMCwgLy8gbW9udGhcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbNV0pIHx8IDAsIC8vIGRheVxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs3XSkgfHwgMCwgLy8gaG91clxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs4XSkgfHwgMCwgLy8gbWludXRlXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzEwXSkgfHwgMCwgLy8gc2Vjb25kXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKHNlY29uZFBhcnRzKSB8fCAwXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMTNdICYmIG1hdGNoWzEzXSAhPT0gXCJaXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gTnVtYmVyKG1hdGNoWzE2XSkgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICBtID0gTnVtYmVyKG1hdGNoWzE3XSkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBoICo9IDM2MDAwMDA7XHJcbiAgICAgICAgICAgICAgICBtICo9IDYwMDAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBoICsgbTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxNV0gPT09IFwiK1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpICsgb2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgvXihcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChcXCt8LSkoXFxkezJ9KTooXFxkezJ9KSkpPyQvLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBUaW1lXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlSXNvRGF0ZVN0cmluZyhzdHJpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKG9iaiwgZnVuYykge1xyXG4gICAgICAgIHZhciBrZXksIHZhbHVlLCBuZXdWYWx1ZTtcclxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBmdW5jKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlKHZhbHVlLCBmdW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZUFuZFJldml2ZTogZnVuY3Rpb24gKGRhdGEsIHJldml2ZXIpIHtcclxuICAgICAgICBpZiAoIXJldml2ZXIpIHtcclxuICAgICAgICAgICAgcmV2aXZlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZShkYXRhLCByZXZpdmVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gKHJldml2ZXIsIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgZXJyb3IubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7bWVzc2FnZTogZXJyb3IubWVzc2FnZSwgY29kZTogZXJyb3IuZXJyb3JDb2RlfTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3BhcnNlSW50ZXJuYWw6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2VBbmRSZXZpdmUoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgX3RyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKGRhdGEsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtyZXN1bHQ6IGRhdGEuUmVzdWx0fTtcclxuICAgICAgICAgICAgXy5leHRlbmQocmVzdWx0LCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcclxuICAgICAgICBkYXRhID0gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3BhcnNlSW50ZXJuYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3RyYW5zZm9ybVJlc3VsdChkYXRhLCB7Y291bnQ6IGRhdGEuQ291bnR9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VTaW5nbGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLl90cmFuc2Zvcm1SZXN1bHQoZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlVXBkYXRlUmVzdWx0OiBmdW5jdGlvbiAocmV2aXZlciwgZGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5fcGFyc2VJbnRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtNb2RpZmllZEF0OiBkYXRhLk1vZGlmaWVkQXR9KTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkUHJvbWlzZSA9IGZ1bmN0aW9uIGJ1aWxkUHJvbWlzZShvcGVyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICB2YXIgY2FsbGJhY2tzID0gdXRpbHMuZ2V0Q2FsbGJhY2tzKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIG9wZXJhdGlvbihjYWxsYmFja3Muc3VjY2VzcywgY2FsbGJhY2tzLmVycm9yKTtcclxuICAgIHJldHVybiBjYWxsYmFja3MucHJvbWlzZTtcclxufTtcclxuXHJcbnV0aWxzLmdldENhbGxiYWNrcyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgdmFyIHByb21pc2U7XHJcbiAgICB2YXIgY3JlYXRlUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc05vZGVqcykge1xyXG4gICAgICAgIC8vIG5vZGUganMgc3R5bGUgY29udGludWF0aW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBzdWNjZXNzO1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlLCBzdWNjZXNzOiBzdWNjZXNzLCBlcnJvcjogZXJyb3J9O1xyXG59O1xyXG5cclxudXRpbHMuYnVpbGRBdXRoSGVhZGVyID0gZnVuY3Rpb24gYnVpbGRBdXRoSGVhZGVyKHNldHVwLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgYXV0aEhlYWRlclZhbHVlID0gbnVsbDtcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0aEhlYWRlcnMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGF1dGhIZWFkZXJWYWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChzZXR1cC50b2tlbikge1xyXG4gICAgICAgIGF1dGhIZWFkZXJWYWx1ZSA9IChzZXR1cC50b2tlblR5cGUgfHwgJ2JlYXJlcicpICsgJyAnICsgc2V0dXAudG9rZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzZXR1cC5tYXN0ZXJLZXkpIHtcclxuICAgICAgICBhdXRoSGVhZGVyVmFsdWUgPSAnbWFzdGVya2V5ICcgKyBzZXR1cC5tYXN0ZXJLZXk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXV0aEhlYWRlclZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtBdXRob3JpemF0aW9uOiBhdXRoSGVhZGVyVmFsdWV9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLkRldmljZVJlZ2lzdHJhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCh0b2tlbikge1xyXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG59O1xyXG5cclxudXRpbHMuY2xvbmVEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkVXJsID0gZnVuY3Rpb24gKHNldHVwKSB7XHJcbiAgICB2YXIgdXJsID0gJyc7XHJcbiAgICBpZiAodHlwZW9mIHNldHVwLnNjaGVtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB1cmwgKz0gc2V0dXAuc2NoZW1lICsgJzonO1xyXG4gICAgfVxyXG4gICAgdXJsICs9IHNldHVwLnVybDtcclxuICAgIGlmIChzZXR1cC5hcGlLZXkpIHtcclxuICAgICAgICB1cmwgKz0gc2V0dXAuYXBpS2V5ICsgJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufTtcclxuXHJcbnV0aWxzLmdldERiT3BlcmF0b3JzID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIHNoYWxsb3cpIHtcclxuICAgIHZhciBkYk9wZXJhdG9ycyA9IFtdO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZGJPcGVyYXRvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vZGlmaWVyS2V5cyA9IE9iamVjdC5rZXlzKGV4cHJlc3Npb24pO1xyXG4gICAgXy5lYWNoKG1vZGlmaWVyS2V5cywgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignJCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRiT3BlcmF0b3JzLnB1c2goa2V5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uW2tleV0gPT09ICdvYmplY3QnICYmICFzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIGRiT3BlcmF0b3JzID0gZGJPcGVyYXRvcnMuY29uY2F0KHV0aWxzLmdldERiT3BlcmF0b3JzKGV4cHJlc3Npb25ba2V5XSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBkYk9wZXJhdG9ycztcclxufTtcclxuXHJcblxyXG52YXIgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyA9IFtcclxuICAgICckZ2VvV2l0aGluJyxcclxuICAgICckZ2VvSW50ZXJzZWN0cycsXHJcbiAgICAnJG5lYXInLFxyXG4gICAgJyR3aXRoaW4nLFxyXG4gICAgJyRuZWFyU3BoZXJlJ1xyXG5dO1xyXG5cclxudXRpbHMuZ2V0VW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICB2YXIgZGJPcGVyYXRvcnMgPSB1dGlscy5nZXREYk9wZXJhdG9ycyhmaWx0ZXIpO1xyXG4gICAgcmV0dXJuIF8uaW50ZXJzZWN0aW9uKGRiT3BlcmF0b3JzLCB1bnN1cHBvcnRlZERiT3BlcmF0b3JzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7XHJcbiJdfQ==
if (typeof module === "object" && typeof exports === "object") { module.exports = Everlive; }